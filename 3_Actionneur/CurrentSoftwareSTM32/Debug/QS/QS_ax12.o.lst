   1              		.syntax unified
   2              		.cpu cortex-m4
   3              		.fpu softvfp
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 6
  11              		.eabi_attribute 34, 1
  12              		.eabi_attribute 18, 4
  13              		.thumb
  14              		.file	"QS_ax12.c"
  15              		.text
  16              	.Ltext0:
  17              		.cfi_sections	.debug_frame
  18              		.align	2
  19              		.thumb
  20              		.thumb_func
  22              	NVIC_EnableIRQ:
  23              	.LFB96:
  24              		.file 1 "../stm32f4xx/core_cm4.h"
   1:../stm32f4xx/core_cm4.h **** /**************************************************************************//**
   2:../stm32f4xx/core_cm4.h ****  * @file     core_cm4.h
   3:../stm32f4xx/core_cm4.h ****  * @brief    CMSIS Cortex-M4 Core Peripheral Access Layer Header File
   4:../stm32f4xx/core_cm4.h ****  * @version  V3.01
   5:../stm32f4xx/core_cm4.h ****  * @date     22. March 2012
   6:../stm32f4xx/core_cm4.h ****  *
   7:../stm32f4xx/core_cm4.h ****  * @note
   8:../stm32f4xx/core_cm4.h ****  * Copyright (C) 2009-2012 ARM Limited. All rights reserved.
   9:../stm32f4xx/core_cm4.h ****  *
  10:../stm32f4xx/core_cm4.h ****  * @par
  11:../stm32f4xx/core_cm4.h ****  * ARM Limited (ARM) is supplying this software for use with Cortex-M
  12:../stm32f4xx/core_cm4.h ****  * processor based microcontrollers.  This file can be freely distributed
  13:../stm32f4xx/core_cm4.h ****  * within development tools that are supporting such ARM based processors.
  14:../stm32f4xx/core_cm4.h ****  *
  15:../stm32f4xx/core_cm4.h ****  * @par
  16:../stm32f4xx/core_cm4.h ****  * THIS SOFTWARE IS PROVIDED "AS IS".  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
  17:../stm32f4xx/core_cm4.h ****  * OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
  18:../stm32f4xx/core_cm4.h ****  * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
  19:../stm32f4xx/core_cm4.h ****  * ARM SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
  20:../stm32f4xx/core_cm4.h ****  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
  21:../stm32f4xx/core_cm4.h ****  *
  22:../stm32f4xx/core_cm4.h ****  ******************************************************************************/
  23:../stm32f4xx/core_cm4.h **** #if defined ( __ICCARM__ )
  24:../stm32f4xx/core_cm4.h ****  #pragma system_include  /* treat file as system include file for MISRA check */
  25:../stm32f4xx/core_cm4.h **** #endif
  26:../stm32f4xx/core_cm4.h **** 
  27:../stm32f4xx/core_cm4.h **** #ifdef __cplusplus
  28:../stm32f4xx/core_cm4.h ****  extern "C" {
  29:../stm32f4xx/core_cm4.h **** #endif
  30:../stm32f4xx/core_cm4.h **** 
  31:../stm32f4xx/core_cm4.h **** #ifndef __CORE_CM4_H_GENERIC
  32:../stm32f4xx/core_cm4.h **** #define __CORE_CM4_H_GENERIC
  33:../stm32f4xx/core_cm4.h **** 
  34:../stm32f4xx/core_cm4.h **** /** \page CMSIS_MISRA_Exceptions  MISRA-C:2004 Compliance Exceptions
  35:../stm32f4xx/core_cm4.h ****   CMSIS violates the following MISRA-C:2004 rules:
  36:../stm32f4xx/core_cm4.h **** 
  37:../stm32f4xx/core_cm4.h ****    \li Required Rule 8.5, object/function definition in header file.<br>
  38:../stm32f4xx/core_cm4.h ****      Function definitions in header files are used to allow 'inlining'.
  39:../stm32f4xx/core_cm4.h **** 
  40:../stm32f4xx/core_cm4.h ****    \li Required Rule 18.4, declaration of union type or object of union type: '{...}'.<br>
  41:../stm32f4xx/core_cm4.h ****      Unions are used for effective representation of core registers.
  42:../stm32f4xx/core_cm4.h **** 
  43:../stm32f4xx/core_cm4.h ****    \li Advisory Rule 19.7, Function-like macro defined.<br>
  44:../stm32f4xx/core_cm4.h ****      Function-like macros are used to allow more efficient code.
  45:../stm32f4xx/core_cm4.h ****  */
  46:../stm32f4xx/core_cm4.h **** 
  47:../stm32f4xx/core_cm4.h **** 
  48:../stm32f4xx/core_cm4.h **** /*******************************************************************************
  49:../stm32f4xx/core_cm4.h ****  *                 CMSIS definitions
  50:../stm32f4xx/core_cm4.h ****  ******************************************************************************/
  51:../stm32f4xx/core_cm4.h **** /** \ingroup Cortex_M4
  52:../stm32f4xx/core_cm4.h ****   @{
  53:../stm32f4xx/core_cm4.h ****  */
  54:../stm32f4xx/core_cm4.h **** 
  55:../stm32f4xx/core_cm4.h **** /*  CMSIS CM4 definitions */
  56:../stm32f4xx/core_cm4.h **** #define __CM4_CMSIS_VERSION_MAIN  (0x03)                                   /*!< [31:16] CMSIS HAL m
  57:../stm32f4xx/core_cm4.h **** #define __CM4_CMSIS_VERSION_SUB   (0x01)                                   /*!< [15:0]  CMSIS HAL s
  58:../stm32f4xx/core_cm4.h **** #define __CM4_CMSIS_VERSION       ((__CM4_CMSIS_VERSION_MAIN << 16) | \
  59:../stm32f4xx/core_cm4.h ****                                     __CM4_CMSIS_VERSION_SUB          )     /*!< CMSIS HAL version n
  60:../stm32f4xx/core_cm4.h **** 
  61:../stm32f4xx/core_cm4.h **** #define __CORTEX_M                (0x04)                                   /*!< Cortex-M Core      
  62:../stm32f4xx/core_cm4.h **** 
  63:../stm32f4xx/core_cm4.h **** 
  64:../stm32f4xx/core_cm4.h **** #if   defined ( __CC_ARM )
  65:../stm32f4xx/core_cm4.h ****   #define __ASM            __asm                                      /*!< asm keyword for ARM Comp
  66:../stm32f4xx/core_cm4.h ****   #define __INLINE         __inline                                   /*!< inline keyword for ARM C
  67:../stm32f4xx/core_cm4.h ****   #define __STATIC_INLINE  static __inline
  68:../stm32f4xx/core_cm4.h **** 
  69:../stm32f4xx/core_cm4.h **** #elif defined ( __ICCARM__ )
  70:../stm32f4xx/core_cm4.h ****   #define __ASM            __asm                                      /*!< asm keyword for IAR Comp
  71:../stm32f4xx/core_cm4.h ****   #define __INLINE         inline                                     /*!< inline keyword for IAR C
  72:../stm32f4xx/core_cm4.h ****   #define __STATIC_INLINE  static inline
  73:../stm32f4xx/core_cm4.h **** 
  74:../stm32f4xx/core_cm4.h **** #elif defined ( __TMS470__ )
  75:../stm32f4xx/core_cm4.h ****   #define __ASM            __asm                                      /*!< asm keyword for TI CCS C
  76:../stm32f4xx/core_cm4.h ****   #define __STATIC_INLINE  static inline
  77:../stm32f4xx/core_cm4.h **** 
  78:../stm32f4xx/core_cm4.h **** #elif defined ( __GNUC__ )
  79:../stm32f4xx/core_cm4.h ****   #define __ASM            __asm                                      /*!< asm keyword for GNU Comp
  80:../stm32f4xx/core_cm4.h ****   #define __INLINE         inline                                     /*!< inline keyword for GNU C
  81:../stm32f4xx/core_cm4.h ****   #define __STATIC_INLINE  static inline
  82:../stm32f4xx/core_cm4.h **** 
  83:../stm32f4xx/core_cm4.h **** #elif defined ( __TASKING__ )
  84:../stm32f4xx/core_cm4.h ****   #define __ASM            __asm                                      /*!< asm keyword for TASKING 
  85:../stm32f4xx/core_cm4.h ****   #define __INLINE         inline                                     /*!< inline keyword for TASKI
  86:../stm32f4xx/core_cm4.h ****   #define __STATIC_INLINE  static inline
  87:../stm32f4xx/core_cm4.h **** 
  88:../stm32f4xx/core_cm4.h **** #endif
  89:../stm32f4xx/core_cm4.h **** 
  90:../stm32f4xx/core_cm4.h **** /** __FPU_USED indicates whether an FPU is used or not. For this, __FPU_PRESENT has to be checked p
  91:../stm32f4xx/core_cm4.h **** */
  92:../stm32f4xx/core_cm4.h **** #if defined ( __CC_ARM )
  93:../stm32f4xx/core_cm4.h ****   #if defined __TARGET_FPU_VFP
  94:../stm32f4xx/core_cm4.h ****     #if (__FPU_PRESENT == 1)
  95:../stm32f4xx/core_cm4.h ****       #define __FPU_USED       1
  96:../stm32f4xx/core_cm4.h ****     #else
  97:../stm32f4xx/core_cm4.h ****       #warning "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESEN
  98:../stm32f4xx/core_cm4.h ****       #define __FPU_USED       0
  99:../stm32f4xx/core_cm4.h ****     #endif
 100:../stm32f4xx/core_cm4.h ****   #else
 101:../stm32f4xx/core_cm4.h ****     #define __FPU_USED         0
 102:../stm32f4xx/core_cm4.h ****   #endif
 103:../stm32f4xx/core_cm4.h **** 
 104:../stm32f4xx/core_cm4.h **** #elif defined ( __ICCARM__ )
 105:../stm32f4xx/core_cm4.h ****   #if defined __ARMVFP__
 106:../stm32f4xx/core_cm4.h ****     #if (__FPU_PRESENT == 1)
 107:../stm32f4xx/core_cm4.h ****       #define __FPU_USED       1
 108:../stm32f4xx/core_cm4.h ****     #else
 109:../stm32f4xx/core_cm4.h ****       #warning "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESEN
 110:../stm32f4xx/core_cm4.h ****       #define __FPU_USED       0
 111:../stm32f4xx/core_cm4.h ****     #endif
 112:../stm32f4xx/core_cm4.h ****   #else
 113:../stm32f4xx/core_cm4.h ****     #define __FPU_USED         0
 114:../stm32f4xx/core_cm4.h ****   #endif
 115:../stm32f4xx/core_cm4.h **** 
 116:../stm32f4xx/core_cm4.h **** #elif defined ( __TMS470__ )
 117:../stm32f4xx/core_cm4.h ****   #if defined __TI_VFP_SUPPORT__
 118:../stm32f4xx/core_cm4.h ****     #if (__FPU_PRESENT == 1)
 119:../stm32f4xx/core_cm4.h ****       #define __FPU_USED       1
 120:../stm32f4xx/core_cm4.h ****     #else
 121:../stm32f4xx/core_cm4.h ****       #warning "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESEN
 122:../stm32f4xx/core_cm4.h ****       #define __FPU_USED       0
 123:../stm32f4xx/core_cm4.h ****     #endif
 124:../stm32f4xx/core_cm4.h ****   #else
 125:../stm32f4xx/core_cm4.h ****     #define __FPU_USED         0
 126:../stm32f4xx/core_cm4.h ****   #endif
 127:../stm32f4xx/core_cm4.h **** 
 128:../stm32f4xx/core_cm4.h **** #elif defined ( __GNUC__ )
 129:../stm32f4xx/core_cm4.h ****   #if defined (__VFP_FP__) && !defined(__SOFTFP__)
 130:../stm32f4xx/core_cm4.h ****     #if (__FPU_PRESENT == 1)
 131:../stm32f4xx/core_cm4.h ****       #define __FPU_USED       1
 132:../stm32f4xx/core_cm4.h ****     #else
 133:../stm32f4xx/core_cm4.h ****       #warning "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESEN
 134:../stm32f4xx/core_cm4.h ****       #define __FPU_USED       0
 135:../stm32f4xx/core_cm4.h ****     #endif
 136:../stm32f4xx/core_cm4.h ****   #else
 137:../stm32f4xx/core_cm4.h ****     #define __FPU_USED         0
 138:../stm32f4xx/core_cm4.h ****   #endif
 139:../stm32f4xx/core_cm4.h **** 
 140:../stm32f4xx/core_cm4.h **** #elif defined ( __TASKING__ )
 141:../stm32f4xx/core_cm4.h ****   #if defined __FPU_VFP__
 142:../stm32f4xx/core_cm4.h ****     #if (__FPU_PRESENT == 1)
 143:../stm32f4xx/core_cm4.h ****       #define __FPU_USED       1
 144:../stm32f4xx/core_cm4.h ****     #else
 145:../stm32f4xx/core_cm4.h ****       #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)
 146:../stm32f4xx/core_cm4.h ****       #define __FPU_USED       0
 147:../stm32f4xx/core_cm4.h ****     #endif
 148:../stm32f4xx/core_cm4.h ****   #else
 149:../stm32f4xx/core_cm4.h ****     #define __FPU_USED         0
 150:../stm32f4xx/core_cm4.h ****   #endif
 151:../stm32f4xx/core_cm4.h **** #endif
 152:../stm32f4xx/core_cm4.h **** 
 153:../stm32f4xx/core_cm4.h **** #include <stdint.h>                      /* standard types definitions                      */
 154:../stm32f4xx/core_cm4.h **** #include <core_cmInstr.h>                /* Core Instruction Access                         */
 155:../stm32f4xx/core_cm4.h **** #include <core_cmFunc.h>                 /* Core Function Access                            */
 156:../stm32f4xx/core_cm4.h **** #include <core_cm4_simd.h>               /* Compiler specific SIMD Intrinsics               */
 157:../stm32f4xx/core_cm4.h **** 
 158:../stm32f4xx/core_cm4.h **** #endif /* __CORE_CM4_H_GENERIC */
 159:../stm32f4xx/core_cm4.h **** 
 160:../stm32f4xx/core_cm4.h **** #ifndef __CMSIS_GENERIC
 161:../stm32f4xx/core_cm4.h **** 
 162:../stm32f4xx/core_cm4.h **** #ifndef __CORE_CM4_H_DEPENDANT
 163:../stm32f4xx/core_cm4.h **** #define __CORE_CM4_H_DEPENDANT
 164:../stm32f4xx/core_cm4.h **** 
 165:../stm32f4xx/core_cm4.h **** /* check device defines and use defaults */
 166:../stm32f4xx/core_cm4.h **** #if defined __CHECK_DEVICE_DEFINES
 167:../stm32f4xx/core_cm4.h ****   #ifndef __CM4_REV
 168:../stm32f4xx/core_cm4.h ****     #define __CM4_REV               0x0000
 169:../stm32f4xx/core_cm4.h ****     #warning "__CM4_REV not defined in device header file; using default!"
 170:../stm32f4xx/core_cm4.h ****   #endif
 171:../stm32f4xx/core_cm4.h **** 
 172:../stm32f4xx/core_cm4.h ****   #ifndef __FPU_PRESENT
 173:../stm32f4xx/core_cm4.h ****     #define __FPU_PRESENT             0
 174:../stm32f4xx/core_cm4.h ****     #warning "__FPU_PRESENT not defined in device header file; using default!"
 175:../stm32f4xx/core_cm4.h ****   #endif
 176:../stm32f4xx/core_cm4.h **** 
 177:../stm32f4xx/core_cm4.h ****   #ifndef __MPU_PRESENT
 178:../stm32f4xx/core_cm4.h ****     #define __MPU_PRESENT             0
 179:../stm32f4xx/core_cm4.h ****     #warning "__MPU_PRESENT not defined in device header file; using default!"
 180:../stm32f4xx/core_cm4.h ****   #endif
 181:../stm32f4xx/core_cm4.h **** 
 182:../stm32f4xx/core_cm4.h ****   #ifndef __NVIC_PRIO_BITS
 183:../stm32f4xx/core_cm4.h ****     #define __NVIC_PRIO_BITS          4
 184:../stm32f4xx/core_cm4.h ****     #warning "__NVIC_PRIO_BITS not defined in device header file; using default!"
 185:../stm32f4xx/core_cm4.h ****   #endif
 186:../stm32f4xx/core_cm4.h **** 
 187:../stm32f4xx/core_cm4.h ****   #ifndef __Vendor_SysTickConfig
 188:../stm32f4xx/core_cm4.h ****     #define __Vendor_SysTickConfig    0
 189:../stm32f4xx/core_cm4.h ****     #warning "__Vendor_SysTickConfig not defined in device header file; using default!"
 190:../stm32f4xx/core_cm4.h ****   #endif
 191:../stm32f4xx/core_cm4.h **** #endif
 192:../stm32f4xx/core_cm4.h **** 
 193:../stm32f4xx/core_cm4.h **** /* IO definitions (access restrictions to peripheral registers) */
 194:../stm32f4xx/core_cm4.h **** /**
 195:../stm32f4xx/core_cm4.h ****     \defgroup CMSIS_glob_defs CMSIS Global Defines
 196:../stm32f4xx/core_cm4.h **** 
 197:../stm32f4xx/core_cm4.h ****     <strong>IO Type Qualifiers</strong> are used
 198:../stm32f4xx/core_cm4.h ****     \li to specify the access to peripheral variables.
 199:../stm32f4xx/core_cm4.h ****     \li for automatic generation of peripheral register debug information.
 200:../stm32f4xx/core_cm4.h **** */
 201:../stm32f4xx/core_cm4.h **** #ifdef __cplusplus
 202:../stm32f4xx/core_cm4.h ****   #define   __I     volatile             /*!< Defines 'read only' permissions                 */
 203:../stm32f4xx/core_cm4.h **** #else
 204:../stm32f4xx/core_cm4.h ****   #define   __I     volatile const       /*!< Defines 'read only' permissions                 */
 205:../stm32f4xx/core_cm4.h **** #endif
 206:../stm32f4xx/core_cm4.h **** #define     __O     volatile             /*!< Defines 'write only' permissions                */
 207:../stm32f4xx/core_cm4.h **** #define     __IO    volatile             /*!< Defines 'read / write' permissions              */
 208:../stm32f4xx/core_cm4.h **** 
 209:../stm32f4xx/core_cm4.h **** /*@} end of group Cortex_M4 */
 210:../stm32f4xx/core_cm4.h **** 
 211:../stm32f4xx/core_cm4.h **** 
 212:../stm32f4xx/core_cm4.h **** 
 213:../stm32f4xx/core_cm4.h **** /*******************************************************************************
 214:../stm32f4xx/core_cm4.h ****  *                 Register Abstraction
 215:../stm32f4xx/core_cm4.h ****   Core Register contain:
 216:../stm32f4xx/core_cm4.h ****   - Core Register
 217:../stm32f4xx/core_cm4.h ****   - Core NVIC Register
 218:../stm32f4xx/core_cm4.h ****   - Core SCB Register
 219:../stm32f4xx/core_cm4.h ****   - Core SysTick Register
 220:../stm32f4xx/core_cm4.h ****   - Core Debug Register
 221:../stm32f4xx/core_cm4.h ****   - Core MPU Register
 222:../stm32f4xx/core_cm4.h ****   - Core FPU Register
 223:../stm32f4xx/core_cm4.h ****  ******************************************************************************/
 224:../stm32f4xx/core_cm4.h **** /** \defgroup CMSIS_core_register Defines and Type Definitions
 225:../stm32f4xx/core_cm4.h ****     \brief Type definitions and defines for Cortex-M processor based devices.
 226:../stm32f4xx/core_cm4.h **** */
 227:../stm32f4xx/core_cm4.h **** 
 228:../stm32f4xx/core_cm4.h **** /** \ingroup    CMSIS_core_register
 229:../stm32f4xx/core_cm4.h ****     \defgroup   CMSIS_CORE  Status and Control Registers
 230:../stm32f4xx/core_cm4.h ****     \brief  Core Register type definitions.
 231:../stm32f4xx/core_cm4.h ****   @{
 232:../stm32f4xx/core_cm4.h ****  */
 233:../stm32f4xx/core_cm4.h **** 
 234:../stm32f4xx/core_cm4.h **** /** \brief  Union type to access the Application Program Status Register (APSR).
 235:../stm32f4xx/core_cm4.h ****  */
 236:../stm32f4xx/core_cm4.h **** typedef union
 237:../stm32f4xx/core_cm4.h **** {
 238:../stm32f4xx/core_cm4.h ****   struct
 239:../stm32f4xx/core_cm4.h ****   {
 240:../stm32f4xx/core_cm4.h **** #if (__CORTEX_M != 0x04)
 241:../stm32f4xx/core_cm4.h ****     uint32_t _reserved0:27;              /*!< bit:  0..26  Reserved                           */
 242:../stm32f4xx/core_cm4.h **** #else
 243:../stm32f4xx/core_cm4.h ****     uint32_t _reserved0:16;              /*!< bit:  0..15  Reserved                           */
 244:../stm32f4xx/core_cm4.h ****     uint32_t GE:4;                       /*!< bit: 16..19  Greater than or Equal flags        */
 245:../stm32f4xx/core_cm4.h ****     uint32_t _reserved1:7;               /*!< bit: 20..26  Reserved                           */
 246:../stm32f4xx/core_cm4.h **** #endif
 247:../stm32f4xx/core_cm4.h ****     uint32_t Q:1;                        /*!< bit:     27  Saturation condition flag          */
 248:../stm32f4xx/core_cm4.h ****     uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag       */
 249:../stm32f4xx/core_cm4.h ****     uint32_t C:1;                        /*!< bit:     29  Carry condition code flag          */
 250:../stm32f4xx/core_cm4.h ****     uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag           */
 251:../stm32f4xx/core_cm4.h ****     uint32_t N:1;                        /*!< bit:     31  Negative condition code flag       */
 252:../stm32f4xx/core_cm4.h ****   } b;                                   /*!< Structure used for bit  access                  */
 253:../stm32f4xx/core_cm4.h ****   uint32_t w;                            /*!< Type      used for word access                  */
 254:../stm32f4xx/core_cm4.h **** } APSR_Type;
 255:../stm32f4xx/core_cm4.h **** 
 256:../stm32f4xx/core_cm4.h **** 
 257:../stm32f4xx/core_cm4.h **** /** \brief  Union type to access the Interrupt Program Status Register (IPSR).
 258:../stm32f4xx/core_cm4.h ****  */
 259:../stm32f4xx/core_cm4.h **** typedef union
 260:../stm32f4xx/core_cm4.h **** {
 261:../stm32f4xx/core_cm4.h ****   struct
 262:../stm32f4xx/core_cm4.h ****   {
 263:../stm32f4xx/core_cm4.h ****     uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number                   */
 264:../stm32f4xx/core_cm4.h ****     uint32_t _reserved0:23;              /*!< bit:  9..31  Reserved                           */
 265:../stm32f4xx/core_cm4.h ****   } b;                                   /*!< Structure used for bit  access                  */
 266:../stm32f4xx/core_cm4.h ****   uint32_t w;                            /*!< Type      used for word access                  */
 267:../stm32f4xx/core_cm4.h **** } IPSR_Type;
 268:../stm32f4xx/core_cm4.h **** 
 269:../stm32f4xx/core_cm4.h **** 
 270:../stm32f4xx/core_cm4.h **** /** \brief  Union type to access the Special-Purpose Program Status Registers (xPSR).
 271:../stm32f4xx/core_cm4.h ****  */
 272:../stm32f4xx/core_cm4.h **** typedef union
 273:../stm32f4xx/core_cm4.h **** {
 274:../stm32f4xx/core_cm4.h ****   struct
 275:../stm32f4xx/core_cm4.h ****   {
 276:../stm32f4xx/core_cm4.h ****     uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number                   */
 277:../stm32f4xx/core_cm4.h **** #if (__CORTEX_M != 0x04)
 278:../stm32f4xx/core_cm4.h ****     uint32_t _reserved0:15;              /*!< bit:  9..23  Reserved                           */
 279:../stm32f4xx/core_cm4.h **** #else
 280:../stm32f4xx/core_cm4.h ****     uint32_t _reserved0:7;               /*!< bit:  9..15  Reserved                           */
 281:../stm32f4xx/core_cm4.h ****     uint32_t GE:4;                       /*!< bit: 16..19  Greater than or Equal flags        */
 282:../stm32f4xx/core_cm4.h ****     uint32_t _reserved1:4;               /*!< bit: 20..23  Reserved                           */
 283:../stm32f4xx/core_cm4.h **** #endif
 284:../stm32f4xx/core_cm4.h ****     uint32_t T:1;                        /*!< bit:     24  Thumb bit        (read 0)          */
 285:../stm32f4xx/core_cm4.h ****     uint32_t IT:2;                       /*!< bit: 25..26  saved IT state   (read 0)          */
 286:../stm32f4xx/core_cm4.h ****     uint32_t Q:1;                        /*!< bit:     27  Saturation condition flag          */
 287:../stm32f4xx/core_cm4.h ****     uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag       */
 288:../stm32f4xx/core_cm4.h ****     uint32_t C:1;                        /*!< bit:     29  Carry condition code flag          */
 289:../stm32f4xx/core_cm4.h ****     uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag           */
 290:../stm32f4xx/core_cm4.h ****     uint32_t N:1;                        /*!< bit:     31  Negative condition code flag       */
 291:../stm32f4xx/core_cm4.h ****   } b;                                   /*!< Structure used for bit  access                  */
 292:../stm32f4xx/core_cm4.h ****   uint32_t w;                            /*!< Type      used for word access                  */
 293:../stm32f4xx/core_cm4.h **** } xPSR_Type;
 294:../stm32f4xx/core_cm4.h **** 
 295:../stm32f4xx/core_cm4.h **** 
 296:../stm32f4xx/core_cm4.h **** /** \brief  Union type to access the Control Registers (CONTROL).
 297:../stm32f4xx/core_cm4.h ****  */
 298:../stm32f4xx/core_cm4.h **** typedef union
 299:../stm32f4xx/core_cm4.h **** {
 300:../stm32f4xx/core_cm4.h ****   struct
 301:../stm32f4xx/core_cm4.h ****   {
 302:../stm32f4xx/core_cm4.h ****     uint32_t nPRIV:1;                    /*!< bit:      0  Execution privilege in Thread mode */
 303:../stm32f4xx/core_cm4.h ****     uint32_t SPSEL:1;                    /*!< bit:      1  Stack to be used                   */
 304:../stm32f4xx/core_cm4.h ****     uint32_t FPCA:1;                     /*!< bit:      2  FP extension active flag           */
 305:../stm32f4xx/core_cm4.h ****     uint32_t _reserved0:29;              /*!< bit:  3..31  Reserved                           */
 306:../stm32f4xx/core_cm4.h ****   } b;                                   /*!< Structure used for bit  access                  */
 307:../stm32f4xx/core_cm4.h ****   uint32_t w;                            /*!< Type      used for word access                  */
 308:../stm32f4xx/core_cm4.h **** } CONTROL_Type;
 309:../stm32f4xx/core_cm4.h **** 
 310:../stm32f4xx/core_cm4.h **** /*@} end of group CMSIS_CORE */
 311:../stm32f4xx/core_cm4.h **** 
 312:../stm32f4xx/core_cm4.h **** 
 313:../stm32f4xx/core_cm4.h **** /** \ingroup    CMSIS_core_register
 314:../stm32f4xx/core_cm4.h ****     \defgroup   CMSIS_NVIC  Nested Vectored Interrupt Controller (NVIC)
 315:../stm32f4xx/core_cm4.h ****     \brief      Type definitions for the NVIC Registers
 316:../stm32f4xx/core_cm4.h ****   @{
 317:../stm32f4xx/core_cm4.h ****  */
 318:../stm32f4xx/core_cm4.h **** 
 319:../stm32f4xx/core_cm4.h **** /** \brief  Structure type to access the Nested Vectored Interrupt Controller (NVIC).
 320:../stm32f4xx/core_cm4.h ****  */
 321:../stm32f4xx/core_cm4.h **** typedef struct
 322:../stm32f4xx/core_cm4.h **** {
 323:../stm32f4xx/core_cm4.h ****   __IO uint32_t ISER[8];                 /*!< Offset: 0x000 (R/W)  Interrupt Set Enable Register   
 324:../stm32f4xx/core_cm4.h ****        uint32_t RESERVED0[24];
 325:../stm32f4xx/core_cm4.h ****   __IO uint32_t ICER[8];                 /*!< Offset: 0x080 (R/W)  Interrupt Clear Enable Register 
 326:../stm32f4xx/core_cm4.h ****        uint32_t RSERVED1[24];
 327:../stm32f4xx/core_cm4.h ****   __IO uint32_t ISPR[8];                 /*!< Offset: 0x100 (R/W)  Interrupt Set Pending Register  
 328:../stm32f4xx/core_cm4.h ****        uint32_t RESERVED2[24];
 329:../stm32f4xx/core_cm4.h ****   __IO uint32_t ICPR[8];                 /*!< Offset: 0x180 (R/W)  Interrupt Clear Pending Register
 330:../stm32f4xx/core_cm4.h ****        uint32_t RESERVED3[24];
 331:../stm32f4xx/core_cm4.h ****   __IO uint32_t IABR[8];                 /*!< Offset: 0x200 (R/W)  Interrupt Active bit Register   
 332:../stm32f4xx/core_cm4.h ****        uint32_t RESERVED4[56];
 333:../stm32f4xx/core_cm4.h ****   __IO uint8_t  IP[240];                 /*!< Offset: 0x300 (R/W)  Interrupt Priority Register (8Bi
 334:../stm32f4xx/core_cm4.h ****        uint32_t RESERVED5[644];
 335:../stm32f4xx/core_cm4.h ****   __O  uint32_t STIR;                    /*!< Offset: 0xE00 ( /W)  Software Trigger Interrupt Regis
 336:../stm32f4xx/core_cm4.h **** }  NVIC_Type;
 337:../stm32f4xx/core_cm4.h **** 
 338:../stm32f4xx/core_cm4.h **** /* Software Triggered Interrupt Register Definitions */
 339:../stm32f4xx/core_cm4.h **** #define NVIC_STIR_INTID_Pos                 0                                          /*!< STIR: I
 340:../stm32f4xx/core_cm4.h **** #define NVIC_STIR_INTID_Msk                (0x1FFUL << NVIC_STIR_INTID_Pos)            /*!< STIR: I
 341:../stm32f4xx/core_cm4.h **** 
 342:../stm32f4xx/core_cm4.h **** /*@} end of group CMSIS_NVIC */
 343:../stm32f4xx/core_cm4.h **** 
 344:../stm32f4xx/core_cm4.h **** 
 345:../stm32f4xx/core_cm4.h **** /** \ingroup  CMSIS_core_register
 346:../stm32f4xx/core_cm4.h ****     \defgroup CMSIS_SCB     System Control Block (SCB)
 347:../stm32f4xx/core_cm4.h ****     \brief      Type definitions for the System Control Block Registers
 348:../stm32f4xx/core_cm4.h ****   @{
 349:../stm32f4xx/core_cm4.h ****  */
 350:../stm32f4xx/core_cm4.h **** 
 351:../stm32f4xx/core_cm4.h **** /** \brief  Structure type to access the System Control Block (SCB).
 352:../stm32f4xx/core_cm4.h ****  */
 353:../stm32f4xx/core_cm4.h **** typedef struct
 354:../stm32f4xx/core_cm4.h **** {
 355:../stm32f4xx/core_cm4.h ****   __I  uint32_t CPUID;                   /*!< Offset: 0x000 (R/ )  CPUID Base Register             
 356:../stm32f4xx/core_cm4.h ****   __IO uint32_t ICSR;                    /*!< Offset: 0x004 (R/W)  Interrupt Control and State Regi
 357:../stm32f4xx/core_cm4.h ****   __IO uint32_t VTOR;                    /*!< Offset: 0x008 (R/W)  Vector Table Offset Register    
 358:../stm32f4xx/core_cm4.h ****   __IO uint32_t AIRCR;                   /*!< Offset: 0x00C (R/W)  Application Interrupt and Reset 
 359:../stm32f4xx/core_cm4.h ****   __IO uint32_t SCR;                     /*!< Offset: 0x010 (R/W)  System Control Register         
 360:../stm32f4xx/core_cm4.h ****   __IO uint32_t CCR;                     /*!< Offset: 0x014 (R/W)  Configuration Control Register  
 361:../stm32f4xx/core_cm4.h ****   __IO uint8_t  SHP[12];                 /*!< Offset: 0x018 (R/W)  System Handlers Priority Registe
 362:../stm32f4xx/core_cm4.h ****   __IO uint32_t SHCSR;                   /*!< Offset: 0x024 (R/W)  System Handler Control and State
 363:../stm32f4xx/core_cm4.h ****   __IO uint32_t CFSR;                    /*!< Offset: 0x028 (R/W)  Configurable Fault Status Regist
 364:../stm32f4xx/core_cm4.h ****   __IO uint32_t HFSR;                    /*!< Offset: 0x02C (R/W)  HardFault Status Register       
 365:../stm32f4xx/core_cm4.h ****   __IO uint32_t DFSR;                    /*!< Offset: 0x030 (R/W)  Debug Fault Status Register     
 366:../stm32f4xx/core_cm4.h ****   __IO uint32_t MMFAR;                   /*!< Offset: 0x034 (R/W)  MemManage Fault Address Register
 367:../stm32f4xx/core_cm4.h ****   __IO uint32_t BFAR;                    /*!< Offset: 0x038 (R/W)  BusFault Address Register       
 368:../stm32f4xx/core_cm4.h ****   __IO uint32_t AFSR;                    /*!< Offset: 0x03C (R/W)  Auxiliary Fault Status Register 
 369:../stm32f4xx/core_cm4.h ****   __I  uint32_t PFR[2];                  /*!< Offset: 0x040 (R/ )  Processor Feature Register      
 370:../stm32f4xx/core_cm4.h ****   __I  uint32_t DFR;                     /*!< Offset: 0x048 (R/ )  Debug Feature Register          
 371:../stm32f4xx/core_cm4.h ****   __I  uint32_t ADR;                     /*!< Offset: 0x04C (R/ )  Auxiliary Feature Register      
 372:../stm32f4xx/core_cm4.h ****   __I  uint32_t MMFR[4];                 /*!< Offset: 0x050 (R/ )  Memory Model Feature Register   
 373:../stm32f4xx/core_cm4.h ****   __I  uint32_t ISAR[5];                 /*!< Offset: 0x060 (R/ )  Instruction Set Attributes Regis
 374:../stm32f4xx/core_cm4.h ****        uint32_t RESERVED0[5];
 375:../stm32f4xx/core_cm4.h ****   __IO uint32_t CPACR;                   /*!< Offset: 0x088 (R/W)  Coprocessor Access Control Regis
 376:../stm32f4xx/core_cm4.h **** } SCB_Type;
 377:../stm32f4xx/core_cm4.h **** 
 378:../stm32f4xx/core_cm4.h **** /* SCB CPUID Register Definitions */
 379:../stm32f4xx/core_cm4.h **** #define SCB_CPUID_IMPLEMENTER_Pos          24                                             /*!< SCB 
 380:../stm32f4xx/core_cm4.h **** #define SCB_CPUID_IMPLEMENTER_Msk          (0xFFUL << SCB_CPUID_IMPLEMENTER_Pos)          /*!< SCB 
 381:../stm32f4xx/core_cm4.h **** 
 382:../stm32f4xx/core_cm4.h **** #define SCB_CPUID_VARIANT_Pos              20                                             /*!< SCB 
 383:../stm32f4xx/core_cm4.h **** #define SCB_CPUID_VARIANT_Msk              (0xFUL << SCB_CPUID_VARIANT_Pos)               /*!< SCB 
 384:../stm32f4xx/core_cm4.h **** 
 385:../stm32f4xx/core_cm4.h **** #define SCB_CPUID_ARCHITECTURE_Pos         16                                             /*!< SCB 
 386:../stm32f4xx/core_cm4.h **** #define SCB_CPUID_ARCHITECTURE_Msk         (0xFUL << SCB_CPUID_ARCHITECTURE_Pos)          /*!< SCB 
 387:../stm32f4xx/core_cm4.h **** 
 388:../stm32f4xx/core_cm4.h **** #define SCB_CPUID_PARTNO_Pos                4                                             /*!< SCB 
 389:../stm32f4xx/core_cm4.h **** #define SCB_CPUID_PARTNO_Msk               (0xFFFUL << SCB_CPUID_PARTNO_Pos)              /*!< SCB 
 390:../stm32f4xx/core_cm4.h **** 
 391:../stm32f4xx/core_cm4.h **** #define SCB_CPUID_REVISION_Pos              0                                             /*!< SCB 
 392:../stm32f4xx/core_cm4.h **** #define SCB_CPUID_REVISION_Msk             (0xFUL << SCB_CPUID_REVISION_Pos)              /*!< SCB 
 393:../stm32f4xx/core_cm4.h **** 
 394:../stm32f4xx/core_cm4.h **** /* SCB Interrupt Control State Register Definitions */
 395:../stm32f4xx/core_cm4.h **** #define SCB_ICSR_NMIPENDSET_Pos            31                                             /*!< SCB 
 396:../stm32f4xx/core_cm4.h **** #define SCB_ICSR_NMIPENDSET_Msk            (1UL << SCB_ICSR_NMIPENDSET_Pos)               /*!< SCB 
 397:../stm32f4xx/core_cm4.h **** 
 398:../stm32f4xx/core_cm4.h **** #define SCB_ICSR_PENDSVSET_Pos             28                                             /*!< SCB 
 399:../stm32f4xx/core_cm4.h **** #define SCB_ICSR_PENDSVSET_Msk             (1UL << SCB_ICSR_PENDSVSET_Pos)                /*!< SCB 
 400:../stm32f4xx/core_cm4.h **** 
 401:../stm32f4xx/core_cm4.h **** #define SCB_ICSR_PENDSVCLR_Pos             27                                             /*!< SCB 
 402:../stm32f4xx/core_cm4.h **** #define SCB_ICSR_PENDSVCLR_Msk             (1UL << SCB_ICSR_PENDSVCLR_Pos)                /*!< SCB 
 403:../stm32f4xx/core_cm4.h **** 
 404:../stm32f4xx/core_cm4.h **** #define SCB_ICSR_PENDSTSET_Pos             26                                             /*!< SCB 
 405:../stm32f4xx/core_cm4.h **** #define SCB_ICSR_PENDSTSET_Msk             (1UL << SCB_ICSR_PENDSTSET_Pos)                /*!< SCB 
 406:../stm32f4xx/core_cm4.h **** 
 407:../stm32f4xx/core_cm4.h **** #define SCB_ICSR_PENDSTCLR_Pos             25                                             /*!< SCB 
 408:../stm32f4xx/core_cm4.h **** #define SCB_ICSR_PENDSTCLR_Msk             (1UL << SCB_ICSR_PENDSTCLR_Pos)                /*!< SCB 
 409:../stm32f4xx/core_cm4.h **** 
 410:../stm32f4xx/core_cm4.h **** #define SCB_ICSR_ISRPREEMPT_Pos            23                                             /*!< SCB 
 411:../stm32f4xx/core_cm4.h **** #define SCB_ICSR_ISRPREEMPT_Msk            (1UL << SCB_ICSR_ISRPREEMPT_Pos)               /*!< SCB 
 412:../stm32f4xx/core_cm4.h **** 
 413:../stm32f4xx/core_cm4.h **** #define SCB_ICSR_ISRPENDING_Pos            22                                             /*!< SCB 
 414:../stm32f4xx/core_cm4.h **** #define SCB_ICSR_ISRPENDING_Msk            (1UL << SCB_ICSR_ISRPENDING_Pos)               /*!< SCB 
 415:../stm32f4xx/core_cm4.h **** 
 416:../stm32f4xx/core_cm4.h **** #define SCB_ICSR_VECTPENDING_Pos           12                                             /*!< SCB 
 417:../stm32f4xx/core_cm4.h **** #define SCB_ICSR_VECTPENDING_Msk           (0x1FFUL << SCB_ICSR_VECTPENDING_Pos)          /*!< SCB 
 418:../stm32f4xx/core_cm4.h **** 
 419:../stm32f4xx/core_cm4.h **** #define SCB_ICSR_RETTOBASE_Pos             11                                             /*!< SCB 
 420:../stm32f4xx/core_cm4.h **** #define SCB_ICSR_RETTOBASE_Msk             (1UL << SCB_ICSR_RETTOBASE_Pos)                /*!< SCB 
 421:../stm32f4xx/core_cm4.h **** 
 422:../stm32f4xx/core_cm4.h **** #define SCB_ICSR_VECTACTIVE_Pos             0                                             /*!< SCB 
 423:../stm32f4xx/core_cm4.h **** #define SCB_ICSR_VECTACTIVE_Msk            (0x1FFUL << SCB_ICSR_VECTACTIVE_Pos)           /*!< SCB 
 424:../stm32f4xx/core_cm4.h **** 
 425:../stm32f4xx/core_cm4.h **** /* SCB Vector Table Offset Register Definitions */
 426:../stm32f4xx/core_cm4.h **** #define SCB_VTOR_TBLOFF_Pos                 7                                             /*!< SCB 
 427:../stm32f4xx/core_cm4.h **** #define SCB_VTOR_TBLOFF_Msk                (0x1FFFFFFUL << SCB_VTOR_TBLOFF_Pos)           /*!< SCB 
 428:../stm32f4xx/core_cm4.h **** 
 429:../stm32f4xx/core_cm4.h **** /* SCB Application Interrupt and Reset Control Register Definitions */
 430:../stm32f4xx/core_cm4.h **** #define SCB_AIRCR_VECTKEY_Pos              16                                             /*!< SCB 
 431:../stm32f4xx/core_cm4.h **** #define SCB_AIRCR_VECTKEY_Msk              (0xFFFFUL << SCB_AIRCR_VECTKEY_Pos)            /*!< SCB 
 432:../stm32f4xx/core_cm4.h **** 
 433:../stm32f4xx/core_cm4.h **** #define SCB_AIRCR_VECTKEYSTAT_Pos          16                                             /*!< SCB 
 434:../stm32f4xx/core_cm4.h **** #define SCB_AIRCR_VECTKEYSTAT_Msk          (0xFFFFUL << SCB_AIRCR_VECTKEYSTAT_Pos)        /*!< SCB 
 435:../stm32f4xx/core_cm4.h **** 
 436:../stm32f4xx/core_cm4.h **** #define SCB_AIRCR_ENDIANESS_Pos            15                                             /*!< SCB 
 437:../stm32f4xx/core_cm4.h **** #define SCB_AIRCR_ENDIANESS_Msk            (1UL << SCB_AIRCR_ENDIANESS_Pos)               /*!< SCB 
 438:../stm32f4xx/core_cm4.h **** 
 439:../stm32f4xx/core_cm4.h **** #define SCB_AIRCR_PRIGROUP_Pos              8                                             /*!< SCB 
 440:../stm32f4xx/core_cm4.h **** #define SCB_AIRCR_PRIGROUP_Msk             (7UL << SCB_AIRCR_PRIGROUP_Pos)                /*!< SCB 
 441:../stm32f4xx/core_cm4.h **** 
 442:../stm32f4xx/core_cm4.h **** #define SCB_AIRCR_SYSRESETREQ_Pos           2                                             /*!< SCB 
 443:../stm32f4xx/core_cm4.h **** #define SCB_AIRCR_SYSRESETREQ_Msk          (1UL << SCB_AIRCR_SYSRESETREQ_Pos)             /*!< SCB 
 444:../stm32f4xx/core_cm4.h **** 
 445:../stm32f4xx/core_cm4.h **** #define SCB_AIRCR_VECTCLRACTIVE_Pos         1                                             /*!< SCB 
 446:../stm32f4xx/core_cm4.h **** #define SCB_AIRCR_VECTCLRACTIVE_Msk        (1UL << SCB_AIRCR_VECTCLRACTIVE_Pos)           /*!< SCB 
 447:../stm32f4xx/core_cm4.h **** 
 448:../stm32f4xx/core_cm4.h **** #define SCB_AIRCR_VECTRESET_Pos             0                                             /*!< SCB 
 449:../stm32f4xx/core_cm4.h **** #define SCB_AIRCR_VECTRESET_Msk            (1UL << SCB_AIRCR_VECTRESET_Pos)               /*!< SCB 
 450:../stm32f4xx/core_cm4.h **** 
 451:../stm32f4xx/core_cm4.h **** /* SCB System Control Register Definitions */
 452:../stm32f4xx/core_cm4.h **** #define SCB_SCR_SEVONPEND_Pos               4                                             /*!< SCB 
 453:../stm32f4xx/core_cm4.h **** #define SCB_SCR_SEVONPEND_Msk              (1UL << SCB_SCR_SEVONPEND_Pos)                 /*!< SCB 
 454:../stm32f4xx/core_cm4.h **** 
 455:../stm32f4xx/core_cm4.h **** #define SCB_SCR_SLEEPDEEP_Pos               2                                             /*!< SCB 
 456:../stm32f4xx/core_cm4.h **** #define SCB_SCR_SLEEPDEEP_Msk              (1UL << SCB_SCR_SLEEPDEEP_Pos)                 /*!< SCB 
 457:../stm32f4xx/core_cm4.h **** 
 458:../stm32f4xx/core_cm4.h **** #define SCB_SCR_SLEEPONEXIT_Pos             1                                             /*!< SCB 
 459:../stm32f4xx/core_cm4.h **** #define SCB_SCR_SLEEPONEXIT_Msk            (1UL << SCB_SCR_SLEEPONEXIT_Pos)               /*!< SCB 
 460:../stm32f4xx/core_cm4.h **** 
 461:../stm32f4xx/core_cm4.h **** /* SCB Configuration Control Register Definitions */
 462:../stm32f4xx/core_cm4.h **** #define SCB_CCR_STKALIGN_Pos                9                                             /*!< SCB 
 463:../stm32f4xx/core_cm4.h **** #define SCB_CCR_STKALIGN_Msk               (1UL << SCB_CCR_STKALIGN_Pos)                  /*!< SCB 
 464:../stm32f4xx/core_cm4.h **** 
 465:../stm32f4xx/core_cm4.h **** #define SCB_CCR_BFHFNMIGN_Pos               8                                             /*!< SCB 
 466:../stm32f4xx/core_cm4.h **** #define SCB_CCR_BFHFNMIGN_Msk              (1UL << SCB_CCR_BFHFNMIGN_Pos)                 /*!< SCB 
 467:../stm32f4xx/core_cm4.h **** 
 468:../stm32f4xx/core_cm4.h **** #define SCB_CCR_DIV_0_TRP_Pos               4                                             /*!< SCB 
 469:../stm32f4xx/core_cm4.h **** #define SCB_CCR_DIV_0_TRP_Msk              (1UL << SCB_CCR_DIV_0_TRP_Pos)                 /*!< SCB 
 470:../stm32f4xx/core_cm4.h **** 
 471:../stm32f4xx/core_cm4.h **** #define SCB_CCR_UNALIGN_TRP_Pos             3                                             /*!< SCB 
 472:../stm32f4xx/core_cm4.h **** #define SCB_CCR_UNALIGN_TRP_Msk            (1UL << SCB_CCR_UNALIGN_TRP_Pos)               /*!< SCB 
 473:../stm32f4xx/core_cm4.h **** 
 474:../stm32f4xx/core_cm4.h **** #define SCB_CCR_USERSETMPEND_Pos            1                                             /*!< SCB 
 475:../stm32f4xx/core_cm4.h **** #define SCB_CCR_USERSETMPEND_Msk           (1UL << SCB_CCR_USERSETMPEND_Pos)              /*!< SCB 
 476:../stm32f4xx/core_cm4.h **** 
 477:../stm32f4xx/core_cm4.h **** #define SCB_CCR_NONBASETHRDENA_Pos          0                                             /*!< SCB 
 478:../stm32f4xx/core_cm4.h **** #define SCB_CCR_NONBASETHRDENA_Msk         (1UL << SCB_CCR_NONBASETHRDENA_Pos)            /*!< SCB 
 479:../stm32f4xx/core_cm4.h **** 
 480:../stm32f4xx/core_cm4.h **** /* SCB System Handler Control and State Register Definitions */
 481:../stm32f4xx/core_cm4.h **** #define SCB_SHCSR_USGFAULTENA_Pos          18                                             /*!< SCB 
 482:../stm32f4xx/core_cm4.h **** #define SCB_SHCSR_USGFAULTENA_Msk          (1UL << SCB_SHCSR_USGFAULTENA_Pos)             /*!< SCB 
 483:../stm32f4xx/core_cm4.h **** 
 484:../stm32f4xx/core_cm4.h **** #define SCB_SHCSR_BUSFAULTENA_Pos          17                                             /*!< SCB 
 485:../stm32f4xx/core_cm4.h **** #define SCB_SHCSR_BUSFAULTENA_Msk          (1UL << SCB_SHCSR_BUSFAULTENA_Pos)             /*!< SCB 
 486:../stm32f4xx/core_cm4.h **** 
 487:../stm32f4xx/core_cm4.h **** #define SCB_SHCSR_MEMFAULTENA_Pos          16                                             /*!< SCB 
 488:../stm32f4xx/core_cm4.h **** #define SCB_SHCSR_MEMFAULTENA_Msk          (1UL << SCB_SHCSR_MEMFAULTENA_Pos)             /*!< SCB 
 489:../stm32f4xx/core_cm4.h **** 
 490:../stm32f4xx/core_cm4.h **** #define SCB_SHCSR_SVCALLPENDED_Pos         15                                             /*!< SCB 
 491:../stm32f4xx/core_cm4.h **** #define SCB_SHCSR_SVCALLPENDED_Msk         (1UL << SCB_SHCSR_SVCALLPENDED_Pos)            /*!< SCB 
 492:../stm32f4xx/core_cm4.h **** 
 493:../stm32f4xx/core_cm4.h **** #define SCB_SHCSR_BUSFAULTPENDED_Pos       14                                             /*!< SCB 
 494:../stm32f4xx/core_cm4.h **** #define SCB_SHCSR_BUSFAULTPENDED_Msk       (1UL << SCB_SHCSR_BUSFAULTPENDED_Pos)          /*!< SCB 
 495:../stm32f4xx/core_cm4.h **** 
 496:../stm32f4xx/core_cm4.h **** #define SCB_SHCSR_MEMFAULTPENDED_Pos       13                                             /*!< SCB 
 497:../stm32f4xx/core_cm4.h **** #define SCB_SHCSR_MEMFAULTPENDED_Msk       (1UL << SCB_SHCSR_MEMFAULTPENDED_Pos)          /*!< SCB 
 498:../stm32f4xx/core_cm4.h **** 
 499:../stm32f4xx/core_cm4.h **** #define SCB_SHCSR_USGFAULTPENDED_Pos       12                                             /*!< SCB 
 500:../stm32f4xx/core_cm4.h **** #define SCB_SHCSR_USGFAULTPENDED_Msk       (1UL << SCB_SHCSR_USGFAULTPENDED_Pos)          /*!< SCB 
 501:../stm32f4xx/core_cm4.h **** 
 502:../stm32f4xx/core_cm4.h **** #define SCB_SHCSR_SYSTICKACT_Pos           11                                             /*!< SCB 
 503:../stm32f4xx/core_cm4.h **** #define SCB_SHCSR_SYSTICKACT_Msk           (1UL << SCB_SHCSR_SYSTICKACT_Pos)              /*!< SCB 
 504:../stm32f4xx/core_cm4.h **** 
 505:../stm32f4xx/core_cm4.h **** #define SCB_SHCSR_PENDSVACT_Pos            10                                             /*!< SCB 
 506:../stm32f4xx/core_cm4.h **** #define SCB_SHCSR_PENDSVACT_Msk            (1UL << SCB_SHCSR_PENDSVACT_Pos)               /*!< SCB 
 507:../stm32f4xx/core_cm4.h **** 
 508:../stm32f4xx/core_cm4.h **** #define SCB_SHCSR_MONITORACT_Pos            8                                             /*!< SCB 
 509:../stm32f4xx/core_cm4.h **** #define SCB_SHCSR_MONITORACT_Msk           (1UL << SCB_SHCSR_MONITORACT_Pos)              /*!< SCB 
 510:../stm32f4xx/core_cm4.h **** 
 511:../stm32f4xx/core_cm4.h **** #define SCB_SHCSR_SVCALLACT_Pos             7                                             /*!< SCB 
 512:../stm32f4xx/core_cm4.h **** #define SCB_SHCSR_SVCALLACT_Msk            (1UL << SCB_SHCSR_SVCALLACT_Pos)               /*!< SCB 
 513:../stm32f4xx/core_cm4.h **** 
 514:../stm32f4xx/core_cm4.h **** #define SCB_SHCSR_USGFAULTACT_Pos           3                                             /*!< SCB 
 515:../stm32f4xx/core_cm4.h **** #define SCB_SHCSR_USGFAULTACT_Msk          (1UL << SCB_SHCSR_USGFAULTACT_Pos)             /*!< SCB 
 516:../stm32f4xx/core_cm4.h **** 
 517:../stm32f4xx/core_cm4.h **** #define SCB_SHCSR_BUSFAULTACT_Pos           1                                             /*!< SCB 
 518:../stm32f4xx/core_cm4.h **** #define SCB_SHCSR_BUSFAULTACT_Msk          (1UL << SCB_SHCSR_BUSFAULTACT_Pos)             /*!< SCB 
 519:../stm32f4xx/core_cm4.h **** 
 520:../stm32f4xx/core_cm4.h **** #define SCB_SHCSR_MEMFAULTACT_Pos           0                                             /*!< SCB 
 521:../stm32f4xx/core_cm4.h **** #define SCB_SHCSR_MEMFAULTACT_Msk          (1UL << SCB_SHCSR_MEMFAULTACT_Pos)             /*!< SCB 
 522:../stm32f4xx/core_cm4.h **** 
 523:../stm32f4xx/core_cm4.h **** /* SCB Configurable Fault Status Registers Definitions */
 524:../stm32f4xx/core_cm4.h **** #define SCB_CFSR_USGFAULTSR_Pos            16                                             /*!< SCB 
 525:../stm32f4xx/core_cm4.h **** #define SCB_CFSR_USGFAULTSR_Msk            (0xFFFFUL << SCB_CFSR_USGFAULTSR_Pos)          /*!< SCB 
 526:../stm32f4xx/core_cm4.h **** 
 527:../stm32f4xx/core_cm4.h **** #define SCB_CFSR_BUSFAULTSR_Pos             8                                             /*!< SCB 
 528:../stm32f4xx/core_cm4.h **** #define SCB_CFSR_BUSFAULTSR_Msk            (0xFFUL << SCB_CFSR_BUSFAULTSR_Pos)            /*!< SCB 
 529:../stm32f4xx/core_cm4.h **** 
 530:../stm32f4xx/core_cm4.h **** #define SCB_CFSR_MEMFAULTSR_Pos             0                                             /*!< SCB 
 531:../stm32f4xx/core_cm4.h **** #define SCB_CFSR_MEMFAULTSR_Msk            (0xFFUL << SCB_CFSR_MEMFAULTSR_Pos)            /*!< SCB 
 532:../stm32f4xx/core_cm4.h **** 
 533:../stm32f4xx/core_cm4.h **** /* SCB Hard Fault Status Registers Definitions */
 534:../stm32f4xx/core_cm4.h **** #define SCB_HFSR_DEBUGEVT_Pos              31                                             /*!< SCB 
 535:../stm32f4xx/core_cm4.h **** #define SCB_HFSR_DEBUGEVT_Msk              (1UL << SCB_HFSR_DEBUGEVT_Pos)                 /*!< SCB 
 536:../stm32f4xx/core_cm4.h **** 
 537:../stm32f4xx/core_cm4.h **** #define SCB_HFSR_FORCED_Pos                30                                             /*!< SCB 
 538:../stm32f4xx/core_cm4.h **** #define SCB_HFSR_FORCED_Msk                (1UL << SCB_HFSR_FORCED_Pos)                   /*!< SCB 
 539:../stm32f4xx/core_cm4.h **** 
 540:../stm32f4xx/core_cm4.h **** #define SCB_HFSR_VECTTBL_Pos                1                                             /*!< SCB 
 541:../stm32f4xx/core_cm4.h **** #define SCB_HFSR_VECTTBL_Msk               (1UL << SCB_HFSR_VECTTBL_Pos)                  /*!< SCB 
 542:../stm32f4xx/core_cm4.h **** 
 543:../stm32f4xx/core_cm4.h **** /* SCB Debug Fault Status Register Definitions */
 544:../stm32f4xx/core_cm4.h **** #define SCB_DFSR_EXTERNAL_Pos               4                                             /*!< SCB 
 545:../stm32f4xx/core_cm4.h **** #define SCB_DFSR_EXTERNAL_Msk              (1UL << SCB_DFSR_EXTERNAL_Pos)                 /*!< SCB 
 546:../stm32f4xx/core_cm4.h **** 
 547:../stm32f4xx/core_cm4.h **** #define SCB_DFSR_VCATCH_Pos                 3                                             /*!< SCB 
 548:../stm32f4xx/core_cm4.h **** #define SCB_DFSR_VCATCH_Msk                (1UL << SCB_DFSR_VCATCH_Pos)                   /*!< SCB 
 549:../stm32f4xx/core_cm4.h **** 
 550:../stm32f4xx/core_cm4.h **** #define SCB_DFSR_DWTTRAP_Pos                2                                             /*!< SCB 
 551:../stm32f4xx/core_cm4.h **** #define SCB_DFSR_DWTTRAP_Msk               (1UL << SCB_DFSR_DWTTRAP_Pos)                  /*!< SCB 
 552:../stm32f4xx/core_cm4.h **** 
 553:../stm32f4xx/core_cm4.h **** #define SCB_DFSR_BKPT_Pos                   1                                             /*!< SCB 
 554:../stm32f4xx/core_cm4.h **** #define SCB_DFSR_BKPT_Msk                  (1UL << SCB_DFSR_BKPT_Pos)                     /*!< SCB 
 555:../stm32f4xx/core_cm4.h **** 
 556:../stm32f4xx/core_cm4.h **** #define SCB_DFSR_HALTED_Pos                 0                                             /*!< SCB 
 557:../stm32f4xx/core_cm4.h **** #define SCB_DFSR_HALTED_Msk                (1UL << SCB_DFSR_HALTED_Pos)                   /*!< SCB 
 558:../stm32f4xx/core_cm4.h **** 
 559:../stm32f4xx/core_cm4.h **** /*@} end of group CMSIS_SCB */
 560:../stm32f4xx/core_cm4.h **** 
 561:../stm32f4xx/core_cm4.h **** 
 562:../stm32f4xx/core_cm4.h **** /** \ingroup  CMSIS_core_register
 563:../stm32f4xx/core_cm4.h ****     \defgroup CMSIS_SCnSCB System Controls not in SCB (SCnSCB)
 564:../stm32f4xx/core_cm4.h ****     \brief      Type definitions for the System Control and ID Register not in the SCB
 565:../stm32f4xx/core_cm4.h ****   @{
 566:../stm32f4xx/core_cm4.h ****  */
 567:../stm32f4xx/core_cm4.h **** 
 568:../stm32f4xx/core_cm4.h **** /** \brief  Structure type to access the System Control and ID Register not in the SCB.
 569:../stm32f4xx/core_cm4.h ****  */
 570:../stm32f4xx/core_cm4.h **** typedef struct
 571:../stm32f4xx/core_cm4.h **** {
 572:../stm32f4xx/core_cm4.h ****        uint32_t RESERVED0[1];
 573:../stm32f4xx/core_cm4.h ****   __I  uint32_t ICTR;                    /*!< Offset: 0x004 (R/ )  Interrupt Controller Type Regist
 574:../stm32f4xx/core_cm4.h ****   __IO uint32_t ACTLR;                   /*!< Offset: 0x008 (R/W)  Auxiliary Control Register      
 575:../stm32f4xx/core_cm4.h **** } SCnSCB_Type;
 576:../stm32f4xx/core_cm4.h **** 
 577:../stm32f4xx/core_cm4.h **** /* Interrupt Controller Type Register Definitions */
 578:../stm32f4xx/core_cm4.h **** #define SCnSCB_ICTR_INTLINESNUM_Pos         0                                          /*!< ICTR: I
 579:../stm32f4xx/core_cm4.h **** #define SCnSCB_ICTR_INTLINESNUM_Msk        (0xFUL << SCnSCB_ICTR_INTLINESNUM_Pos)      /*!< ICTR: I
 580:../stm32f4xx/core_cm4.h **** 
 581:../stm32f4xx/core_cm4.h **** /* Auxiliary Control Register Definitions */
 582:../stm32f4xx/core_cm4.h **** #define SCnSCB_ACTLR_DISOOFP_Pos            9                                          /*!< ACTLR: 
 583:../stm32f4xx/core_cm4.h **** #define SCnSCB_ACTLR_DISOOFP_Msk           (1UL << SCnSCB_ACTLR_DISOOFP_Pos)           /*!< ACTLR: 
 584:../stm32f4xx/core_cm4.h **** 
 585:../stm32f4xx/core_cm4.h **** #define SCnSCB_ACTLR_DISFPCA_Pos            8                                          /*!< ACTLR: 
 586:../stm32f4xx/core_cm4.h **** #define SCnSCB_ACTLR_DISFPCA_Msk           (1UL << SCnSCB_ACTLR_DISFPCA_Pos)           /*!< ACTLR: 
 587:../stm32f4xx/core_cm4.h **** 
 588:../stm32f4xx/core_cm4.h **** #define SCnSCB_ACTLR_DISFOLD_Pos            2                                          /*!< ACTLR: 
 589:../stm32f4xx/core_cm4.h **** #define SCnSCB_ACTLR_DISFOLD_Msk           (1UL << SCnSCB_ACTLR_DISFOLD_Pos)           /*!< ACTLR: 
 590:../stm32f4xx/core_cm4.h **** 
 591:../stm32f4xx/core_cm4.h **** #define SCnSCB_ACTLR_DISDEFWBUF_Pos         1                                          /*!< ACTLR: 
 592:../stm32f4xx/core_cm4.h **** #define SCnSCB_ACTLR_DISDEFWBUF_Msk        (1UL << SCnSCB_ACTLR_DISDEFWBUF_Pos)        /*!< ACTLR: 
 593:../stm32f4xx/core_cm4.h **** 
 594:../stm32f4xx/core_cm4.h **** #define SCnSCB_ACTLR_DISMCYCINT_Pos         0                                          /*!< ACTLR: 
 595:../stm32f4xx/core_cm4.h **** #define SCnSCB_ACTLR_DISMCYCINT_Msk        (1UL << SCnSCB_ACTLR_DISMCYCINT_Pos)        /*!< ACTLR: 
 596:../stm32f4xx/core_cm4.h **** 
 597:../stm32f4xx/core_cm4.h **** /*@} end of group CMSIS_SCnotSCB */
 598:../stm32f4xx/core_cm4.h **** 
 599:../stm32f4xx/core_cm4.h **** 
 600:../stm32f4xx/core_cm4.h **** /** \ingroup  CMSIS_core_register
 601:../stm32f4xx/core_cm4.h ****     \defgroup CMSIS_SysTick     System Tick Timer (SysTick)
 602:../stm32f4xx/core_cm4.h ****     \brief      Type definitions for the System Timer Registers.
 603:../stm32f4xx/core_cm4.h ****   @{
 604:../stm32f4xx/core_cm4.h ****  */
 605:../stm32f4xx/core_cm4.h **** 
 606:../stm32f4xx/core_cm4.h **** /** \brief  Structure type to access the System Timer (SysTick).
 607:../stm32f4xx/core_cm4.h ****  */
 608:../stm32f4xx/core_cm4.h **** typedef struct
 609:../stm32f4xx/core_cm4.h **** {
 610:../stm32f4xx/core_cm4.h ****   __IO uint32_t CTRL;                    /*!< Offset: 0x000 (R/W)  SysTick Control and Status Regis
 611:../stm32f4xx/core_cm4.h ****   __IO uint32_t LOAD;                    /*!< Offset: 0x004 (R/W)  SysTick Reload Value Register   
 612:../stm32f4xx/core_cm4.h ****   __IO uint32_t VAL;                     /*!< Offset: 0x008 (R/W)  SysTick Current Value Register  
 613:../stm32f4xx/core_cm4.h ****   __I  uint32_t CALIB;                   /*!< Offset: 0x00C (R/ )  SysTick Calibration Register    
 614:../stm32f4xx/core_cm4.h **** } SysTick_Type;
 615:../stm32f4xx/core_cm4.h **** 
 616:../stm32f4xx/core_cm4.h **** /* SysTick Control / Status Register Definitions */
 617:../stm32f4xx/core_cm4.h **** #define SysTick_CTRL_COUNTFLAG_Pos         16                                             /*!< SysT
 618:../stm32f4xx/core_cm4.h **** #define SysTick_CTRL_COUNTFLAG_Msk         (1UL << SysTick_CTRL_COUNTFLAG_Pos)            /*!< SysT
 619:../stm32f4xx/core_cm4.h **** 
 620:../stm32f4xx/core_cm4.h **** #define SysTick_CTRL_CLKSOURCE_Pos          2                                             /*!< SysT
 621:../stm32f4xx/core_cm4.h **** #define SysTick_CTRL_CLKSOURCE_Msk         (1UL << SysTick_CTRL_CLKSOURCE_Pos)            /*!< SysT
 622:../stm32f4xx/core_cm4.h **** 
 623:../stm32f4xx/core_cm4.h **** #define SysTick_CTRL_TICKINT_Pos            1                                             /*!< SysT
 624:../stm32f4xx/core_cm4.h **** #define SysTick_CTRL_TICKINT_Msk           (1UL << SysTick_CTRL_TICKINT_Pos)              /*!< SysT
 625:../stm32f4xx/core_cm4.h **** 
 626:../stm32f4xx/core_cm4.h **** #define SysTick_CTRL_ENABLE_Pos             0                                             /*!< SysT
 627:../stm32f4xx/core_cm4.h **** #define SysTick_CTRL_ENABLE_Msk            (1UL << SysTick_CTRL_ENABLE_Pos)               /*!< SysT
 628:../stm32f4xx/core_cm4.h **** 
 629:../stm32f4xx/core_cm4.h **** /* SysTick Reload Register Definitions */
 630:../stm32f4xx/core_cm4.h **** #define SysTick_LOAD_RELOAD_Pos             0                                             /*!< SysT
 631:../stm32f4xx/core_cm4.h **** #define SysTick_LOAD_RELOAD_Msk            (0xFFFFFFUL << SysTick_LOAD_RELOAD_Pos)        /*!< SysT
 632:../stm32f4xx/core_cm4.h **** 
 633:../stm32f4xx/core_cm4.h **** /* SysTick Current Register Definitions */
 634:../stm32f4xx/core_cm4.h **** #define SysTick_VAL_CURRENT_Pos             0                                             /*!< SysT
 635:../stm32f4xx/core_cm4.h **** #define SysTick_VAL_CURRENT_Msk            (0xFFFFFFUL << SysTick_VAL_CURRENT_Pos)        /*!< SysT
 636:../stm32f4xx/core_cm4.h **** 
 637:../stm32f4xx/core_cm4.h **** /* SysTick Calibration Register Definitions */
 638:../stm32f4xx/core_cm4.h **** #define SysTick_CALIB_NOREF_Pos            31                                             /*!< SysT
 639:../stm32f4xx/core_cm4.h **** #define SysTick_CALIB_NOREF_Msk            (1UL << SysTick_CALIB_NOREF_Pos)               /*!< SysT
 640:../stm32f4xx/core_cm4.h **** 
 641:../stm32f4xx/core_cm4.h **** #define SysTick_CALIB_SKEW_Pos             30                                             /*!< SysT
 642:../stm32f4xx/core_cm4.h **** #define SysTick_CALIB_SKEW_Msk             (1UL << SysTick_CALIB_SKEW_Pos)                /*!< SysT
 643:../stm32f4xx/core_cm4.h **** 
 644:../stm32f4xx/core_cm4.h **** #define SysTick_CALIB_TENMS_Pos             0                                             /*!< SysT
 645:../stm32f4xx/core_cm4.h **** #define SysTick_CALIB_TENMS_Msk            (0xFFFFFFUL << SysTick_VAL_CURRENT_Pos)        /*!< SysT
 646:../stm32f4xx/core_cm4.h **** 
 647:../stm32f4xx/core_cm4.h **** /*@} end of group CMSIS_SysTick */
 648:../stm32f4xx/core_cm4.h **** 
 649:../stm32f4xx/core_cm4.h **** 
 650:../stm32f4xx/core_cm4.h **** /** \ingroup  CMSIS_core_register
 651:../stm32f4xx/core_cm4.h ****     \defgroup CMSIS_ITM     Instrumentation Trace Macrocell (ITM)
 652:../stm32f4xx/core_cm4.h ****     \brief      Type definitions for the Instrumentation Trace Macrocell (ITM)
 653:../stm32f4xx/core_cm4.h ****   @{
 654:../stm32f4xx/core_cm4.h ****  */
 655:../stm32f4xx/core_cm4.h **** 
 656:../stm32f4xx/core_cm4.h **** /** \brief  Structure type to access the Instrumentation Trace Macrocell Register (ITM).
 657:../stm32f4xx/core_cm4.h ****  */
 658:../stm32f4xx/core_cm4.h **** typedef struct
 659:../stm32f4xx/core_cm4.h **** {
 660:../stm32f4xx/core_cm4.h ****   __O  union
 661:../stm32f4xx/core_cm4.h ****   {
 662:../stm32f4xx/core_cm4.h ****     __O  uint8_t    u8;                  /*!< Offset: 0x000 ( /W)  ITM Stimulus Port 8-bit         
 663:../stm32f4xx/core_cm4.h ****     __O  uint16_t   u16;                 /*!< Offset: 0x000 ( /W)  ITM Stimulus Port 16-bit        
 664:../stm32f4xx/core_cm4.h ****     __O  uint32_t   u32;                 /*!< Offset: 0x000 ( /W)  ITM Stimulus Port 32-bit        
 665:../stm32f4xx/core_cm4.h ****   }  PORT [32];                          /*!< Offset: 0x000 ( /W)  ITM Stimulus Port Registers     
 666:../stm32f4xx/core_cm4.h ****        uint32_t RESERVED0[864];
 667:../stm32f4xx/core_cm4.h ****   __IO uint32_t TER;                     /*!< Offset: 0xE00 (R/W)  ITM Trace Enable Register       
 668:../stm32f4xx/core_cm4.h ****        uint32_t RESERVED1[15];
 669:../stm32f4xx/core_cm4.h ****   __IO uint32_t TPR;                     /*!< Offset: 0xE40 (R/W)  ITM Trace Privilege Register    
 670:../stm32f4xx/core_cm4.h ****        uint32_t RESERVED2[15];
 671:../stm32f4xx/core_cm4.h ****   __IO uint32_t TCR;                     /*!< Offset: 0xE80 (R/W)  ITM Trace Control Register      
 672:../stm32f4xx/core_cm4.h ****        uint32_t RESERVED3[29];                                  
 673:../stm32f4xx/core_cm4.h ****   __O  uint32_t IWR;                     /*!< Offset: 0xEF8 ( /W)  ITM Integration Write Register  
 674:../stm32f4xx/core_cm4.h ****   __I  uint32_t IRR;                     /*!< Offset: 0xEFC (R/ )  ITM Integration Read Register   
 675:../stm32f4xx/core_cm4.h ****   __IO uint32_t IMCR;                    /*!< Offset: 0xF00 (R/W)  ITM Integration Mode Control Reg
 676:../stm32f4xx/core_cm4.h ****        uint32_t RESERVED4[43];                                  
 677:../stm32f4xx/core_cm4.h ****   __O  uint32_t LAR;                     /*!< Offset: 0xFB0 ( /W)  ITM Lock Access Register        
 678:../stm32f4xx/core_cm4.h ****   __I  uint32_t LSR;                     /*!< Offset: 0xFB4 (R/ )  ITM Lock Status Register        
 679:../stm32f4xx/core_cm4.h ****        uint32_t RESERVED5[6];                                   
 680:../stm32f4xx/core_cm4.h ****   __I  uint32_t PID4;                    /*!< Offset: 0xFD0 (R/ )  ITM Peripheral Identification Re
 681:../stm32f4xx/core_cm4.h ****   __I  uint32_t PID5;                    /*!< Offset: 0xFD4 (R/ )  ITM Peripheral Identification Re
 682:../stm32f4xx/core_cm4.h ****   __I  uint32_t PID6;                    /*!< Offset: 0xFD8 (R/ )  ITM Peripheral Identification Re
 683:../stm32f4xx/core_cm4.h ****   __I  uint32_t PID7;                    /*!< Offset: 0xFDC (R/ )  ITM Peripheral Identification Re
 684:../stm32f4xx/core_cm4.h ****   __I  uint32_t PID0;                    /*!< Offset: 0xFE0 (R/ )  ITM Peripheral Identification Re
 685:../stm32f4xx/core_cm4.h ****   __I  uint32_t PID1;                    /*!< Offset: 0xFE4 (R/ )  ITM Peripheral Identification Re
 686:../stm32f4xx/core_cm4.h ****   __I  uint32_t PID2;                    /*!< Offset: 0xFE8 (R/ )  ITM Peripheral Identification Re
 687:../stm32f4xx/core_cm4.h ****   __I  uint32_t PID3;                    /*!< Offset: 0xFEC (R/ )  ITM Peripheral Identification Re
 688:../stm32f4xx/core_cm4.h ****   __I  uint32_t CID0;                    /*!< Offset: 0xFF0 (R/ )  ITM Component  Identification Re
 689:../stm32f4xx/core_cm4.h ****   __I  uint32_t CID1;                    /*!< Offset: 0xFF4 (R/ )  ITM Component  Identification Re
 690:../stm32f4xx/core_cm4.h ****   __I  uint32_t CID2;                    /*!< Offset: 0xFF8 (R/ )  ITM Component  Identification Re
 691:../stm32f4xx/core_cm4.h ****   __I  uint32_t CID3;                    /*!< Offset: 0xFFC (R/ )  ITM Component  Identification Re
 692:../stm32f4xx/core_cm4.h **** } ITM_Type;
 693:../stm32f4xx/core_cm4.h **** 
 694:../stm32f4xx/core_cm4.h **** /* ITM Trace Privilege Register Definitions */
 695:../stm32f4xx/core_cm4.h **** #define ITM_TPR_PRIVMASK_Pos                0                                             /*!< ITM 
 696:../stm32f4xx/core_cm4.h **** #define ITM_TPR_PRIVMASK_Msk               (0xFUL << ITM_TPR_PRIVMASK_Pos)                /*!< ITM 
 697:../stm32f4xx/core_cm4.h **** 
 698:../stm32f4xx/core_cm4.h **** /* ITM Trace Control Register Definitions */
 699:../stm32f4xx/core_cm4.h **** #define ITM_TCR_BUSY_Pos                   23                                             /*!< ITM 
 700:../stm32f4xx/core_cm4.h **** #define ITM_TCR_BUSY_Msk                   (1UL << ITM_TCR_BUSY_Pos)                      /*!< ITM 
 701:../stm32f4xx/core_cm4.h **** 
 702:../stm32f4xx/core_cm4.h **** #define ITM_TCR_TraceBusID_Pos             16                                             /*!< ITM 
 703:../stm32f4xx/core_cm4.h **** #define ITM_TCR_TraceBusID_Msk             (0x7FUL << ITM_TCR_TraceBusID_Pos)             /*!< ITM 
 704:../stm32f4xx/core_cm4.h **** 
 705:../stm32f4xx/core_cm4.h **** #define ITM_TCR_GTSFREQ_Pos                10                                             /*!< ITM 
 706:../stm32f4xx/core_cm4.h **** #define ITM_TCR_GTSFREQ_Msk                (3UL << ITM_TCR_GTSFREQ_Pos)                   /*!< ITM 
 707:../stm32f4xx/core_cm4.h **** 
 708:../stm32f4xx/core_cm4.h **** #define ITM_TCR_TSPrescale_Pos              8                                             /*!< ITM 
 709:../stm32f4xx/core_cm4.h **** #define ITM_TCR_TSPrescale_Msk             (3UL << ITM_TCR_TSPrescale_Pos)                /*!< ITM 
 710:../stm32f4xx/core_cm4.h **** 
 711:../stm32f4xx/core_cm4.h **** #define ITM_TCR_SWOENA_Pos                  4                                             /*!< ITM 
 712:../stm32f4xx/core_cm4.h **** #define ITM_TCR_SWOENA_Msk                 (1UL << ITM_TCR_SWOENA_Pos)                    /*!< ITM 
 713:../stm32f4xx/core_cm4.h **** 
 714:../stm32f4xx/core_cm4.h **** #define ITM_TCR_DWTENA_Pos                  3                                             /*!< ITM 
 715:../stm32f4xx/core_cm4.h **** #define ITM_TCR_DWTENA_Msk                 (1UL << ITM_TCR_DWTENA_Pos)                    /*!< ITM 
 716:../stm32f4xx/core_cm4.h **** 
 717:../stm32f4xx/core_cm4.h **** #define ITM_TCR_SYNCENA_Pos                 2                                             /*!< ITM 
 718:../stm32f4xx/core_cm4.h **** #define ITM_TCR_SYNCENA_Msk                (1UL << ITM_TCR_SYNCENA_Pos)                   /*!< ITM 
 719:../stm32f4xx/core_cm4.h **** 
 720:../stm32f4xx/core_cm4.h **** #define ITM_TCR_TSENA_Pos                   1                                             /*!< ITM 
 721:../stm32f4xx/core_cm4.h **** #define ITM_TCR_TSENA_Msk                  (1UL << ITM_TCR_TSENA_Pos)                     /*!< ITM 
 722:../stm32f4xx/core_cm4.h **** 
 723:../stm32f4xx/core_cm4.h **** #define ITM_TCR_ITMENA_Pos                  0                                             /*!< ITM 
 724:../stm32f4xx/core_cm4.h **** #define ITM_TCR_ITMENA_Msk                 (1UL << ITM_TCR_ITMENA_Pos)                    /*!< ITM 
 725:../stm32f4xx/core_cm4.h **** 
 726:../stm32f4xx/core_cm4.h **** /* ITM Integration Write Register Definitions */
 727:../stm32f4xx/core_cm4.h **** #define ITM_IWR_ATVALIDM_Pos                0                                             /*!< ITM 
 728:../stm32f4xx/core_cm4.h **** #define ITM_IWR_ATVALIDM_Msk               (1UL << ITM_IWR_ATVALIDM_Pos)                  /*!< ITM 
 729:../stm32f4xx/core_cm4.h **** 
 730:../stm32f4xx/core_cm4.h **** /* ITM Integration Read Register Definitions */
 731:../stm32f4xx/core_cm4.h **** #define ITM_IRR_ATREADYM_Pos                0                                             /*!< ITM 
 732:../stm32f4xx/core_cm4.h **** #define ITM_IRR_ATREADYM_Msk               (1UL << ITM_IRR_ATREADYM_Pos)                  /*!< ITM 
 733:../stm32f4xx/core_cm4.h **** 
 734:../stm32f4xx/core_cm4.h **** /* ITM Integration Mode Control Register Definitions */
 735:../stm32f4xx/core_cm4.h **** #define ITM_IMCR_INTEGRATION_Pos            0                                             /*!< ITM 
 736:../stm32f4xx/core_cm4.h **** #define ITM_IMCR_INTEGRATION_Msk           (1UL << ITM_IMCR_INTEGRATION_Pos)              /*!< ITM 
 737:../stm32f4xx/core_cm4.h **** 
 738:../stm32f4xx/core_cm4.h **** /* ITM Lock Status Register Definitions */
 739:../stm32f4xx/core_cm4.h **** #define ITM_LSR_ByteAcc_Pos                 2                                             /*!< ITM 
 740:../stm32f4xx/core_cm4.h **** #define ITM_LSR_ByteAcc_Msk                (1UL << ITM_LSR_ByteAcc_Pos)                   /*!< ITM 
 741:../stm32f4xx/core_cm4.h **** 
 742:../stm32f4xx/core_cm4.h **** #define ITM_LSR_Access_Pos                  1                                             /*!< ITM 
 743:../stm32f4xx/core_cm4.h **** #define ITM_LSR_Access_Msk                 (1UL << ITM_LSR_Access_Pos)                    /*!< ITM 
 744:../stm32f4xx/core_cm4.h **** 
 745:../stm32f4xx/core_cm4.h **** #define ITM_LSR_Present_Pos                 0                                             /*!< ITM 
 746:../stm32f4xx/core_cm4.h **** #define ITM_LSR_Present_Msk                (1UL << ITM_LSR_Present_Pos)                   /*!< ITM 
 747:../stm32f4xx/core_cm4.h **** 
 748:../stm32f4xx/core_cm4.h **** /*@}*/ /* end of group CMSIS_ITM */
 749:../stm32f4xx/core_cm4.h **** 
 750:../stm32f4xx/core_cm4.h **** 
 751:../stm32f4xx/core_cm4.h **** /** \ingroup  CMSIS_core_register
 752:../stm32f4xx/core_cm4.h ****     \defgroup CMSIS_DWT     Data Watchpoint and Trace (DWT)
 753:../stm32f4xx/core_cm4.h ****     \brief      Type definitions for the Data Watchpoint and Trace (DWT)
 754:../stm32f4xx/core_cm4.h ****   @{
 755:../stm32f4xx/core_cm4.h ****  */
 756:../stm32f4xx/core_cm4.h **** 
 757:../stm32f4xx/core_cm4.h **** /** \brief  Structure type to access the Data Watchpoint and Trace Register (DWT).
 758:../stm32f4xx/core_cm4.h ****  */
 759:../stm32f4xx/core_cm4.h **** typedef struct
 760:../stm32f4xx/core_cm4.h **** {
 761:../stm32f4xx/core_cm4.h ****   __IO uint32_t CTRL;                    /*!< Offset: 0x000 (R/W)  Control Register                
 762:../stm32f4xx/core_cm4.h ****   __IO uint32_t CYCCNT;                  /*!< Offset: 0x004 (R/W)  Cycle Count Register            
 763:../stm32f4xx/core_cm4.h ****   __IO uint32_t CPICNT;                  /*!< Offset: 0x008 (R/W)  CPI Count Register              
 764:../stm32f4xx/core_cm4.h ****   __IO uint32_t EXCCNT;                  /*!< Offset: 0x00C (R/W)  Exception Overhead Count Registe
 765:../stm32f4xx/core_cm4.h ****   __IO uint32_t SLEEPCNT;                /*!< Offset: 0x010 (R/W)  Sleep Count Register            
 766:../stm32f4xx/core_cm4.h ****   __IO uint32_t LSUCNT;                  /*!< Offset: 0x014 (R/W)  LSU Count Register              
 767:../stm32f4xx/core_cm4.h ****   __IO uint32_t FOLDCNT;                 /*!< Offset: 0x018 (R/W)  Folded-instruction Count Registe
 768:../stm32f4xx/core_cm4.h ****   __I  uint32_t PCSR;                    /*!< Offset: 0x01C (R/ )  Program Counter Sample Register 
 769:../stm32f4xx/core_cm4.h ****   __IO uint32_t COMP0;                   /*!< Offset: 0x020 (R/W)  Comparator Register 0           
 770:../stm32f4xx/core_cm4.h ****   __IO uint32_t MASK0;                   /*!< Offset: 0x024 (R/W)  Mask Register 0                 
 771:../stm32f4xx/core_cm4.h ****   __IO uint32_t FUNCTION0;               /*!< Offset: 0x028 (R/W)  Function Register 0             
 772:../stm32f4xx/core_cm4.h ****        uint32_t RESERVED0[1];
 773:../stm32f4xx/core_cm4.h ****   __IO uint32_t COMP1;                   /*!< Offset: 0x030 (R/W)  Comparator Register 1           
 774:../stm32f4xx/core_cm4.h ****   __IO uint32_t MASK1;                   /*!< Offset: 0x034 (R/W)  Mask Register 1                 
 775:../stm32f4xx/core_cm4.h ****   __IO uint32_t FUNCTION1;               /*!< Offset: 0x038 (R/W)  Function Register 1             
 776:../stm32f4xx/core_cm4.h ****        uint32_t RESERVED1[1];
 777:../stm32f4xx/core_cm4.h ****   __IO uint32_t COMP2;                   /*!< Offset: 0x040 (R/W)  Comparator Register 2           
 778:../stm32f4xx/core_cm4.h ****   __IO uint32_t MASK2;                   /*!< Offset: 0x044 (R/W)  Mask Register 2                 
 779:../stm32f4xx/core_cm4.h ****   __IO uint32_t FUNCTION2;               /*!< Offset: 0x048 (R/W)  Function Register 2             
 780:../stm32f4xx/core_cm4.h ****        uint32_t RESERVED2[1];
 781:../stm32f4xx/core_cm4.h ****   __IO uint32_t COMP3;                   /*!< Offset: 0x050 (R/W)  Comparator Register 3           
 782:../stm32f4xx/core_cm4.h ****   __IO uint32_t MASK3;                   /*!< Offset: 0x054 (R/W)  Mask Register 3                 
 783:../stm32f4xx/core_cm4.h ****   __IO uint32_t FUNCTION3;               /*!< Offset: 0x058 (R/W)  Function Register 3             
 784:../stm32f4xx/core_cm4.h **** } DWT_Type;
 785:../stm32f4xx/core_cm4.h **** 
 786:../stm32f4xx/core_cm4.h **** /* DWT Control Register Definitions */
 787:../stm32f4xx/core_cm4.h **** #define DWT_CTRL_NUMCOMP_Pos               28                                          /*!< DWT CTR
 788:../stm32f4xx/core_cm4.h **** #define DWT_CTRL_NUMCOMP_Msk               (0xFUL << DWT_CTRL_NUMCOMP_Pos)             /*!< DWT CTR
 789:../stm32f4xx/core_cm4.h **** 
 790:../stm32f4xx/core_cm4.h **** #define DWT_CTRL_NOTRCPKT_Pos              27                                          /*!< DWT CTR
 791:../stm32f4xx/core_cm4.h **** #define DWT_CTRL_NOTRCPKT_Msk              (0x1UL << DWT_CTRL_NOTRCPKT_Pos)            /*!< DWT CTR
 792:../stm32f4xx/core_cm4.h **** 
 793:../stm32f4xx/core_cm4.h **** #define DWT_CTRL_NOEXTTRIG_Pos             26                                          /*!< DWT CTR
 794:../stm32f4xx/core_cm4.h **** #define DWT_CTRL_NOEXTTRIG_Msk             (0x1UL << DWT_CTRL_NOEXTTRIG_Pos)           /*!< DWT CTR
 795:../stm32f4xx/core_cm4.h **** 
 796:../stm32f4xx/core_cm4.h **** #define DWT_CTRL_NOCYCCNT_Pos              25                                          /*!< DWT CTR
 797:../stm32f4xx/core_cm4.h **** #define DWT_CTRL_NOCYCCNT_Msk              (0x1UL << DWT_CTRL_NOCYCCNT_Pos)            /*!< DWT CTR
 798:../stm32f4xx/core_cm4.h **** 
 799:../stm32f4xx/core_cm4.h **** #define DWT_CTRL_NOPRFCNT_Pos              24                                          /*!< DWT CTR
 800:../stm32f4xx/core_cm4.h **** #define DWT_CTRL_NOPRFCNT_Msk              (0x1UL << DWT_CTRL_NOPRFCNT_Pos)            /*!< DWT CTR
 801:../stm32f4xx/core_cm4.h **** 
 802:../stm32f4xx/core_cm4.h **** #define DWT_CTRL_CYCEVTENA_Pos             22                                          /*!< DWT CTR
 803:../stm32f4xx/core_cm4.h **** #define DWT_CTRL_CYCEVTENA_Msk             (0x1UL << DWT_CTRL_CYCEVTENA_Pos)           /*!< DWT CTR
 804:../stm32f4xx/core_cm4.h **** 
 805:../stm32f4xx/core_cm4.h **** #define DWT_CTRL_FOLDEVTENA_Pos            21                                          /*!< DWT CTR
 806:../stm32f4xx/core_cm4.h **** #define DWT_CTRL_FOLDEVTENA_Msk            (0x1UL << DWT_CTRL_FOLDEVTENA_Pos)          /*!< DWT CTR
 807:../stm32f4xx/core_cm4.h **** 
 808:../stm32f4xx/core_cm4.h **** #define DWT_CTRL_LSUEVTENA_Pos             20                                          /*!< DWT CTR
 809:../stm32f4xx/core_cm4.h **** #define DWT_CTRL_LSUEVTENA_Msk             (0x1UL << DWT_CTRL_LSUEVTENA_Pos)           /*!< DWT CTR
 810:../stm32f4xx/core_cm4.h **** 
 811:../stm32f4xx/core_cm4.h **** #define DWT_CTRL_SLEEPEVTENA_Pos           19                                          /*!< DWT CTR
 812:../stm32f4xx/core_cm4.h **** #define DWT_CTRL_SLEEPEVTENA_Msk           (0x1UL << DWT_CTRL_SLEEPEVTENA_Pos)         /*!< DWT CTR
 813:../stm32f4xx/core_cm4.h **** 
 814:../stm32f4xx/core_cm4.h **** #define DWT_CTRL_EXCEVTENA_Pos             18                                          /*!< DWT CTR
 815:../stm32f4xx/core_cm4.h **** #define DWT_CTRL_EXCEVTENA_Msk             (0x1UL << DWT_CTRL_EXCEVTENA_Pos)           /*!< DWT CTR
 816:../stm32f4xx/core_cm4.h **** 
 817:../stm32f4xx/core_cm4.h **** #define DWT_CTRL_CPIEVTENA_Pos             17                                          /*!< DWT CTR
 818:../stm32f4xx/core_cm4.h **** #define DWT_CTRL_CPIEVTENA_Msk             (0x1UL << DWT_CTRL_CPIEVTENA_Pos)           /*!< DWT CTR
 819:../stm32f4xx/core_cm4.h **** 
 820:../stm32f4xx/core_cm4.h **** #define DWT_CTRL_EXCTRCENA_Pos             16                                          /*!< DWT CTR
 821:../stm32f4xx/core_cm4.h **** #define DWT_CTRL_EXCTRCENA_Msk             (0x1UL << DWT_CTRL_EXCTRCENA_Pos)           /*!< DWT CTR
 822:../stm32f4xx/core_cm4.h **** 
 823:../stm32f4xx/core_cm4.h **** #define DWT_CTRL_PCSAMPLENA_Pos            12                                          /*!< DWT CTR
 824:../stm32f4xx/core_cm4.h **** #define DWT_CTRL_PCSAMPLENA_Msk            (0x1UL << DWT_CTRL_PCSAMPLENA_Pos)          /*!< DWT CTR
 825:../stm32f4xx/core_cm4.h **** 
 826:../stm32f4xx/core_cm4.h **** #define DWT_CTRL_SYNCTAP_Pos               10                                          /*!< DWT CTR
 827:../stm32f4xx/core_cm4.h **** #define DWT_CTRL_SYNCTAP_Msk               (0x3UL << DWT_CTRL_SYNCTAP_Pos)             /*!< DWT CTR
 828:../stm32f4xx/core_cm4.h **** 
 829:../stm32f4xx/core_cm4.h **** #define DWT_CTRL_CYCTAP_Pos                 9                                          /*!< DWT CTR
 830:../stm32f4xx/core_cm4.h **** #define DWT_CTRL_CYCTAP_Msk                (0x1UL << DWT_CTRL_CYCTAP_Pos)              /*!< DWT CTR
 831:../stm32f4xx/core_cm4.h **** 
 832:../stm32f4xx/core_cm4.h **** #define DWT_CTRL_POSTINIT_Pos               5                                          /*!< DWT CTR
 833:../stm32f4xx/core_cm4.h **** #define DWT_CTRL_POSTINIT_Msk              (0xFUL << DWT_CTRL_POSTINIT_Pos)            /*!< DWT CTR
 834:../stm32f4xx/core_cm4.h **** 
 835:../stm32f4xx/core_cm4.h **** #define DWT_CTRL_POSTPRESET_Pos             1                                          /*!< DWT CTR
 836:../stm32f4xx/core_cm4.h **** #define DWT_CTRL_POSTPRESET_Msk            (0xFUL << DWT_CTRL_POSTPRESET_Pos)          /*!< DWT CTR
 837:../stm32f4xx/core_cm4.h **** 
 838:../stm32f4xx/core_cm4.h **** #define DWT_CTRL_CYCCNTENA_Pos              0                                          /*!< DWT CTR
 839:../stm32f4xx/core_cm4.h **** #define DWT_CTRL_CYCCNTENA_Msk             (0x1UL << DWT_CTRL_CYCCNTENA_Pos)           /*!< DWT CTR
 840:../stm32f4xx/core_cm4.h **** 
 841:../stm32f4xx/core_cm4.h **** /* DWT CPI Count Register Definitions */
 842:../stm32f4xx/core_cm4.h **** #define DWT_CPICNT_CPICNT_Pos               0                                          /*!< DWT CPI
 843:../stm32f4xx/core_cm4.h **** #define DWT_CPICNT_CPICNT_Msk              (0xFFUL << DWT_CPICNT_CPICNT_Pos)           /*!< DWT CPI
 844:../stm32f4xx/core_cm4.h **** 
 845:../stm32f4xx/core_cm4.h **** /* DWT Exception Overhead Count Register Definitions */
 846:../stm32f4xx/core_cm4.h **** #define DWT_EXCCNT_EXCCNT_Pos               0                                          /*!< DWT EXC
 847:../stm32f4xx/core_cm4.h **** #define DWT_EXCCNT_EXCCNT_Msk              (0xFFUL << DWT_EXCCNT_EXCCNT_Pos)           /*!< DWT EXC
 848:../stm32f4xx/core_cm4.h **** 
 849:../stm32f4xx/core_cm4.h **** /* DWT Sleep Count Register Definitions */
 850:../stm32f4xx/core_cm4.h **** #define DWT_SLEEPCNT_SLEEPCNT_Pos           0                                          /*!< DWT SLE
 851:../stm32f4xx/core_cm4.h **** #define DWT_SLEEPCNT_SLEEPCNT_Msk          (0xFFUL << DWT_SLEEPCNT_SLEEPCNT_Pos)       /*!< DWT SLE
 852:../stm32f4xx/core_cm4.h **** 
 853:../stm32f4xx/core_cm4.h **** /* DWT LSU Count Register Definitions */
 854:../stm32f4xx/core_cm4.h **** #define DWT_LSUCNT_LSUCNT_Pos               0                                          /*!< DWT LSU
 855:../stm32f4xx/core_cm4.h **** #define DWT_LSUCNT_LSUCNT_Msk              (0xFFUL << DWT_LSUCNT_LSUCNT_Pos)           /*!< DWT LSU
 856:../stm32f4xx/core_cm4.h **** 
 857:../stm32f4xx/core_cm4.h **** /* DWT Folded-instruction Count Register Definitions */
 858:../stm32f4xx/core_cm4.h **** #define DWT_FOLDCNT_FOLDCNT_Pos             0                                          /*!< DWT FOL
 859:../stm32f4xx/core_cm4.h **** #define DWT_FOLDCNT_FOLDCNT_Msk            (0xFFUL << DWT_FOLDCNT_FOLDCNT_Pos)         /*!< DWT FOL
 860:../stm32f4xx/core_cm4.h **** 
 861:../stm32f4xx/core_cm4.h **** /* DWT Comparator Mask Register Definitions */
 862:../stm32f4xx/core_cm4.h **** #define DWT_MASK_MASK_Pos                   0                                          /*!< DWT MAS
 863:../stm32f4xx/core_cm4.h **** #define DWT_MASK_MASK_Msk                  (0x1FUL << DWT_MASK_MASK_Pos)               /*!< DWT MAS
 864:../stm32f4xx/core_cm4.h **** 
 865:../stm32f4xx/core_cm4.h **** /* DWT Comparator Function Register Definitions */
 866:../stm32f4xx/core_cm4.h **** #define DWT_FUNCTION_MATCHED_Pos           24                                          /*!< DWT FUN
 867:../stm32f4xx/core_cm4.h **** #define DWT_FUNCTION_MATCHED_Msk           (0x1UL << DWT_FUNCTION_MATCHED_Pos)         /*!< DWT FUN
 868:../stm32f4xx/core_cm4.h **** 
 869:../stm32f4xx/core_cm4.h **** #define DWT_FUNCTION_DATAVADDR1_Pos        16                                          /*!< DWT FUN
 870:../stm32f4xx/core_cm4.h **** #define DWT_FUNCTION_DATAVADDR1_Msk        (0xFUL << DWT_FUNCTION_DATAVADDR1_Pos)      /*!< DWT FUN
 871:../stm32f4xx/core_cm4.h **** 
 872:../stm32f4xx/core_cm4.h **** #define DWT_FUNCTION_DATAVADDR0_Pos        12                                          /*!< DWT FUN
 873:../stm32f4xx/core_cm4.h **** #define DWT_FUNCTION_DATAVADDR0_Msk        (0xFUL << DWT_FUNCTION_DATAVADDR0_Pos)      /*!< DWT FUN
 874:../stm32f4xx/core_cm4.h **** 
 875:../stm32f4xx/core_cm4.h **** #define DWT_FUNCTION_DATAVSIZE_Pos         10                                          /*!< DWT FUN
 876:../stm32f4xx/core_cm4.h **** #define DWT_FUNCTION_DATAVSIZE_Msk         (0x3UL << DWT_FUNCTION_DATAVSIZE_Pos)       /*!< DWT FUN
 877:../stm32f4xx/core_cm4.h **** 
 878:../stm32f4xx/core_cm4.h **** #define DWT_FUNCTION_LNK1ENA_Pos            9                                          /*!< DWT FUN
 879:../stm32f4xx/core_cm4.h **** #define DWT_FUNCTION_LNK1ENA_Msk           (0x1UL << DWT_FUNCTION_LNK1ENA_Pos)         /*!< DWT FUN
 880:../stm32f4xx/core_cm4.h **** 
 881:../stm32f4xx/core_cm4.h **** #define DWT_FUNCTION_DATAVMATCH_Pos         8                                          /*!< DWT FUN
 882:../stm32f4xx/core_cm4.h **** #define DWT_FUNCTION_DATAVMATCH_Msk        (0x1UL << DWT_FUNCTION_DATAVMATCH_Pos)      /*!< DWT FUN
 883:../stm32f4xx/core_cm4.h **** 
 884:../stm32f4xx/core_cm4.h **** #define DWT_FUNCTION_CYCMATCH_Pos           7                                          /*!< DWT FUN
 885:../stm32f4xx/core_cm4.h **** #define DWT_FUNCTION_CYCMATCH_Msk          (0x1UL << DWT_FUNCTION_CYCMATCH_Pos)        /*!< DWT FUN
 886:../stm32f4xx/core_cm4.h **** 
 887:../stm32f4xx/core_cm4.h **** #define DWT_FUNCTION_EMITRANGE_Pos          5                                          /*!< DWT FUN
 888:../stm32f4xx/core_cm4.h **** #define DWT_FUNCTION_EMITRANGE_Msk         (0x1UL << DWT_FUNCTION_EMITRANGE_Pos)       /*!< DWT FUN
 889:../stm32f4xx/core_cm4.h **** 
 890:../stm32f4xx/core_cm4.h **** #define DWT_FUNCTION_FUNCTION_Pos           0                                          /*!< DWT FUN
 891:../stm32f4xx/core_cm4.h **** #define DWT_FUNCTION_FUNCTION_Msk          (0xFUL << DWT_FUNCTION_FUNCTION_Pos)        /*!< DWT FUN
 892:../stm32f4xx/core_cm4.h **** 
 893:../stm32f4xx/core_cm4.h **** /*@}*/ /* end of group CMSIS_DWT */
 894:../stm32f4xx/core_cm4.h **** 
 895:../stm32f4xx/core_cm4.h **** 
 896:../stm32f4xx/core_cm4.h **** /** \ingroup  CMSIS_core_register
 897:../stm32f4xx/core_cm4.h ****     \defgroup CMSIS_TPI     Trace Port Interface (TPI)
 898:../stm32f4xx/core_cm4.h ****     \brief      Type definitions for the Trace Port Interface (TPI)
 899:../stm32f4xx/core_cm4.h ****   @{
 900:../stm32f4xx/core_cm4.h ****  */
 901:../stm32f4xx/core_cm4.h **** 
 902:../stm32f4xx/core_cm4.h **** /** \brief  Structure type to access the Trace Port Interface Register (TPI).
 903:../stm32f4xx/core_cm4.h ****  */
 904:../stm32f4xx/core_cm4.h **** typedef struct
 905:../stm32f4xx/core_cm4.h **** {
 906:../stm32f4xx/core_cm4.h ****   __IO uint32_t SSPSR;                   /*!< Offset: 0x000 (R/ )  Supported Parallel Port Size Reg
 907:../stm32f4xx/core_cm4.h ****   __IO uint32_t CSPSR;                   /*!< Offset: 0x004 (R/W)  Current Parallel Port Size Regis
 908:../stm32f4xx/core_cm4.h ****        uint32_t RESERVED0[2];
 909:../stm32f4xx/core_cm4.h ****   __IO uint32_t ACPR;                    /*!< Offset: 0x010 (R/W)  Asynchronous Clock Prescaler Reg
 910:../stm32f4xx/core_cm4.h ****        uint32_t RESERVED1[55];
 911:../stm32f4xx/core_cm4.h ****   __IO uint32_t SPPR;                    /*!< Offset: 0x0F0 (R/W)  Selected Pin Protocol Register *
 912:../stm32f4xx/core_cm4.h ****        uint32_t RESERVED2[131];
 913:../stm32f4xx/core_cm4.h ****   __I  uint32_t FFSR;                    /*!< Offset: 0x300 (R/ )  Formatter and Flush Status Regis
 914:../stm32f4xx/core_cm4.h ****   __IO uint32_t FFCR;                    /*!< Offset: 0x304 (R/W)  Formatter and Flush Control Regi
 915:../stm32f4xx/core_cm4.h ****   __I  uint32_t FSCR;                    /*!< Offset: 0x308 (R/ )  Formatter Synchronization Counte
 916:../stm32f4xx/core_cm4.h ****        uint32_t RESERVED3[759];
 917:../stm32f4xx/core_cm4.h ****   __I  uint32_t TRIGGER;                 /*!< Offset: 0xEE8 (R/ )  TRIGGER */
 918:../stm32f4xx/core_cm4.h ****   __I  uint32_t FIFO0;                   /*!< Offset: 0xEEC (R/ )  Integration ETM Data */
 919:../stm32f4xx/core_cm4.h ****   __I  uint32_t ITATBCTR2;               /*!< Offset: 0xEF0 (R/ )  ITATBCTR2 */
 920:../stm32f4xx/core_cm4.h ****        uint32_t RESERVED4[1];
 921:../stm32f4xx/core_cm4.h ****   __I  uint32_t ITATBCTR0;               /*!< Offset: 0xEF8 (R/ )  ITATBCTR0 */
 922:../stm32f4xx/core_cm4.h ****   __I  uint32_t FIFO1;                   /*!< Offset: 0xEFC (R/ )  Integration ITM Data */
 923:../stm32f4xx/core_cm4.h ****   __IO uint32_t ITCTRL;                  /*!< Offset: 0xF00 (R/W)  Integration Mode Control */
 924:../stm32f4xx/core_cm4.h ****        uint32_t RESERVED5[39];
 925:../stm32f4xx/core_cm4.h ****   __IO uint32_t CLAIMSET;                /*!< Offset: 0xFA0 (R/W)  Claim tag set */
 926:../stm32f4xx/core_cm4.h ****   __IO uint32_t CLAIMCLR;                /*!< Offset: 0xFA4 (R/W)  Claim tag clear */
 927:../stm32f4xx/core_cm4.h ****        uint32_t RESERVED7[8];
 928:../stm32f4xx/core_cm4.h ****   __I  uint32_t DEVID;                   /*!< Offset: 0xFC8 (R/ )  TPIU_DEVID */
 929:../stm32f4xx/core_cm4.h ****   __I  uint32_t DEVTYPE;                 /*!< Offset: 0xFCC (R/ )  TPIU_DEVTYPE */
 930:../stm32f4xx/core_cm4.h **** } TPI_Type;
 931:../stm32f4xx/core_cm4.h **** 
 932:../stm32f4xx/core_cm4.h **** /* TPI Asynchronous Clock Prescaler Register Definitions */
 933:../stm32f4xx/core_cm4.h **** #define TPI_ACPR_PRESCALER_Pos              0                                          /*!< TPI ACP
 934:../stm32f4xx/core_cm4.h **** #define TPI_ACPR_PRESCALER_Msk             (0x1FFFUL << TPI_ACPR_PRESCALER_Pos)        /*!< TPI ACP
 935:../stm32f4xx/core_cm4.h **** 
 936:../stm32f4xx/core_cm4.h **** /* TPI Selected Pin Protocol Register Definitions */
 937:../stm32f4xx/core_cm4.h **** #define TPI_SPPR_TXMODE_Pos                 0                                          /*!< TPI SPP
 938:../stm32f4xx/core_cm4.h **** #define TPI_SPPR_TXMODE_Msk                (0x3UL << TPI_SPPR_TXMODE_Pos)              /*!< TPI SPP
 939:../stm32f4xx/core_cm4.h **** 
 940:../stm32f4xx/core_cm4.h **** /* TPI Formatter and Flush Status Register Definitions */
 941:../stm32f4xx/core_cm4.h **** #define TPI_FFSR_FtNonStop_Pos              3                                          /*!< TPI FFS
 942:../stm32f4xx/core_cm4.h **** #define TPI_FFSR_FtNonStop_Msk             (0x1UL << TPI_FFSR_FtNonStop_Pos)           /*!< TPI FFS
 943:../stm32f4xx/core_cm4.h **** 
 944:../stm32f4xx/core_cm4.h **** #define TPI_FFSR_TCPresent_Pos              2                                          /*!< TPI FFS
 945:../stm32f4xx/core_cm4.h **** #define TPI_FFSR_TCPresent_Msk             (0x1UL << TPI_FFSR_TCPresent_Pos)           /*!< TPI FFS
 946:../stm32f4xx/core_cm4.h **** 
 947:../stm32f4xx/core_cm4.h **** #define TPI_FFSR_FtStopped_Pos              1                                          /*!< TPI FFS
 948:../stm32f4xx/core_cm4.h **** #define TPI_FFSR_FtStopped_Msk             (0x1UL << TPI_FFSR_FtStopped_Pos)           /*!< TPI FFS
 949:../stm32f4xx/core_cm4.h **** 
 950:../stm32f4xx/core_cm4.h **** #define TPI_FFSR_FlInProg_Pos               0                                          /*!< TPI FFS
 951:../stm32f4xx/core_cm4.h **** #define TPI_FFSR_FlInProg_Msk              (0x1UL << TPI_FFSR_FlInProg_Pos)            /*!< TPI FFS
 952:../stm32f4xx/core_cm4.h **** 
 953:../stm32f4xx/core_cm4.h **** /* TPI Formatter and Flush Control Register Definitions */
 954:../stm32f4xx/core_cm4.h **** #define TPI_FFCR_TrigIn_Pos                 8                                          /*!< TPI FFC
 955:../stm32f4xx/core_cm4.h **** #define TPI_FFCR_TrigIn_Msk                (0x1UL << TPI_FFCR_TrigIn_Pos)              /*!< TPI FFC
 956:../stm32f4xx/core_cm4.h **** 
 957:../stm32f4xx/core_cm4.h **** #define TPI_FFCR_EnFCont_Pos                1                                          /*!< TPI FFC
 958:../stm32f4xx/core_cm4.h **** #define TPI_FFCR_EnFCont_Msk               (0x1UL << TPI_FFCR_EnFCont_Pos)             /*!< TPI FFC
 959:../stm32f4xx/core_cm4.h **** 
 960:../stm32f4xx/core_cm4.h **** /* TPI TRIGGER Register Definitions */
 961:../stm32f4xx/core_cm4.h **** #define TPI_TRIGGER_TRIGGER_Pos             0                                          /*!< TPI TRI
 962:../stm32f4xx/core_cm4.h **** #define TPI_TRIGGER_TRIGGER_Msk            (0x1UL << TPI_TRIGGER_TRIGGER_Pos)          /*!< TPI TRI
 963:../stm32f4xx/core_cm4.h **** 
 964:../stm32f4xx/core_cm4.h **** /* TPI Integration ETM Data Register Definitions (FIFO0) */
 965:../stm32f4xx/core_cm4.h **** #define TPI_FIFO0_ITM_ATVALID_Pos          29                                          /*!< TPI FIF
 966:../stm32f4xx/core_cm4.h **** #define TPI_FIFO0_ITM_ATVALID_Msk          (0x3UL << TPI_FIFO0_ITM_ATVALID_Pos)        /*!< TPI FIF
 967:../stm32f4xx/core_cm4.h **** 
 968:../stm32f4xx/core_cm4.h **** #define TPI_FIFO0_ITM_bytecount_Pos        27                                          /*!< TPI FIF
 969:../stm32f4xx/core_cm4.h **** #define TPI_FIFO0_ITM_bytecount_Msk        (0x3UL << TPI_FIFO0_ITM_bytecount_Pos)      /*!< TPI FIF
 970:../stm32f4xx/core_cm4.h **** 
 971:../stm32f4xx/core_cm4.h **** #define TPI_FIFO0_ETM_ATVALID_Pos          26                                          /*!< TPI FIF
 972:../stm32f4xx/core_cm4.h **** #define TPI_FIFO0_ETM_ATVALID_Msk          (0x3UL << TPI_FIFO0_ETM_ATVALID_Pos)        /*!< TPI FIF
 973:../stm32f4xx/core_cm4.h **** 
 974:../stm32f4xx/core_cm4.h **** #define TPI_FIFO0_ETM_bytecount_Pos        24                                          /*!< TPI FIF
 975:../stm32f4xx/core_cm4.h **** #define TPI_FIFO0_ETM_bytecount_Msk        (0x3UL << TPI_FIFO0_ETM_bytecount_Pos)      /*!< TPI FIF
 976:../stm32f4xx/core_cm4.h **** 
 977:../stm32f4xx/core_cm4.h **** #define TPI_FIFO0_ETM2_Pos                 16                                          /*!< TPI FIF
 978:../stm32f4xx/core_cm4.h **** #define TPI_FIFO0_ETM2_Msk                 (0xFFUL << TPI_FIFO0_ETM2_Pos)              /*!< TPI FIF
 979:../stm32f4xx/core_cm4.h **** 
 980:../stm32f4xx/core_cm4.h **** #define TPI_FIFO0_ETM1_Pos                  8                                          /*!< TPI FIF
 981:../stm32f4xx/core_cm4.h **** #define TPI_FIFO0_ETM1_Msk                 (0xFFUL << TPI_FIFO0_ETM1_Pos)              /*!< TPI FIF
 982:../stm32f4xx/core_cm4.h **** 
 983:../stm32f4xx/core_cm4.h **** #define TPI_FIFO0_ETM0_Pos                  0                                          /*!< TPI FIF
 984:../stm32f4xx/core_cm4.h **** #define TPI_FIFO0_ETM0_Msk                 (0xFFUL << TPI_FIFO0_ETM0_Pos)              /*!< TPI FIF
 985:../stm32f4xx/core_cm4.h **** 
 986:../stm32f4xx/core_cm4.h **** /* TPI ITATBCTR2 Register Definitions */
 987:../stm32f4xx/core_cm4.h **** #define TPI_ITATBCTR2_ATREADY_Pos           0                                          /*!< TPI ITA
 988:../stm32f4xx/core_cm4.h **** #define TPI_ITATBCTR2_ATREADY_Msk          (0x1UL << TPI_ITATBCTR2_ATREADY_Pos)        /*!< TPI ITA
 989:../stm32f4xx/core_cm4.h **** 
 990:../stm32f4xx/core_cm4.h **** /* TPI Integration ITM Data Register Definitions (FIFO1) */
 991:../stm32f4xx/core_cm4.h **** #define TPI_FIFO1_ITM_ATVALID_Pos          29                                          /*!< TPI FIF
 992:../stm32f4xx/core_cm4.h **** #define TPI_FIFO1_ITM_ATVALID_Msk          (0x3UL << TPI_FIFO1_ITM_ATVALID_Pos)        /*!< TPI FIF
 993:../stm32f4xx/core_cm4.h **** 
 994:../stm32f4xx/core_cm4.h **** #define TPI_FIFO1_ITM_bytecount_Pos        27                                          /*!< TPI FIF
 995:../stm32f4xx/core_cm4.h **** #define TPI_FIFO1_ITM_bytecount_Msk        (0x3UL << TPI_FIFO1_ITM_bytecount_Pos)      /*!< TPI FIF
 996:../stm32f4xx/core_cm4.h **** 
 997:../stm32f4xx/core_cm4.h **** #define TPI_FIFO1_ETM_ATVALID_Pos          26                                          /*!< TPI FIF
 998:../stm32f4xx/core_cm4.h **** #define TPI_FIFO1_ETM_ATVALID_Msk          (0x3UL << TPI_FIFO1_ETM_ATVALID_Pos)        /*!< TPI FIF
 999:../stm32f4xx/core_cm4.h **** 
1000:../stm32f4xx/core_cm4.h **** #define TPI_FIFO1_ETM_bytecount_Pos        24                                          /*!< TPI FIF
1001:../stm32f4xx/core_cm4.h **** #define TPI_FIFO1_ETM_bytecount_Msk        (0x3UL << TPI_FIFO1_ETM_bytecount_Pos)      /*!< TPI FIF
1002:../stm32f4xx/core_cm4.h **** 
1003:../stm32f4xx/core_cm4.h **** #define TPI_FIFO1_ITM2_Pos                 16                                          /*!< TPI FIF
1004:../stm32f4xx/core_cm4.h **** #define TPI_FIFO1_ITM2_Msk                 (0xFFUL << TPI_FIFO1_ITM2_Pos)              /*!< TPI FIF
1005:../stm32f4xx/core_cm4.h **** 
1006:../stm32f4xx/core_cm4.h **** #define TPI_FIFO1_ITM1_Pos                  8                                          /*!< TPI FIF
1007:../stm32f4xx/core_cm4.h **** #define TPI_FIFO1_ITM1_Msk                 (0xFFUL << TPI_FIFO1_ITM1_Pos)              /*!< TPI FIF
1008:../stm32f4xx/core_cm4.h **** 
1009:../stm32f4xx/core_cm4.h **** #define TPI_FIFO1_ITM0_Pos                  0                                          /*!< TPI FIF
1010:../stm32f4xx/core_cm4.h **** #define TPI_FIFO1_ITM0_Msk                 (0xFFUL << TPI_FIFO1_ITM0_Pos)              /*!< TPI FIF
1011:../stm32f4xx/core_cm4.h **** 
1012:../stm32f4xx/core_cm4.h **** /* TPI ITATBCTR0 Register Definitions */
1013:../stm32f4xx/core_cm4.h **** #define TPI_ITATBCTR0_ATREADY_Pos           0                                          /*!< TPI ITA
1014:../stm32f4xx/core_cm4.h **** #define TPI_ITATBCTR0_ATREADY_Msk          (0x1UL << TPI_ITATBCTR0_ATREADY_Pos)        /*!< TPI ITA
1015:../stm32f4xx/core_cm4.h **** 
1016:../stm32f4xx/core_cm4.h **** /* TPI Integration Mode Control Register Definitions */
1017:../stm32f4xx/core_cm4.h **** #define TPI_ITCTRL_Mode_Pos                 0                                          /*!< TPI ITC
1018:../stm32f4xx/core_cm4.h **** #define TPI_ITCTRL_Mode_Msk                (0x1UL << TPI_ITCTRL_Mode_Pos)              /*!< TPI ITC
1019:../stm32f4xx/core_cm4.h **** 
1020:../stm32f4xx/core_cm4.h **** /* TPI DEVID Register Definitions */
1021:../stm32f4xx/core_cm4.h **** #define TPI_DEVID_NRZVALID_Pos             11                                          /*!< TPI DEV
1022:../stm32f4xx/core_cm4.h **** #define TPI_DEVID_NRZVALID_Msk             (0x1UL << TPI_DEVID_NRZVALID_Pos)           /*!< TPI DEV
1023:../stm32f4xx/core_cm4.h **** 
1024:../stm32f4xx/core_cm4.h **** #define TPI_DEVID_MANCVALID_Pos            10                                          /*!< TPI DEV
1025:../stm32f4xx/core_cm4.h **** #define TPI_DEVID_MANCVALID_Msk            (0x1UL << TPI_DEVID_MANCVALID_Pos)          /*!< TPI DEV
1026:../stm32f4xx/core_cm4.h **** 
1027:../stm32f4xx/core_cm4.h **** #define TPI_DEVID_PTINVALID_Pos             9                                          /*!< TPI DEV
1028:../stm32f4xx/core_cm4.h **** #define TPI_DEVID_PTINVALID_Msk            (0x1UL << TPI_DEVID_PTINVALID_Pos)          /*!< TPI DEV
1029:../stm32f4xx/core_cm4.h **** 
1030:../stm32f4xx/core_cm4.h **** #define TPI_DEVID_MinBufSz_Pos              6                                          /*!< TPI DEV
1031:../stm32f4xx/core_cm4.h **** #define TPI_DEVID_MinBufSz_Msk             (0x7UL << TPI_DEVID_MinBufSz_Pos)           /*!< TPI DEV
1032:../stm32f4xx/core_cm4.h **** 
1033:../stm32f4xx/core_cm4.h **** #define TPI_DEVID_AsynClkIn_Pos             5                                          /*!< TPI DEV
1034:../stm32f4xx/core_cm4.h **** #define TPI_DEVID_AsynClkIn_Msk            (0x1UL << TPI_DEVID_AsynClkIn_Pos)          /*!< TPI DEV
1035:../stm32f4xx/core_cm4.h **** 
1036:../stm32f4xx/core_cm4.h **** #define TPI_DEVID_NrTraceInput_Pos          0                                          /*!< TPI DEV
1037:../stm32f4xx/core_cm4.h **** #define TPI_DEVID_NrTraceInput_Msk         (0x1FUL << TPI_DEVID_NrTraceInput_Pos)      /*!< TPI DEV
1038:../stm32f4xx/core_cm4.h **** 
1039:../stm32f4xx/core_cm4.h **** /* TPI DEVTYPE Register Definitions */
1040:../stm32f4xx/core_cm4.h **** #define TPI_DEVTYPE_SubType_Pos             0                                          /*!< TPI DEV
1041:../stm32f4xx/core_cm4.h **** #define TPI_DEVTYPE_SubType_Msk            (0xFUL << TPI_DEVTYPE_SubType_Pos)          /*!< TPI DEV
1042:../stm32f4xx/core_cm4.h **** 
1043:../stm32f4xx/core_cm4.h **** #define TPI_DEVTYPE_MajorType_Pos           4                                          /*!< TPI DEV
1044:../stm32f4xx/core_cm4.h **** #define TPI_DEVTYPE_MajorType_Msk          (0xFUL << TPI_DEVTYPE_MajorType_Pos)        /*!< TPI DEV
1045:../stm32f4xx/core_cm4.h **** 
1046:../stm32f4xx/core_cm4.h **** /*@}*/ /* end of group CMSIS_TPI */
1047:../stm32f4xx/core_cm4.h **** 
1048:../stm32f4xx/core_cm4.h **** 
1049:../stm32f4xx/core_cm4.h **** #if (__MPU_PRESENT == 1)
1050:../stm32f4xx/core_cm4.h **** /** \ingroup  CMSIS_core_register
1051:../stm32f4xx/core_cm4.h ****     \defgroup CMSIS_MPU     Memory Protection Unit (MPU)
1052:../stm32f4xx/core_cm4.h ****     \brief      Type definitions for the Memory Protection Unit (MPU)
1053:../stm32f4xx/core_cm4.h ****   @{
1054:../stm32f4xx/core_cm4.h ****  */
1055:../stm32f4xx/core_cm4.h **** 
1056:../stm32f4xx/core_cm4.h **** /** \brief  Structure type to access the Memory Protection Unit (MPU).
1057:../stm32f4xx/core_cm4.h ****  */
1058:../stm32f4xx/core_cm4.h **** typedef struct
1059:../stm32f4xx/core_cm4.h **** {
1060:../stm32f4xx/core_cm4.h ****   __I  uint32_t TYPE;                    /*!< Offset: 0x000 (R/ )  MPU Type Register               
1061:../stm32f4xx/core_cm4.h ****   __IO uint32_t CTRL;                    /*!< Offset: 0x004 (R/W)  MPU Control Register            
1062:../stm32f4xx/core_cm4.h ****   __IO uint32_t RNR;                     /*!< Offset: 0x008 (R/W)  MPU Region RNRber Register      
1063:../stm32f4xx/core_cm4.h ****   __IO uint32_t RBAR;                    /*!< Offset: 0x00C (R/W)  MPU Region Base Address Register
1064:../stm32f4xx/core_cm4.h ****   __IO uint32_t RASR;                    /*!< Offset: 0x010 (R/W)  MPU Region Attribute and Size Re
1065:../stm32f4xx/core_cm4.h ****   __IO uint32_t RBAR_A1;                 /*!< Offset: 0x014 (R/W)  MPU Alias 1 Region Base Address 
1066:../stm32f4xx/core_cm4.h ****   __IO uint32_t RASR_A1;                 /*!< Offset: 0x018 (R/W)  MPU Alias 1 Region Attribute and
1067:../stm32f4xx/core_cm4.h ****   __IO uint32_t RBAR_A2;                 /*!< Offset: 0x01C (R/W)  MPU Alias 2 Region Base Address 
1068:../stm32f4xx/core_cm4.h ****   __IO uint32_t RASR_A2;                 /*!< Offset: 0x020 (R/W)  MPU Alias 2 Region Attribute and
1069:../stm32f4xx/core_cm4.h ****   __IO uint32_t RBAR_A3;                 /*!< Offset: 0x024 (R/W)  MPU Alias 3 Region Base Address 
1070:../stm32f4xx/core_cm4.h ****   __IO uint32_t RASR_A3;                 /*!< Offset: 0x028 (R/W)  MPU Alias 3 Region Attribute and
1071:../stm32f4xx/core_cm4.h **** } MPU_Type;
1072:../stm32f4xx/core_cm4.h **** 
1073:../stm32f4xx/core_cm4.h **** /* MPU Type Register */
1074:../stm32f4xx/core_cm4.h **** #define MPU_TYPE_IREGION_Pos               16                                             /*!< MPU 
1075:../stm32f4xx/core_cm4.h **** #define MPU_TYPE_IREGION_Msk               (0xFFUL << MPU_TYPE_IREGION_Pos)               /*!< MPU 
1076:../stm32f4xx/core_cm4.h **** 
1077:../stm32f4xx/core_cm4.h **** #define MPU_TYPE_DREGION_Pos                8                                             /*!< MPU 
1078:../stm32f4xx/core_cm4.h **** #define MPU_TYPE_DREGION_Msk               (0xFFUL << MPU_TYPE_DREGION_Pos)               /*!< MPU 
1079:../stm32f4xx/core_cm4.h **** 
1080:../stm32f4xx/core_cm4.h **** #define MPU_TYPE_SEPARATE_Pos               0                                             /*!< MPU 
1081:../stm32f4xx/core_cm4.h **** #define MPU_TYPE_SEPARATE_Msk              (1UL << MPU_TYPE_SEPARATE_Pos)                 /*!< MPU 
1082:../stm32f4xx/core_cm4.h **** 
1083:../stm32f4xx/core_cm4.h **** /* MPU Control Register */
1084:../stm32f4xx/core_cm4.h **** #define MPU_CTRL_PRIVDEFENA_Pos             2                                             /*!< MPU 
1085:../stm32f4xx/core_cm4.h **** #define MPU_CTRL_PRIVDEFENA_Msk            (1UL << MPU_CTRL_PRIVDEFENA_Pos)               /*!< MPU 
1086:../stm32f4xx/core_cm4.h **** 
1087:../stm32f4xx/core_cm4.h **** #define MPU_CTRL_HFNMIENA_Pos               1                                             /*!< MPU 
1088:../stm32f4xx/core_cm4.h **** #define MPU_CTRL_HFNMIENA_Msk              (1UL << MPU_CTRL_HFNMIENA_Pos)                 /*!< MPU 
1089:../stm32f4xx/core_cm4.h **** 
1090:../stm32f4xx/core_cm4.h **** #define MPU_CTRL_ENABLE_Pos                 0                                             /*!< MPU 
1091:../stm32f4xx/core_cm4.h **** #define MPU_CTRL_ENABLE_Msk                (1UL << MPU_CTRL_ENABLE_Pos)                   /*!< MPU 
1092:../stm32f4xx/core_cm4.h **** 
1093:../stm32f4xx/core_cm4.h **** /* MPU Region Number Register */
1094:../stm32f4xx/core_cm4.h **** #define MPU_RNR_REGION_Pos                  0                                             /*!< MPU 
1095:../stm32f4xx/core_cm4.h **** #define MPU_RNR_REGION_Msk                 (0xFFUL << MPU_RNR_REGION_Pos)                 /*!< MPU 
1096:../stm32f4xx/core_cm4.h **** 
1097:../stm32f4xx/core_cm4.h **** /* MPU Region Base Address Register */
1098:../stm32f4xx/core_cm4.h **** #define MPU_RBAR_ADDR_Pos                   5                                             /*!< MPU 
1099:../stm32f4xx/core_cm4.h **** #define MPU_RBAR_ADDR_Msk                  (0x7FFFFFFUL << MPU_RBAR_ADDR_Pos)             /*!< MPU 
1100:../stm32f4xx/core_cm4.h **** 
1101:../stm32f4xx/core_cm4.h **** #define MPU_RBAR_VALID_Pos                  4                                             /*!< MPU 
1102:../stm32f4xx/core_cm4.h **** #define MPU_RBAR_VALID_Msk                 (1UL << MPU_RBAR_VALID_Pos)                    /*!< MPU 
1103:../stm32f4xx/core_cm4.h **** 
1104:../stm32f4xx/core_cm4.h **** #define MPU_RBAR_REGION_Pos                 0                                             /*!< MPU 
1105:../stm32f4xx/core_cm4.h **** #define MPU_RBAR_REGION_Msk                (0xFUL << MPU_RBAR_REGION_Pos)                 /*!< MPU 
1106:../stm32f4xx/core_cm4.h **** 
1107:../stm32f4xx/core_cm4.h **** /* MPU Region Attribute and Size Register */
1108:../stm32f4xx/core_cm4.h **** #define MPU_RASR_ATTRS_Pos                 16                                             /*!< MPU 
1109:../stm32f4xx/core_cm4.h **** #define MPU_RASR_ATTRS_Msk                 (0xFFFFUL << MPU_RASR_ATTRS_Pos)               /*!< MPU 
1110:../stm32f4xx/core_cm4.h **** 
1111:../stm32f4xx/core_cm4.h **** #define MPU_RASR_XN_Pos                    28                                             /*!< MPU 
1112:../stm32f4xx/core_cm4.h **** #define MPU_RASR_XN_Msk                    (1UL << MPU_RASR_XN_Pos)                       /*!< MPU 
1113:../stm32f4xx/core_cm4.h **** 
1114:../stm32f4xx/core_cm4.h **** #define MPU_RASR_AP_Pos                    24                                             /*!< MPU 
1115:../stm32f4xx/core_cm4.h **** #define MPU_RASR_AP_Msk                    (0x7UL << MPU_RASR_AP_Pos)                     /*!< MPU 
1116:../stm32f4xx/core_cm4.h **** 
1117:../stm32f4xx/core_cm4.h **** #define MPU_RASR_TEX_Pos                   19                                             /*!< MPU 
1118:../stm32f4xx/core_cm4.h **** #define MPU_RASR_TEX_Msk                   (0x7UL << MPU_RASR_TEX_Pos)                    /*!< MPU 
1119:../stm32f4xx/core_cm4.h **** 
1120:../stm32f4xx/core_cm4.h **** #define MPU_RASR_S_Pos                     18                                             /*!< MPU 
1121:../stm32f4xx/core_cm4.h **** #define MPU_RASR_S_Msk                     (1UL << MPU_RASR_S_Pos)                        /*!< MPU 
1122:../stm32f4xx/core_cm4.h **** 
1123:../stm32f4xx/core_cm4.h **** #define MPU_RASR_C_Pos                     17                                             /*!< MPU 
1124:../stm32f4xx/core_cm4.h **** #define MPU_RASR_C_Msk                     (1UL << MPU_RASR_C_Pos)                        /*!< MPU 
1125:../stm32f4xx/core_cm4.h **** 
1126:../stm32f4xx/core_cm4.h **** #define MPU_RASR_B_Pos                     16                                             /*!< MPU 
1127:../stm32f4xx/core_cm4.h **** #define MPU_RASR_B_Msk                     (1UL << MPU_RASR_B_Pos)                        /*!< MPU 
1128:../stm32f4xx/core_cm4.h **** 
1129:../stm32f4xx/core_cm4.h **** #define MPU_RASR_SRD_Pos                    8                                             /*!< MPU 
1130:../stm32f4xx/core_cm4.h **** #define MPU_RASR_SRD_Msk                   (0xFFUL << MPU_RASR_SRD_Pos)                   /*!< MPU 
1131:../stm32f4xx/core_cm4.h **** 
1132:../stm32f4xx/core_cm4.h **** #define MPU_RASR_SIZE_Pos                   1                                             /*!< MPU 
1133:../stm32f4xx/core_cm4.h **** #define MPU_RASR_SIZE_Msk                  (0x1FUL << MPU_RASR_SIZE_Pos)                  /*!< MPU 
1134:../stm32f4xx/core_cm4.h **** 
1135:../stm32f4xx/core_cm4.h **** #define MPU_RASR_ENABLE_Pos                 0                                             /*!< MPU 
1136:../stm32f4xx/core_cm4.h **** #define MPU_RASR_ENABLE_Msk                (1UL << MPU_RASR_ENABLE_Pos)                   /*!< MPU 
1137:../stm32f4xx/core_cm4.h **** 
1138:../stm32f4xx/core_cm4.h **** /*@} end of group CMSIS_MPU */
1139:../stm32f4xx/core_cm4.h **** #endif
1140:../stm32f4xx/core_cm4.h **** 
1141:../stm32f4xx/core_cm4.h **** 
1142:../stm32f4xx/core_cm4.h **** #if (__FPU_PRESENT == 1)
1143:../stm32f4xx/core_cm4.h **** /** \ingroup  CMSIS_core_register
1144:../stm32f4xx/core_cm4.h ****     \defgroup CMSIS_FPU     Floating Point Unit (FPU)
1145:../stm32f4xx/core_cm4.h ****     \brief      Type definitions for the Floating Point Unit (FPU)
1146:../stm32f4xx/core_cm4.h ****   @{
1147:../stm32f4xx/core_cm4.h ****  */
1148:../stm32f4xx/core_cm4.h **** 
1149:../stm32f4xx/core_cm4.h **** /** \brief  Structure type to access the Floating Point Unit (FPU).
1150:../stm32f4xx/core_cm4.h ****  */
1151:../stm32f4xx/core_cm4.h **** typedef struct
1152:../stm32f4xx/core_cm4.h **** {
1153:../stm32f4xx/core_cm4.h ****        uint32_t RESERVED0[1];
1154:../stm32f4xx/core_cm4.h ****   __IO uint32_t FPCCR;                   /*!< Offset: 0x004 (R/W)  Floating-Point Context Control R
1155:../stm32f4xx/core_cm4.h ****   __IO uint32_t FPCAR;                   /*!< Offset: 0x008 (R/W)  Floating-Point Context Address R
1156:../stm32f4xx/core_cm4.h ****   __IO uint32_t FPDSCR;                  /*!< Offset: 0x00C (R/W)  Floating-Point Default Status Co
1157:../stm32f4xx/core_cm4.h ****   __I  uint32_t MVFR0;                   /*!< Offset: 0x010 (R/ )  Media and FP Feature Register 0 
1158:../stm32f4xx/core_cm4.h ****   __I  uint32_t MVFR1;                   /*!< Offset: 0x014 (R/ )  Media and FP Feature Register 1 
1159:../stm32f4xx/core_cm4.h **** } FPU_Type;
1160:../stm32f4xx/core_cm4.h **** 
1161:../stm32f4xx/core_cm4.h **** /* Floating-Point Context Control Register */
1162:../stm32f4xx/core_cm4.h **** #define FPU_FPCCR_ASPEN_Pos                31                                             /*!< FPCC
1163:../stm32f4xx/core_cm4.h **** #define FPU_FPCCR_ASPEN_Msk                (1UL << FPU_FPCCR_ASPEN_Pos)                   /*!< FPCC
1164:../stm32f4xx/core_cm4.h **** 
1165:../stm32f4xx/core_cm4.h **** #define FPU_FPCCR_LSPEN_Pos                30                                             /*!< FPCC
1166:../stm32f4xx/core_cm4.h **** #define FPU_FPCCR_LSPEN_Msk                (1UL << FPU_FPCCR_LSPEN_Pos)                   /*!< FPCC
1167:../stm32f4xx/core_cm4.h **** 
1168:../stm32f4xx/core_cm4.h **** #define FPU_FPCCR_MONRDY_Pos                8                                             /*!< FPCC
1169:../stm32f4xx/core_cm4.h **** #define FPU_FPCCR_MONRDY_Msk               (1UL << FPU_FPCCR_MONRDY_Pos)                  /*!< FPCC
1170:../stm32f4xx/core_cm4.h **** 
1171:../stm32f4xx/core_cm4.h **** #define FPU_FPCCR_BFRDY_Pos                 6                                             /*!< FPCC
1172:../stm32f4xx/core_cm4.h **** #define FPU_FPCCR_BFRDY_Msk                (1UL << FPU_FPCCR_BFRDY_Pos)                   /*!< FPCC
1173:../stm32f4xx/core_cm4.h **** 
1174:../stm32f4xx/core_cm4.h **** #define FPU_FPCCR_MMRDY_Pos                 5                                             /*!< FPCC
1175:../stm32f4xx/core_cm4.h **** #define FPU_FPCCR_MMRDY_Msk                (1UL << FPU_FPCCR_MMRDY_Pos)                   /*!< FPCC
1176:../stm32f4xx/core_cm4.h **** 
1177:../stm32f4xx/core_cm4.h **** #define FPU_FPCCR_HFRDY_Pos                 4                                             /*!< FPCC
1178:../stm32f4xx/core_cm4.h **** #define FPU_FPCCR_HFRDY_Msk                (1UL << FPU_FPCCR_HFRDY_Pos)                   /*!< FPCC
1179:../stm32f4xx/core_cm4.h **** 
1180:../stm32f4xx/core_cm4.h **** #define FPU_FPCCR_THREAD_Pos                3                                             /*!< FPCC
1181:../stm32f4xx/core_cm4.h **** #define FPU_FPCCR_THREAD_Msk               (1UL << FPU_FPCCR_THREAD_Pos)                  /*!< FPCC
1182:../stm32f4xx/core_cm4.h **** 
1183:../stm32f4xx/core_cm4.h **** #define FPU_FPCCR_USER_Pos                  1                                             /*!< FPCC
1184:../stm32f4xx/core_cm4.h **** #define FPU_FPCCR_USER_Msk                 (1UL << FPU_FPCCR_USER_Pos)                    /*!< FPCC
1185:../stm32f4xx/core_cm4.h **** 
1186:../stm32f4xx/core_cm4.h **** #define FPU_FPCCR_LSPACT_Pos                0                                             /*!< FPCC
1187:../stm32f4xx/core_cm4.h **** #define FPU_FPCCR_LSPACT_Msk               (1UL << FPU_FPCCR_LSPACT_Pos)                  /*!< FPCC
1188:../stm32f4xx/core_cm4.h **** 
1189:../stm32f4xx/core_cm4.h **** /* Floating-Point Context Address Register */
1190:../stm32f4xx/core_cm4.h **** #define FPU_FPCAR_ADDRESS_Pos               3                                             /*!< FPCA
1191:../stm32f4xx/core_cm4.h **** #define FPU_FPCAR_ADDRESS_Msk              (0x1FFFFFFFUL << FPU_FPCAR_ADDRESS_Pos)        /*!< FPCA
1192:../stm32f4xx/core_cm4.h **** 
1193:../stm32f4xx/core_cm4.h **** /* Floating-Point Default Status Control Register */
1194:../stm32f4xx/core_cm4.h **** #define FPU_FPDSCR_AHP_Pos                 26                                             /*!< FPDS
1195:../stm32f4xx/core_cm4.h **** #define FPU_FPDSCR_AHP_Msk                 (1UL << FPU_FPDSCR_AHP_Pos)                    /*!< FPDS
1196:../stm32f4xx/core_cm4.h **** 
1197:../stm32f4xx/core_cm4.h **** #define FPU_FPDSCR_DN_Pos                  25                                             /*!< FPDS
1198:../stm32f4xx/core_cm4.h **** #define FPU_FPDSCR_DN_Msk                  (1UL << FPU_FPDSCR_DN_Pos)                     /*!< FPDS
1199:../stm32f4xx/core_cm4.h **** 
1200:../stm32f4xx/core_cm4.h **** #define FPU_FPDSCR_FZ_Pos                  24                                             /*!< FPDS
1201:../stm32f4xx/core_cm4.h **** #define FPU_FPDSCR_FZ_Msk                  (1UL << FPU_FPDSCR_FZ_Pos)                     /*!< FPDS
1202:../stm32f4xx/core_cm4.h **** 
1203:../stm32f4xx/core_cm4.h **** #define FPU_FPDSCR_RMode_Pos               22                                             /*!< FPDS
1204:../stm32f4xx/core_cm4.h **** #define FPU_FPDSCR_RMode_Msk               (3UL << FPU_FPDSCR_RMode_Pos)                  /*!< FPDS
1205:../stm32f4xx/core_cm4.h **** 
1206:../stm32f4xx/core_cm4.h **** /* Media and FP Feature Register 0 */
1207:../stm32f4xx/core_cm4.h **** #define FPU_MVFR0_FP_rounding_modes_Pos    28                                             /*!< MVFR
1208:../stm32f4xx/core_cm4.h **** #define FPU_MVFR0_FP_rounding_modes_Msk    (0xFUL << FPU_MVFR0_FP_rounding_modes_Pos)     /*!< MVFR
1209:../stm32f4xx/core_cm4.h **** 
1210:../stm32f4xx/core_cm4.h **** #define FPU_MVFR0_Short_vectors_Pos        24                                             /*!< MVFR
1211:../stm32f4xx/core_cm4.h **** #define FPU_MVFR0_Short_vectors_Msk        (0xFUL << FPU_MVFR0_Short_vectors_Pos)         /*!< MVFR
1212:../stm32f4xx/core_cm4.h **** 
1213:../stm32f4xx/core_cm4.h **** #define FPU_MVFR0_Square_root_Pos          20                                             /*!< MVFR
1214:../stm32f4xx/core_cm4.h **** #define FPU_MVFR0_Square_root_Msk          (0xFUL << FPU_MVFR0_Square_root_Pos)           /*!< MVFR
1215:../stm32f4xx/core_cm4.h **** 
1216:../stm32f4xx/core_cm4.h **** #define FPU_MVFR0_Divide_Pos               16                                             /*!< MVFR
1217:../stm32f4xx/core_cm4.h **** #define FPU_MVFR0_Divide_Msk               (0xFUL << FPU_MVFR0_Divide_Pos)                /*!< MVFR
1218:../stm32f4xx/core_cm4.h **** 
1219:../stm32f4xx/core_cm4.h **** #define FPU_MVFR0_FP_excep_trapping_Pos    12                                             /*!< MVFR
1220:../stm32f4xx/core_cm4.h **** #define FPU_MVFR0_FP_excep_trapping_Msk    (0xFUL << FPU_MVFR0_FP_excep_trapping_Pos)     /*!< MVFR
1221:../stm32f4xx/core_cm4.h **** 
1222:../stm32f4xx/core_cm4.h **** #define FPU_MVFR0_Double_precision_Pos      8                                             /*!< MVFR
1223:../stm32f4xx/core_cm4.h **** #define FPU_MVFR0_Double_precision_Msk     (0xFUL << FPU_MVFR0_Double_precision_Pos)      /*!< MVFR
1224:../stm32f4xx/core_cm4.h **** 
1225:../stm32f4xx/core_cm4.h **** #define FPU_MVFR0_Single_precision_Pos      4                                             /*!< MVFR
1226:../stm32f4xx/core_cm4.h **** #define FPU_MVFR0_Single_precision_Msk     (0xFUL << FPU_MVFR0_Single_precision_Pos)      /*!< MVFR
1227:../stm32f4xx/core_cm4.h **** 
1228:../stm32f4xx/core_cm4.h **** #define FPU_MVFR0_A_SIMD_registers_Pos      0                                             /*!< MVFR
1229:../stm32f4xx/core_cm4.h **** #define FPU_MVFR0_A_SIMD_registers_Msk     (0xFUL << FPU_MVFR0_A_SIMD_registers_Pos)      /*!< MVFR
1230:../stm32f4xx/core_cm4.h **** 
1231:../stm32f4xx/core_cm4.h **** /* Media and FP Feature Register 1 */
1232:../stm32f4xx/core_cm4.h **** #define FPU_MVFR1_FP_fused_MAC_Pos         28                                             /*!< MVFR
1233:../stm32f4xx/core_cm4.h **** #define FPU_MVFR1_FP_fused_MAC_Msk         (0xFUL << FPU_MVFR1_FP_fused_MAC_Pos)          /*!< MVFR
1234:../stm32f4xx/core_cm4.h **** 
1235:../stm32f4xx/core_cm4.h **** #define FPU_MVFR1_FP_HPFP_Pos              24                                             /*!< MVFR
1236:../stm32f4xx/core_cm4.h **** #define FPU_MVFR1_FP_HPFP_Msk              (0xFUL << FPU_MVFR1_FP_HPFP_Pos)               /*!< MVFR
1237:../stm32f4xx/core_cm4.h **** 
1238:../stm32f4xx/core_cm4.h **** #define FPU_MVFR1_D_NaN_mode_Pos            4                                             /*!< MVFR
1239:../stm32f4xx/core_cm4.h **** #define FPU_MVFR1_D_NaN_mode_Msk           (0xFUL << FPU_MVFR1_D_NaN_mode_Pos)            /*!< MVFR
1240:../stm32f4xx/core_cm4.h **** 
1241:../stm32f4xx/core_cm4.h **** #define FPU_MVFR1_FtZ_mode_Pos              0                                             /*!< MVFR
1242:../stm32f4xx/core_cm4.h **** #define FPU_MVFR1_FtZ_mode_Msk             (0xFUL << FPU_MVFR1_FtZ_mode_Pos)              /*!< MVFR
1243:../stm32f4xx/core_cm4.h **** 
1244:../stm32f4xx/core_cm4.h **** /*@} end of group CMSIS_FPU */
1245:../stm32f4xx/core_cm4.h **** #endif
1246:../stm32f4xx/core_cm4.h **** 
1247:../stm32f4xx/core_cm4.h **** 
1248:../stm32f4xx/core_cm4.h **** /** \ingroup  CMSIS_core_register
1249:../stm32f4xx/core_cm4.h ****     \defgroup CMSIS_CoreDebug       Core Debug Registers (CoreDebug)
1250:../stm32f4xx/core_cm4.h ****     \brief      Type definitions for the Core Debug Registers
1251:../stm32f4xx/core_cm4.h ****   @{
1252:../stm32f4xx/core_cm4.h ****  */
1253:../stm32f4xx/core_cm4.h **** 
1254:../stm32f4xx/core_cm4.h **** /** \brief  Structure type to access the Core Debug Register (CoreDebug).
1255:../stm32f4xx/core_cm4.h ****  */
1256:../stm32f4xx/core_cm4.h **** typedef struct
1257:../stm32f4xx/core_cm4.h **** {
1258:../stm32f4xx/core_cm4.h ****   __IO uint32_t DHCSR;                   /*!< Offset: 0x000 (R/W)  Debug Halting Control and Status
1259:../stm32f4xx/core_cm4.h ****   __O  uint32_t DCRSR;                   /*!< Offset: 0x004 ( /W)  Debug Core Register Selector Reg
1260:../stm32f4xx/core_cm4.h ****   __IO uint32_t DCRDR;                   /*!< Offset: 0x008 (R/W)  Debug Core Register Data Registe
1261:../stm32f4xx/core_cm4.h ****   __IO uint32_t DEMCR;                   /*!< Offset: 0x00C (R/W)  Debug Exception and Monitor Cont
1262:../stm32f4xx/core_cm4.h **** } CoreDebug_Type;
1263:../stm32f4xx/core_cm4.h **** 
1264:../stm32f4xx/core_cm4.h **** /* Debug Halting Control and Status Register */
1265:../stm32f4xx/core_cm4.h **** #define CoreDebug_DHCSR_DBGKEY_Pos         16                                             /*!< Core
1266:../stm32f4xx/core_cm4.h **** #define CoreDebug_DHCSR_DBGKEY_Msk         (0xFFFFUL << CoreDebug_DHCSR_DBGKEY_Pos)       /*!< Core
1267:../stm32f4xx/core_cm4.h **** 
1268:../stm32f4xx/core_cm4.h **** #define CoreDebug_DHCSR_S_RESET_ST_Pos     25                                             /*!< Core
1269:../stm32f4xx/core_cm4.h **** #define CoreDebug_DHCSR_S_RESET_ST_Msk     (1UL << CoreDebug_DHCSR_S_RESET_ST_Pos)        /*!< Core
1270:../stm32f4xx/core_cm4.h **** 
1271:../stm32f4xx/core_cm4.h **** #define CoreDebug_DHCSR_S_RETIRE_ST_Pos    24                                             /*!< Core
1272:../stm32f4xx/core_cm4.h **** #define CoreDebug_DHCSR_S_RETIRE_ST_Msk    (1UL << CoreDebug_DHCSR_S_RETIRE_ST_Pos)       /*!< Core
1273:../stm32f4xx/core_cm4.h **** 
1274:../stm32f4xx/core_cm4.h **** #define CoreDebug_DHCSR_S_LOCKUP_Pos       19                                             /*!< Core
1275:../stm32f4xx/core_cm4.h **** #define CoreDebug_DHCSR_S_LOCKUP_Msk       (1UL << CoreDebug_DHCSR_S_LOCKUP_Pos)          /*!< Core
1276:../stm32f4xx/core_cm4.h **** 
1277:../stm32f4xx/core_cm4.h **** #define CoreDebug_DHCSR_S_SLEEP_Pos        18                                             /*!< Core
1278:../stm32f4xx/core_cm4.h **** #define CoreDebug_DHCSR_S_SLEEP_Msk        (1UL << CoreDebug_DHCSR_S_SLEEP_Pos)           /*!< Core
1279:../stm32f4xx/core_cm4.h **** 
1280:../stm32f4xx/core_cm4.h **** #define CoreDebug_DHCSR_S_HALT_Pos         17                                             /*!< Core
1281:../stm32f4xx/core_cm4.h **** #define CoreDebug_DHCSR_S_HALT_Msk         (1UL << CoreDebug_DHCSR_S_HALT_Pos)            /*!< Core
1282:../stm32f4xx/core_cm4.h **** 
1283:../stm32f4xx/core_cm4.h **** #define CoreDebug_DHCSR_S_REGRDY_Pos       16                                             /*!< Core
1284:../stm32f4xx/core_cm4.h **** #define CoreDebug_DHCSR_S_REGRDY_Msk       (1UL << CoreDebug_DHCSR_S_REGRDY_Pos)          /*!< Core
1285:../stm32f4xx/core_cm4.h **** 
1286:../stm32f4xx/core_cm4.h **** #define CoreDebug_DHCSR_C_SNAPSTALL_Pos     5                                             /*!< Core
1287:../stm32f4xx/core_cm4.h **** #define CoreDebug_DHCSR_C_SNAPSTALL_Msk    (1UL << CoreDebug_DHCSR_C_SNAPSTALL_Pos)       /*!< Core
1288:../stm32f4xx/core_cm4.h **** 
1289:../stm32f4xx/core_cm4.h **** #define CoreDebug_DHCSR_C_MASKINTS_Pos      3                                             /*!< Core
1290:../stm32f4xx/core_cm4.h **** #define CoreDebug_DHCSR_C_MASKINTS_Msk     (1UL << CoreDebug_DHCSR_C_MASKINTS_Pos)        /*!< Core
1291:../stm32f4xx/core_cm4.h **** 
1292:../stm32f4xx/core_cm4.h **** #define CoreDebug_DHCSR_C_STEP_Pos          2                                             /*!< Core
1293:../stm32f4xx/core_cm4.h **** #define CoreDebug_DHCSR_C_STEP_Msk         (1UL << CoreDebug_DHCSR_C_STEP_Pos)            /*!< Core
1294:../stm32f4xx/core_cm4.h **** 
1295:../stm32f4xx/core_cm4.h **** #define CoreDebug_DHCSR_C_HALT_Pos          1                                             /*!< Core
1296:../stm32f4xx/core_cm4.h **** #define CoreDebug_DHCSR_C_HALT_Msk         (1UL << CoreDebug_DHCSR_C_HALT_Pos)            /*!< Core
1297:../stm32f4xx/core_cm4.h **** 
1298:../stm32f4xx/core_cm4.h **** #define CoreDebug_DHCSR_C_DEBUGEN_Pos       0                                             /*!< Core
1299:../stm32f4xx/core_cm4.h **** #define CoreDebug_DHCSR_C_DEBUGEN_Msk      (1UL << CoreDebug_DHCSR_C_DEBUGEN_Pos)         /*!< Core
1300:../stm32f4xx/core_cm4.h **** 
1301:../stm32f4xx/core_cm4.h **** /* Debug Core Register Selector Register */
1302:../stm32f4xx/core_cm4.h **** #define CoreDebug_DCRSR_REGWnR_Pos         16                                             /*!< Core
1303:../stm32f4xx/core_cm4.h **** #define CoreDebug_DCRSR_REGWnR_Msk         (1UL << CoreDebug_DCRSR_REGWnR_Pos)            /*!< Core
1304:../stm32f4xx/core_cm4.h **** 
1305:../stm32f4xx/core_cm4.h **** #define CoreDebug_DCRSR_REGSEL_Pos          0                                             /*!< Core
1306:../stm32f4xx/core_cm4.h **** #define CoreDebug_DCRSR_REGSEL_Msk         (0x1FUL << CoreDebug_DCRSR_REGSEL_Pos)         /*!< Core
1307:../stm32f4xx/core_cm4.h **** 
1308:../stm32f4xx/core_cm4.h **** /* Debug Exception and Monitor Control Register */
1309:../stm32f4xx/core_cm4.h **** #define CoreDebug_DEMCR_TRCENA_Pos         24                                             /*!< Core
1310:../stm32f4xx/core_cm4.h **** #define CoreDebug_DEMCR_TRCENA_Msk         (1UL << CoreDebug_DEMCR_TRCENA_Pos)            /*!< Core
1311:../stm32f4xx/core_cm4.h **** 
1312:../stm32f4xx/core_cm4.h **** #define CoreDebug_DEMCR_MON_REQ_Pos        19                                             /*!< Core
1313:../stm32f4xx/core_cm4.h **** #define CoreDebug_DEMCR_MON_REQ_Msk        (1UL << CoreDebug_DEMCR_MON_REQ_Pos)           /*!< Core
1314:../stm32f4xx/core_cm4.h **** 
1315:../stm32f4xx/core_cm4.h **** #define CoreDebug_DEMCR_MON_STEP_Pos       18                                             /*!< Core
1316:../stm32f4xx/core_cm4.h **** #define CoreDebug_DEMCR_MON_STEP_Msk       (1UL << CoreDebug_DEMCR_MON_STEP_Pos)          /*!< Core
1317:../stm32f4xx/core_cm4.h **** 
1318:../stm32f4xx/core_cm4.h **** #define CoreDebug_DEMCR_MON_PEND_Pos       17                                             /*!< Core
1319:../stm32f4xx/core_cm4.h **** #define CoreDebug_DEMCR_MON_PEND_Msk       (1UL << CoreDebug_DEMCR_MON_PEND_Pos)          /*!< Core
1320:../stm32f4xx/core_cm4.h **** 
1321:../stm32f4xx/core_cm4.h **** #define CoreDebug_DEMCR_MON_EN_Pos         16                                             /*!< Core
1322:../stm32f4xx/core_cm4.h **** #define CoreDebug_DEMCR_MON_EN_Msk         (1UL << CoreDebug_DEMCR_MON_EN_Pos)            /*!< Core
1323:../stm32f4xx/core_cm4.h **** 
1324:../stm32f4xx/core_cm4.h **** #define CoreDebug_DEMCR_VC_HARDERR_Pos     10                                             /*!< Core
1325:../stm32f4xx/core_cm4.h **** #define CoreDebug_DEMCR_VC_HARDERR_Msk     (1UL << CoreDebug_DEMCR_VC_HARDERR_Pos)        /*!< Core
1326:../stm32f4xx/core_cm4.h **** 
1327:../stm32f4xx/core_cm4.h **** #define CoreDebug_DEMCR_VC_INTERR_Pos       9                                             /*!< Core
1328:../stm32f4xx/core_cm4.h **** #define CoreDebug_DEMCR_VC_INTERR_Msk      (1UL << CoreDebug_DEMCR_VC_INTERR_Pos)         /*!< Core
1329:../stm32f4xx/core_cm4.h **** 
1330:../stm32f4xx/core_cm4.h **** #define CoreDebug_DEMCR_VC_BUSERR_Pos       8                                             /*!< Core
1331:../stm32f4xx/core_cm4.h **** #define CoreDebug_DEMCR_VC_BUSERR_Msk      (1UL << CoreDebug_DEMCR_VC_BUSERR_Pos)         /*!< Core
1332:../stm32f4xx/core_cm4.h **** 
1333:../stm32f4xx/core_cm4.h **** #define CoreDebug_DEMCR_VC_STATERR_Pos      7                                             /*!< Core
1334:../stm32f4xx/core_cm4.h **** #define CoreDebug_DEMCR_VC_STATERR_Msk     (1UL << CoreDebug_DEMCR_VC_STATERR_Pos)        /*!< Core
1335:../stm32f4xx/core_cm4.h **** 
1336:../stm32f4xx/core_cm4.h **** #define CoreDebug_DEMCR_VC_CHKERR_Pos       6                                             /*!< Core
1337:../stm32f4xx/core_cm4.h **** #define CoreDebug_DEMCR_VC_CHKERR_Msk      (1UL << CoreDebug_DEMCR_VC_CHKERR_Pos)         /*!< Core
1338:../stm32f4xx/core_cm4.h **** 
1339:../stm32f4xx/core_cm4.h **** #define CoreDebug_DEMCR_VC_NOCPERR_Pos      5                                             /*!< Core
1340:../stm32f4xx/core_cm4.h **** #define CoreDebug_DEMCR_VC_NOCPERR_Msk     (1UL << CoreDebug_DEMCR_VC_NOCPERR_Pos)        /*!< Core
1341:../stm32f4xx/core_cm4.h **** 
1342:../stm32f4xx/core_cm4.h **** #define CoreDebug_DEMCR_VC_MMERR_Pos        4                                             /*!< Core
1343:../stm32f4xx/core_cm4.h **** #define CoreDebug_DEMCR_VC_MMERR_Msk       (1UL << CoreDebug_DEMCR_VC_MMERR_Pos)          /*!< Core
1344:../stm32f4xx/core_cm4.h **** 
1345:../stm32f4xx/core_cm4.h **** #define CoreDebug_DEMCR_VC_CORERESET_Pos    0                                             /*!< Core
1346:../stm32f4xx/core_cm4.h **** #define CoreDebug_DEMCR_VC_CORERESET_Msk   (1UL << CoreDebug_DEMCR_VC_CORERESET_Pos)      /*!< Core
1347:../stm32f4xx/core_cm4.h **** 
1348:../stm32f4xx/core_cm4.h **** /*@} end of group CMSIS_CoreDebug */
1349:../stm32f4xx/core_cm4.h **** 
1350:../stm32f4xx/core_cm4.h **** 
1351:../stm32f4xx/core_cm4.h **** /** \ingroup    CMSIS_core_register
1352:../stm32f4xx/core_cm4.h ****     \defgroup   CMSIS_core_base     Core Definitions
1353:../stm32f4xx/core_cm4.h ****     \brief      Definitions for base addresses, unions, and structures.
1354:../stm32f4xx/core_cm4.h ****   @{
1355:../stm32f4xx/core_cm4.h ****  */
1356:../stm32f4xx/core_cm4.h **** 
1357:../stm32f4xx/core_cm4.h **** /* Memory mapping of Cortex-M4 Hardware */
1358:../stm32f4xx/core_cm4.h **** #define SCS_BASE            (0xE000E000UL)                            /*!< System Control Space Bas
1359:../stm32f4xx/core_cm4.h **** #define ITM_BASE            (0xE0000000UL)                            /*!< ITM Base Address        
1360:../stm32f4xx/core_cm4.h **** #define DWT_BASE            (0xE0001000UL)                            /*!< DWT Base Address        
1361:../stm32f4xx/core_cm4.h **** #define TPI_BASE            (0xE0040000UL)                            /*!< TPI Base Address        
1362:../stm32f4xx/core_cm4.h **** #define CoreDebug_BASE      (0xE000EDF0UL)                            /*!< Core Debug Base Address 
1363:../stm32f4xx/core_cm4.h **** #define SysTick_BASE        (SCS_BASE +  0x0010UL)                    /*!< SysTick Base Address    
1364:../stm32f4xx/core_cm4.h **** #define NVIC_BASE           (SCS_BASE +  0x0100UL)                    /*!< NVIC Base Address       
1365:../stm32f4xx/core_cm4.h **** #define SCB_BASE            (SCS_BASE +  0x0D00UL)                    /*!< System Control Block Bas
1366:../stm32f4xx/core_cm4.h **** 
1367:../stm32f4xx/core_cm4.h **** #define SCnSCB              ((SCnSCB_Type    *)     SCS_BASE      )   /*!< System control Register 
1368:../stm32f4xx/core_cm4.h **** #define SCB                 ((SCB_Type       *)     SCB_BASE      )   /*!< SCB configuration struct
1369:../stm32f4xx/core_cm4.h **** #define SysTick             ((SysTick_Type   *)     SysTick_BASE  )   /*!< SysTick configuration st
1370:../stm32f4xx/core_cm4.h **** #define NVIC                ((NVIC_Type      *)     NVIC_BASE     )   /*!< NVIC configuration struc
1371:../stm32f4xx/core_cm4.h **** #define ITM                 ((ITM_Type       *)     ITM_BASE      )   /*!< ITM configuration struct
1372:../stm32f4xx/core_cm4.h **** #define DWT                 ((DWT_Type       *)     DWT_BASE      )   /*!< DWT configuration struct
1373:../stm32f4xx/core_cm4.h **** #define TPI                 ((TPI_Type       *)     TPI_BASE      )   /*!< TPI configuration struct
1374:../stm32f4xx/core_cm4.h **** #define CoreDebug           ((CoreDebug_Type *)     CoreDebug_BASE)   /*!< Core Debug configuration
1375:../stm32f4xx/core_cm4.h **** 
1376:../stm32f4xx/core_cm4.h **** #if (__MPU_PRESENT == 1)
1377:../stm32f4xx/core_cm4.h ****   #define MPU_BASE          (SCS_BASE +  0x0D90UL)                    /*!< Memory Protection Unit  
1378:../stm32f4xx/core_cm4.h ****   #define MPU               ((MPU_Type       *)     MPU_BASE      )   /*!< Memory Protection Unit  
1379:../stm32f4xx/core_cm4.h **** #endif
1380:../stm32f4xx/core_cm4.h **** 
1381:../stm32f4xx/core_cm4.h **** #if (__FPU_PRESENT == 1)
1382:../stm32f4xx/core_cm4.h ****   #define FPU_BASE          (SCS_BASE +  0x0F30UL)                    /*!< Floating Point Unit     
1383:../stm32f4xx/core_cm4.h ****   #define FPU               ((FPU_Type       *)     FPU_BASE      )   /*!< Floating Point Unit     
1384:../stm32f4xx/core_cm4.h **** #endif
1385:../stm32f4xx/core_cm4.h **** 
1386:../stm32f4xx/core_cm4.h **** /*@} */
1387:../stm32f4xx/core_cm4.h **** 
1388:../stm32f4xx/core_cm4.h **** 
1389:../stm32f4xx/core_cm4.h **** 
1390:../stm32f4xx/core_cm4.h **** /*******************************************************************************
1391:../stm32f4xx/core_cm4.h ****  *                Hardware Abstraction Layer
1392:../stm32f4xx/core_cm4.h ****   Core Function Interface contains:
1393:../stm32f4xx/core_cm4.h ****   - Core NVIC Functions
1394:../stm32f4xx/core_cm4.h ****   - Core SysTick Functions
1395:../stm32f4xx/core_cm4.h ****   - Core Debug Functions
1396:../stm32f4xx/core_cm4.h ****   - Core Register Access Functions
1397:../stm32f4xx/core_cm4.h ****  ******************************************************************************/
1398:../stm32f4xx/core_cm4.h **** /** \defgroup CMSIS_Core_FunctionInterface Functions and Instructions Reference
1399:../stm32f4xx/core_cm4.h **** */
1400:../stm32f4xx/core_cm4.h **** 
1401:../stm32f4xx/core_cm4.h **** 
1402:../stm32f4xx/core_cm4.h **** 
1403:../stm32f4xx/core_cm4.h **** /* ##########################   NVIC functions  #################################### */
1404:../stm32f4xx/core_cm4.h **** /** \ingroup  CMSIS_Core_FunctionInterface
1405:../stm32f4xx/core_cm4.h ****     \defgroup CMSIS_Core_NVICFunctions NVIC Functions
1406:../stm32f4xx/core_cm4.h ****     \brief      Functions that manage interrupts and exceptions via the NVIC.
1407:../stm32f4xx/core_cm4.h ****     @{
1408:../stm32f4xx/core_cm4.h ****  */
1409:../stm32f4xx/core_cm4.h **** 
1410:../stm32f4xx/core_cm4.h **** /** \brief  Set Priority Grouping
1411:../stm32f4xx/core_cm4.h **** 
1412:../stm32f4xx/core_cm4.h ****   The function sets the priority grouping field using the required unlock sequence.
1413:../stm32f4xx/core_cm4.h ****   The parameter PriorityGroup is assigned to the field SCB->AIRCR [10:8] PRIGROUP field.
1414:../stm32f4xx/core_cm4.h ****   Only values from 0..7 are used.
1415:../stm32f4xx/core_cm4.h ****   In case of a conflict between priority grouping and available
1416:../stm32f4xx/core_cm4.h ****   priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.
1417:../stm32f4xx/core_cm4.h **** 
1418:../stm32f4xx/core_cm4.h ****     \param [in]      PriorityGroup  Priority grouping field.
1419:../stm32f4xx/core_cm4.h ****  */
1420:../stm32f4xx/core_cm4.h **** __STATIC_INLINE void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
1421:../stm32f4xx/core_cm4.h **** {
1422:../stm32f4xx/core_cm4.h ****   uint32_t reg_value;
1423:../stm32f4xx/core_cm4.h ****   uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07);               /* only values 0..7 a
1424:../stm32f4xx/core_cm4.h **** 
1425:../stm32f4xx/core_cm4.h ****   reg_value  =  SCB->AIRCR;                                                   /* read old register 
1426:../stm32f4xx/core_cm4.h ****   reg_value &= ~(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk);             /* clear bits to chan
1427:../stm32f4xx/core_cm4.h ****   reg_value  =  (reg_value                                 |
1428:../stm32f4xx/core_cm4.h ****                 ((uint32_t)0x5FA << SCB_AIRCR_VECTKEY_Pos) |
1429:../stm32f4xx/core_cm4.h ****                 (PriorityGroupTmp << 8));                                     /* Insert write key a
1430:../stm32f4xx/core_cm4.h ****   SCB->AIRCR =  reg_value;
1431:../stm32f4xx/core_cm4.h **** }
1432:../stm32f4xx/core_cm4.h **** 
1433:../stm32f4xx/core_cm4.h **** 
1434:../stm32f4xx/core_cm4.h **** /** \brief  Get Priority Grouping
1435:../stm32f4xx/core_cm4.h **** 
1436:../stm32f4xx/core_cm4.h ****   The function reads the priority grouping field from the NVIC Interrupt Controller.
1437:../stm32f4xx/core_cm4.h **** 
1438:../stm32f4xx/core_cm4.h ****     \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
1439:../stm32f4xx/core_cm4.h ****  */
1440:../stm32f4xx/core_cm4.h **** __STATIC_INLINE uint32_t NVIC_GetPriorityGrouping(void)
1441:../stm32f4xx/core_cm4.h **** {
1442:../stm32f4xx/core_cm4.h ****   return ((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos);   /* read priority grou
1443:../stm32f4xx/core_cm4.h **** }
1444:../stm32f4xx/core_cm4.h **** 
1445:../stm32f4xx/core_cm4.h **** 
1446:../stm32f4xx/core_cm4.h **** /** \brief  Enable External Interrupt
1447:../stm32f4xx/core_cm4.h **** 
1448:../stm32f4xx/core_cm4.h ****     The function enables a device-specific interrupt in the NVIC interrupt controller.
1449:../stm32f4xx/core_cm4.h **** 
1450:../stm32f4xx/core_cm4.h ****     \param [in]      IRQn  External interrupt number. Value cannot be negative.
1451:../stm32f4xx/core_cm4.h ****  */
1452:../stm32f4xx/core_cm4.h **** __STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
1453:../stm32f4xx/core_cm4.h **** {
  25              		.loc 1 1453 0
  26              		.cfi_startproc
  27              		@ args = 0, pretend = 0, frame = 8
  28              		@ frame_needed = 1, uses_anonymous_args = 0
  29              		@ link register save eliminated.
  30 0000 80B4     		push	{r7}
  31              	.LCFI0:
  32              		.cfi_def_cfa_offset 4
  33              		.cfi_offset 7, -4
  34 0002 83B0     		sub	sp, sp, #12
  35              	.LCFI1:
  36              		.cfi_def_cfa_offset 16
  37 0004 00AF     		add	r7, sp, #0
  38              	.LCFI2:
  39              		.cfi_def_cfa_register 7
  40 0006 0346     		mov	r3, r0
  41 0008 FB71     		strb	r3, [r7, #7]
1454:../stm32f4xx/core_cm4.h **** /*  NVIC->ISER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F));  enable interrupt */
1455:../stm32f4xx/core_cm4.h ****   NVIC->ISER[(uint32_t)((int32_t)IRQn) >> 5] = (uint32_t)(1 << ((uint32_t)((int32_t)IRQn) & (uint32
  42              		.loc 1 1455 0
  43 000a 4FF46143 		mov	r3, #57600
  44 000e CEF20003 		movt	r3, 57344
  45 0012 97F90720 		ldrsb	r2, [r7, #7]
  46 0016 4FEA5212 		lsr	r2, r2, #5
  47 001a F979     		ldrb	r1, [r7, #7]	@ zero_extendqisi2
  48 001c 01F01F01 		and	r1, r1, #31
  49 0020 4FF00100 		mov	r0, #1
  50 0024 00FA01F1 		lsl	r1, r0, r1
  51 0028 43F82210 		str	r1, [r3, r2, lsl #2]
1456:../stm32f4xx/core_cm4.h **** }
  52              		.loc 1 1456 0
  53 002c 07F10C07 		add	r7, r7, #12
  54 0030 BD46     		mov	sp, r7
  55 0032 80BC     		pop	{r7}
  56 0034 7047     		bx	lr
  57              		.cfi_endproc
  58              	.LFE96:
  60 0036 00BF     		.align	2
  61              		.thumb
  62              		.thumb_func
  64              	NVIC_DisableIRQ:
  65              	.LFB97:
1457:../stm32f4xx/core_cm4.h **** 
1458:../stm32f4xx/core_cm4.h **** 
1459:../stm32f4xx/core_cm4.h **** /** \brief  Disable External Interrupt
1460:../stm32f4xx/core_cm4.h **** 
1461:../stm32f4xx/core_cm4.h ****     The function disables a device-specific interrupt in the NVIC interrupt controller.
1462:../stm32f4xx/core_cm4.h **** 
1463:../stm32f4xx/core_cm4.h ****     \param [in]      IRQn  External interrupt number. Value cannot be negative.
1464:../stm32f4xx/core_cm4.h ****  */
1465:../stm32f4xx/core_cm4.h **** __STATIC_INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
1466:../stm32f4xx/core_cm4.h **** {
  66              		.loc 1 1466 0
  67              		.cfi_startproc
  68              		@ args = 0, pretend = 0, frame = 8
  69              		@ frame_needed = 1, uses_anonymous_args = 0
  70              		@ link register save eliminated.
  71 0038 80B4     		push	{r7}
  72              	.LCFI3:
  73              		.cfi_def_cfa_offset 4
  74              		.cfi_offset 7, -4
  75 003a 83B0     		sub	sp, sp, #12
  76              	.LCFI4:
  77              		.cfi_def_cfa_offset 16
  78 003c 00AF     		add	r7, sp, #0
  79              	.LCFI5:
  80              		.cfi_def_cfa_register 7
  81 003e 0346     		mov	r3, r0
  82 0040 FB71     		strb	r3, [r7, #7]
1467:../stm32f4xx/core_cm4.h ****   NVIC->ICER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* disable interrupt */
  83              		.loc 1 1467 0
  84 0042 4FF46143 		mov	r3, #57600
  85 0046 CEF20003 		movt	r3, 57344
  86 004a 97F90720 		ldrsb	r2, [r7, #7]
  87 004e 4FEA5212 		lsr	r2, r2, #5
  88 0052 F979     		ldrb	r1, [r7, #7]	@ zero_extendqisi2
  89 0054 01F01F01 		and	r1, r1, #31
  90 0058 4FF00100 		mov	r0, #1
  91 005c 00FA01F1 		lsl	r1, r0, r1
  92 0060 02F12002 		add	r2, r2, #32
  93 0064 43F82210 		str	r1, [r3, r2, lsl #2]
1468:../stm32f4xx/core_cm4.h **** }
  94              		.loc 1 1468 0
  95 0068 07F10C07 		add	r7, r7, #12
  96 006c BD46     		mov	sp, r7
  97 006e 80BC     		pop	{r7}
  98 0070 7047     		bx	lr
  99              		.cfi_endproc
 100              	.LFE97:
 102              		.section	.rodata
 103              		.align	2
 106              	AX12_values_ranges:
 107 0000 00       		.byte	0
 108 0001 00       		.byte	0
 109 0002 00       		.byte	0
 110 0003 20       		.byte	32
 111 0004 12       		.byte	18
 112 0005 10       		.byte	16
 113 0006 00       		.byte	0
 114 0007 10       		.byte	16
 115 0008 00       		.byte	0
 116 0009 10       		.byte	16
 117 000a 00       		.byte	0
 118 000b 40       		.byte	64
 119 000c 33       		.byte	51
 120 000d 33       		.byte	51
 121 000e 00       		.byte	0
 122 000f 10       		.byte	16
 123 0010 60       		.byte	96
 124 0011 50       		.byte	80
 125 0012 50       		.byte	80
 126 0013 70       		.byte	112
 127 0014 00       		.byte	0
 128 0015 00       		.byte	0
 129 0016 00       		.byte	0
 130 0017 00       		.byte	0
 131 0018 70       		.byte	112
 132 0019 70       		.byte	112
 133 001a 10       		.byte	16
 134 001b 10       		.byte	16
 135 001c 11       		.byte	17
 136 001d 11       		.byte	17
 137 001e 00       		.byte	0
 138 001f 10       		.byte	16
 139 0020 00       		.byte	0
 140 0021 10       		.byte	16
 141 0022 00       		.byte	0
 142 0023 10       		.byte	16
 143 0024 00       		.byte	0
 144 0025 00       		.byte	0
 145 0026 00       		.byte	0
 146 0027 00       		.byte	0
 147 0028 00       		.byte	0
 148 0029 00       		.byte	0
 149 002a 00       		.byte	0
 150 002b 00       		.byte	0
 151 002c 00       		.byte	0
 152 002d 00       		.byte	0
 153 002e 00       		.byte	0
 154 002f 70       		.byte	112
 155 0030 00       		.byte	0
 156 0031 10       		.byte	16
 157              		.bss
 158              		.align	2
 159              	AX12_on_the_robot:
 160 0000 00000000 		.space	70
 160      00000000 
 160      00000000 
 160      00000000 
 160      00000000 
 161 0046 0000     		.align	2
 162              	state_machine:
 163 0048 00000000 		.space	14
 163      00000000 
 163      00000000 
 163      0000
 164 0056 0000     		.align	2
 165              	AX12_special_instruction_buffer:
 166 0058 00000000 		.space	1610
 166      00000000 
 166      00000000 
 166      00000000 
 166      00000000 
 167              	AX12_prepare_commands:
 168 06a2 00       		.space	1
 169              		.text
 170 0072 00BF     		.align	2
 171              		.thumb
 172              		.thumb_func
 174              	AX12_instruction_async_read:
 175              	.LFB111:
 176              		.file 2 "../QS/QS_ax12.c"
   1:../QS/QS_ax12.c **** /*
   2:../QS/QS_ax12.c ****  *	Club Robot ESEO 2010 - 2013
   3:../QS/QS_ax12.c ****  *	???
   4:../QS/QS_ax12.c ****  *
   5:../QS/QS_ax12.c ****  *	Fichier : QS_ax12.h
   6:../QS/QS_ax12.c ****  *	Package : Qualite Software
   7:../QS/QS_ax12.c ****  *	Description : Module de gestion des servomoteurs Dynamixel AX12/AX12+
   8:../QS/QS_ax12.c ****  *	Auteur : Ronan, Jacen, modifi et complt par Alexis (2012-2013)
   9:../QS/QS_ax12.c ****  *	Licence : CeCILL-C (voir LICENCE.txt)
  10:../QS/QS_ax12.c ****  *	Version 20121110
  11:../QS/QS_ax12.c ****  */
  12:../QS/QS_ax12.c **** 
  13:../QS/QS_ax12.c **** //Pour voir l'ancienne version avant les modifications faites pour le robot 2012-2013, utilisez la 
  14:../QS/QS_ax12.c **** 
  15:../QS/QS_ax12.c **** #include "QS_ax12.h"
  16:../QS/QS_ax12.c **** 
  17:../QS/QS_ax12.c **** #ifdef USE_AX12_SERVO
  18:../QS/QS_ax12.c **** 
  19:../QS/QS_ax12.c **** #include "QS_ports.h"
  20:../QS/QS_ax12.c **** #include "QS_outputlog.h"
  21:../QS/QS_ax12.c **** #include "stm32f4xx_usart.h"
  22:../QS/QS_ax12.c **** 
  23:../QS/QS_ax12.c **** #ifdef NEW_CONFIG_ORGANISATION
  24:../QS/QS_ax12.c **** 	#include "config_pin.h"
  25:../QS/QS_ax12.c **** #endif
  26:../QS/QS_ax12.c **** 
  27:../QS/QS_ax12.c **** 	/**********************************************************************/
  28:../QS/QS_ax12.c **** 	/** Paramtres de configuration du driver AX12                        */
  29:../QS/QS_ax12.c **** 	/**********************************************************************/
  30:../QS/QS_ax12.c **** 
  31:../QS/QS_ax12.c **** 	#if !defined(AX12_NUMBER) || AX12_NUMBER > 254
  32:../QS/QS_ax12.c **** 		#error "Vous devez definir un nombre de servo sur le robot (AX12_NUMBER) (254 max)"
  33:../QS/QS_ax12.c **** 	#endif /* ndef AX12_NUMBER */
  34:../QS/QS_ax12.c **** 
  35:../QS/QS_ax12.c **** 	//#define AX12_DEBUG_PACKETS: si dfini, les paquets envoy sont crit sur la sortie uart en utili
  36:../QS/QS_ax12.c **** 
  37:../QS/QS_ax12.c **** 	#ifndef AX12_UART_ID
  38:../QS/QS_ax12.c **** 		#define AX12_UART_ID 2
  39:../QS/QS_ax12.c **** 	#endif
  40:../QS/QS_ax12.c **** 
  41:../QS/QS_ax12.c **** #if AX12_UART_ID == 1
  42:../QS/QS_ax12.c **** 	#define AX12_UART_Ptr USART1
  43:../QS/QS_ax12.c **** 	#define AX12_UART_Interrupt USART1_IRQHandler
  44:../QS/QS_ax12.c **** 	#define AX12_UART_Interrupt_IRQn USART1_IRQn
  45:../QS/QS_ax12.c **** #elif AX12_UART_ID == 2
  46:../QS/QS_ax12.c **** 	#define AX12_UART_Ptr USART2
  47:../QS/QS_ax12.c **** 	#define AX12_UART_Interrupt USART2_IRQHandler
  48:../QS/QS_ax12.c **** 	#define AX12_UART_Interrupt_IRQn USART2_IRQn
  49:../QS/QS_ax12.c **** #else
  50:../QS/QS_ax12.c **** #warning "AX12: Unknown UART ID"
  51:../QS/QS_ax12.c **** #endif
  52:../QS/QS_ax12.c **** 
  53:../QS/QS_ax12.c **** 	#ifndef AX12_UART_BAUDRATE
  54:../QS/QS_ax12.c **** 		#define AX12_UART_BAUDRATE  56700
  55:../QS/QS_ax12.c **** 	#endif
  56:../QS/QS_ax12.c **** 
  57:../QS/QS_ax12.c **** 	#ifndef AX12_STATUS_RETURN_TIMEOUT
  58:../QS/QS_ax12.c **** 		#define AX12_STATUS_RETURN_TIMEOUT 50	//Ne pas mettre une valeur trop proche de celle prvue, l'A
  59:../QS/QS_ax12.c **** 	#endif
  60:../QS/QS_ax12.c **** 
  61:../QS/QS_ax12.c **** 	#ifndef AX12_STATUS_SEND_TIMEOUT
  62:../QS/QS_ax12.c **** 		#define AX12_STATUS_SEND_TIMEOUT 10
  63:../QS/QS_ax12.c **** 	#endif
  64:../QS/QS_ax12.c **** 
  65:../QS/QS_ax12.c **** 	#ifndef AX12_STATUS_RETURN_MODE
  66:../QS/QS_ax12.c **** 		#define AX12_STATUS_RETURN_MODE AX12_STATUS_RETURN_ONREAD
  67:../QS/QS_ax12.c **** 	#endif
  68:../QS/QS_ax12.c **** 
  69:../QS/QS_ax12.c **** 	#ifndef AX12_INSTRUCTION_BUFFER_SIZE
  70:../QS/QS_ax12.c **** 		#define AX12_INSTRUCTION_BUFFER_SIZE (5*AX12_NUMBER)
  71:../QS/QS_ax12.c **** 	#endif
  72:../QS/QS_ax12.c **** 
  73:../QS/QS_ax12.c **** 	/**********************************************************************/
  74:../QS/QS_ax12.c **** 	/** Configuration du timer pour le timeout de rception du status    **/
  75:../QS/QS_ax12.c **** 	/**********************************************************************/
  76:../QS/QS_ax12.c **** 
  77:../QS/QS_ax12.c **** 	#ifdef AX12_TIMER_ID
  78:../QS/QS_ax12.c **** 		#define TIMER_SRC_TIMER_ID AX12_TIMER_ID
  79:../QS/QS_ax12.c **** 	#endif
  80:../QS/QS_ax12.c **** 	#ifdef AX12_TIMER_USE_WATCHDOG
  81:../QS/QS_ax12.c **** 		#define TIMER_SRC_USE_WATCHDOG
  82:../QS/QS_ax12.c **** 	#endif
  83:../QS/QS_ax12.c **** 
  84:../QS/QS_ax12.c **** 	#include "QS_setTimerSource.h"
  85:../QS/QS_ax12.c **** 
  86:../QS/QS_ax12.c **** 	/*************************************************************************************/
  87:../QS/QS_ax12.c **** 
  88:../QS/QS_ax12.c **** 	/* UART2 exclusivement ddi  la gestion des servomoteurs AX-12+ */
  89:../QS/QS_ax12.c **** 
  90:../QS/QS_ax12.c **** 	#ifdef USE_UART2
  91:../QS/QS_ax12.c **** 		#error "Vous ne pouvez pas utiliser l'UART2 et l'AX12 en mme temps, l'AX12  besoin de l'UART2 p
  92:../QS/QS_ax12.c **** 	#endif
  93:../QS/QS_ax12.c **** 
  94:../QS/QS_ax12.c **** 	#ifndef AX12_DIRECTION_PORT
  95:../QS/QS_ax12.c **** 		#error "Vous devez definir un port de direction (AX12_DIRECTION_PORT) pour grer l'UART qui est e
  96:../QS/QS_ax12.c **** 	#endif /* ndef AX12_DIRECTION_PORT */
  97:../QS/QS_ax12.c **** 
  98:../QS/QS_ax12.c **** 	/* Pour UART half-uplex */
  99:../QS/QS_ax12.c **** 	#define TX_DIRECTION 1
 100:../QS/QS_ax12.c **** 	#define RX_DIRECTION 0
 101:../QS/QS_ax12.c **** 
 102:../QS/QS_ax12.c **** 
 103:../QS/QS_ax12.c **** 	/*************************************************************************************/
 104:../QS/QS_ax12.c **** 	/** Constantes lies au instruction envoyes a l'AX12                               **/
 105:../QS/QS_ax12.c **** 	/*************************************************************************************/
 106:../QS/QS_ax12.c **** 
 107:../QS/QS_ax12.c **** 	/* Instructions */
 108:../QS/QS_ax12.c **** 
 109:../QS/QS_ax12.c **** 	#define INST_PING 				0x01
 110:../QS/QS_ax12.c **** 	#define INST_READ 				0x02
 111:../QS/QS_ax12.c **** 	#define INST_WRITE 				0x03
 112:../QS/QS_ax12.c **** 	#define INST_REG_WRITE 			0x04
 113:../QS/QS_ax12.c **** 	#define INST_ACTION 			0x05
 114:../QS/QS_ax12.c **** 	//Instructions non utilises
 115:../QS/QS_ax12.c **** 	//#define INST_RESET 				0x06
 116:../QS/QS_ax12.c **** 	//#define INST_DIGITAL_RESET 		0x07
 117:../QS/QS_ax12.c **** 	//#define INST_SYSTEM_READ 		0x0C
 118:../QS/QS_ax12.c **** 	//#define INST_SYSTEM_WRITE 		0x0D
 119:../QS/QS_ax12.c **** 	//#define INST_SYNC_WRITE 		0x83
 120:../QS/QS_ax12.c **** 	//#define INST_SYNC_REG_WRITE 	0x84
 121:../QS/QS_ax12.c **** 
 122:../QS/QS_ax12.c **** 	// Adresses de la mmoire interne de l'AX12
 123:../QS/QS_ax12.c **** 	#define AX12_MEM_SIZE		0x32
 124:../QS/QS_ax12.c **** 
 125:../QS/QS_ax12.c **** 	#define AX12_MIN_VALUE_0	0x00
 126:../QS/QS_ax12.c **** 	#define AX12_MIN_VALUE_1	0x01
 127:../QS/QS_ax12.c **** 	#define AX12_MIN_VALUE_34	0x02
 128:../QS/QS_ax12.c **** 	#define AX12_MIN_VALUE_50	0x03
 129:../QS/QS_ax12.c **** 
 130:../QS/QS_ax12.c **** 	#define AX12_MAX_VALUE_1	0x70
 131:../QS/QS_ax12.c **** 	#define AX12_MAX_VALUE_2	0x60
 132:../QS/QS_ax12.c **** 	#define AX12_MAX_VALUE_127	0x50
 133:../QS/QS_ax12.c **** 	#define AX12_MAX_VALUE_150	0x40
 134:../QS/QS_ax12.c **** 	#define AX12_MAX_VALUE_250	0x30
 135:../QS/QS_ax12.c **** 	#define AX12_MAX_VALUE_253	0x20
 136:../QS/QS_ax12.c **** 	#define AX12_MAX_VALUE_254	0x10
 137:../QS/QS_ax12.c **** 	#define AX12_MAX_VALUE_1023	0x00
 138:../QS/QS_ax12.c **** 
 139:../QS/QS_ax12.c **** 	//Les defines sont globaux, il sont dfini en mme temps que le tableau des valeurs accept par l'
 140:../QS/QS_ax12.c **** 	static const Uint8 AX12_values_ranges[0x32] = {
 141:../QS/QS_ax12.c **** 		//EEPROM, utilis par les fonctions AX12_config_*, les valeurs persiste aprs une mise hors tensi
 142:../QS/QS_ax12.c **** 		#define AX12_MODEL_NUMBER_L 			0x00
 143:../QS/QS_ax12.c **** 			0,	//non utilis
 144:../QS/QS_ax12.c **** 		#define AX12_MODEL_NUMBER_H				0x01
 145:../QS/QS_ax12.c **** 			0,	//non utilis
 146:../QS/QS_ax12.c **** 		#define AX12_VERSION					0x02
 147:../QS/QS_ax12.c **** 			0,	//non utilis
 148:../QS/QS_ax12.c **** 		#define AX12_ID 						0x03
 149:../QS/QS_ax12.c **** 			AX12_MIN_VALUE_0 | AX12_MAX_VALUE_253,
 150:../QS/QS_ax12.c **** 		#define AX12_BAUD_RATE					0x04
 151:../QS/QS_ax12.c **** 			AX12_MIN_VALUE_34 | AX12_MAX_VALUE_254,	//la limite de l'AX12 est 0-254, mais la carte ne suppor
 152:../QS/QS_ax12.c **** 		#define AX12_RETURN_DELAY_TIME			0x05
 153:../QS/QS_ax12.c **** 			AX12_MIN_VALUE_0 | AX12_MAX_VALUE_254,	//Maximum de 508 us
 154:../QS/QS_ax12.c **** 		#define AX12_CW_ANGLE_LIMIT_L			0x06
 155:../QS/QS_ax12.c **** 			AX12_MIN_VALUE_0 | AX12_MAX_VALUE_1023,
 156:../QS/QS_ax12.c **** 		#define AX12_CW_ANGLE_LIMIT_H			0x07
 157:../QS/QS_ax12.c **** 			AX12_MIN_VALUE_0 | AX12_MAX_VALUE_254,	//ne devrait pas tre utilis
 158:../QS/QS_ax12.c **** 		#define AX12_CCW_ANGLE_LIMIT_L			0x08
 159:../QS/QS_ax12.c **** 			AX12_MIN_VALUE_0 | AX12_MAX_VALUE_1023,
 160:../QS/QS_ax12.c **** 		#define AX12_CCW_ANGLE_LIMIT_H			0x09
 161:../QS/QS_ax12.c **** 			AX12_MIN_VALUE_0 | AX12_MAX_VALUE_254,	//ne devrait pas tre utilis
 162:../QS/QS_ax12.c **** 		#define AX12_SYSTEM_DATA2				0x0A
 163:../QS/QS_ax12.c **** 			0,	//non utilis
 164:../QS/QS_ax12.c **** 		#define AX12_LIMIT_TEMPERATURE			0x0B
 165:../QS/QS_ax12.c **** 			AX12_MIN_VALUE_0 | AX12_MAX_VALUE_150,
 166:../QS/QS_ax12.c **** 		#define AX12_DOWN_LIMIT_VOLTAGE 		0x0C
 167:../QS/QS_ax12.c **** 			AX12_MIN_VALUE_50 | AX12_MAX_VALUE_250,
 168:../QS/QS_ax12.c **** 		#define AX12_UP_LIMIT_VOLTAGE			0x0D
 169:../QS/QS_ax12.c **** 			AX12_MIN_VALUE_50 | AX12_MAX_VALUE_250,
 170:../QS/QS_ax12.c **** 		#define AX12_MAX_TORQUE_L				0x0E
 171:../QS/QS_ax12.c **** 			AX12_MIN_VALUE_0 | AX12_MAX_VALUE_1023,
 172:../QS/QS_ax12.c **** 		#define AX12_MAX_TORQUE_H				0x0F
 173:../QS/QS_ax12.c **** 			AX12_MIN_VALUE_0 | AX12_MAX_VALUE_254,	//ne devrait pas tre utilis
 174:../QS/QS_ax12.c **** 		#define AX12_RETURN_LEVEL				0x10
 175:../QS/QS_ax12.c **** 			AX12_MIN_VALUE_0 | AX12_MAX_VALUE_2,
 176:../QS/QS_ax12.c **** 		#define AX12_ALARM_LED					0x11
 177:../QS/QS_ax12.c **** 			AX12_MIN_VALUE_0 | AX12_MAX_VALUE_127,
 178:../QS/QS_ax12.c **** 		#define AX12_ALARM_SHUTDOWN 			0x12
 179:../QS/QS_ax12.c **** 			AX12_MIN_VALUE_0 | AX12_MAX_VALUE_127,
 180:../QS/QS_ax12.c **** 		#define AX12_OPERATING_MODE 			0x13
 181:../QS/QS_ax12.c **** 			AX12_MIN_VALUE_0 | AX12_MAX_VALUE_1,
 182:../QS/QS_ax12.c **** 		#define AX12_DOWN_CALIBRATION_L 		0x14
 183:../QS/QS_ax12.c **** 			0,	//non utilis
 184:../QS/QS_ax12.c **** 		#define AX12_DOWN_CALIBRATION_H 		0x15
 185:../QS/QS_ax12.c **** 			0,	//non utilis
 186:../QS/QS_ax12.c **** 		#define AX12_UP_CALIBRATION_L			0x16
 187:../QS/QS_ax12.c **** 			0,	//non utilis
 188:../QS/QS_ax12.c **** 		#define AX12_UP_CALIBRATION_H			0x17
 189:../QS/QS_ax12.c **** 			0,	//non utilis
 190:../QS/QS_ax12.c **** 
 191:../QS/QS_ax12.c **** 		//RAM de l'AX12, reinitialis aprs une mise hors tension
 192:../QS/QS_ax12.c **** 		#define AX12_TORQUE_ENABLE				0x18
 193:../QS/QS_ax12.c **** 			AX12_MIN_VALUE_0 | AX12_MAX_VALUE_1,
 194:../QS/QS_ax12.c **** 		#define AX12_LED						0x19
 195:../QS/QS_ax12.c **** 			AX12_MIN_VALUE_0 | AX12_MAX_VALUE_1,
 196:../QS/QS_ax12.c **** 		#define AX12_CW_COMPLIANCE_MARGIN		0x1A
 197:../QS/QS_ax12.c **** 			AX12_MIN_VALUE_0 | AX12_MAX_VALUE_254,
 198:../QS/QS_ax12.c **** 		#define AX12_CCW_COMPLIANCE_MARGIN		0x1B
 199:../QS/QS_ax12.c **** 			AX12_MIN_VALUE_0 | AX12_MAX_VALUE_254,
 200:../QS/QS_ax12.c **** 		#define AX12_CW_COMPLIANCE_SLOPE		0x1C
 201:../QS/QS_ax12.c **** 			AX12_MIN_VALUE_1 | AX12_MAX_VALUE_254,
 202:../QS/QS_ax12.c **** 		#define AX12_CCW_COMPLIANCE_SLOPE		0x1D
 203:../QS/QS_ax12.c **** 			AX12_MIN_VALUE_1 | AX12_MAX_VALUE_254,
 204:../QS/QS_ax12.c **** 		#define AX12_GOAL_POSITION_L			0x1E
 205:../QS/QS_ax12.c **** 			AX12_MIN_VALUE_0 | AX12_MAX_VALUE_1023,
 206:../QS/QS_ax12.c **** 		#define AX12_GOAL_POSITION_H			0x1F
 207:../QS/QS_ax12.c **** 			AX12_MIN_VALUE_0 | AX12_MAX_VALUE_254,	//ne devrait pas tre utilis
 208:../QS/QS_ax12.c **** 		#define AX12_GOAL_SPEED_L				0x20
 209:../QS/QS_ax12.c **** 			AX12_MIN_VALUE_0 | AX12_MAX_VALUE_1023,
 210:../QS/QS_ax12.c **** 		#define AX12_GOAL_SPEED_H				0x21
 211:../QS/QS_ax12.c **** 			AX12_MIN_VALUE_0 | AX12_MAX_VALUE_254,	//ne devrait pas tre utilis
 212:../QS/QS_ax12.c **** 		#define AX12_TORQUE_LIMIT_L				0x22
 213:../QS/QS_ax12.c **** 			AX12_MIN_VALUE_0 | AX12_MAX_VALUE_1023,
 214:../QS/QS_ax12.c **** 		#define AX12_TORQUE_LIMIT_H 			0x23
 215:../QS/QS_ax12.c **** 			AX12_MIN_VALUE_0 | AX12_MAX_VALUE_254,	//ne devrait pas tre utilis
 216:../QS/QS_ax12.c **** 		#define AX12_PRESENT_POSITION_L 		0x24
 217:../QS/QS_ax12.c **** 			0,	//non utilis
 218:../QS/QS_ax12.c **** 		#define AX12_PRESENT_POSITION_H 		0x25
 219:../QS/QS_ax12.c **** 			0,	//non utilis
 220:../QS/QS_ax12.c **** 		#define AX12_PRESENT_SPEED_L			0x26
 221:../QS/QS_ax12.c **** 			0,	//non utilis
 222:../QS/QS_ax12.c **** 		#define AX12_PRESENT_SPEED_H			0x27
 223:../QS/QS_ax12.c **** 			0,	//non utilis
 224:../QS/QS_ax12.c **** 		#define AX12_PRESENT_LOAD_L 			0x28
 225:../QS/QS_ax12.c **** 			0,	//non utilis
 226:../QS/QS_ax12.c **** 		#define AX12_PRESENT_LOAD_H 			0x29
 227:../QS/QS_ax12.c **** 			0,	//non utilis
 228:../QS/QS_ax12.c **** 		#define AX12_PRESENT_VOLTAGE			0x2A
 229:../QS/QS_ax12.c **** 			0,	//non utilis
 230:../QS/QS_ax12.c **** 		#define AX12_PRESENT_TEMPERATURE		0x2B
 231:../QS/QS_ax12.c **** 			0,	//non utilis
 232:../QS/QS_ax12.c **** 		#define AX12_REGISTERED_INSTRUCTION		0x2C
 233:../QS/QS_ax12.c **** 			0,	//non utilis
 234:../QS/QS_ax12.c **** 		#define AX12_PAUSE_TIME 				0x2D
 235:../QS/QS_ax12.c **** 			0,	//non utilis
 236:../QS/QS_ax12.c **** 		#define AX12_MOVING 					0x2E
 237:../QS/QS_ax12.c **** 			0,	//non utilis
 238:../QS/QS_ax12.c **** 		#define AX12_LOCK						0x2F
 239:../QS/QS_ax12.c **** 			AX12_MIN_VALUE_0 | AX12_MAX_VALUE_1,
 240:../QS/QS_ax12.c **** 		#define AX12_PUNCH_L					0x30
 241:../QS/QS_ax12.c **** 			AX12_MIN_VALUE_0 | AX12_MAX_VALUE_1023,
 242:../QS/QS_ax12.c **** 		#define AX12_PUNCH_H					0x31
 243:../QS/QS_ax12.c **** 			AX12_MIN_VALUE_0 | AX12_MAX_VALUE_254	//ne devrait pas tre utilis
 244:../QS/QS_ax12.c **** 	};
 245:../QS/QS_ax12.c **** 
 246:../QS/QS_ax12.c **** 	/***********************************************************************/
 247:../QS/QS_ax12.c **** 	/** Autre dfinitions internes                                        **/
 248:../QS/QS_ax12.c **** 	/***********************************************************************/
 249:../QS/QS_ax12.c **** 
 250:../QS/QS_ax12.c **** 	//Si dfini, on teste le checksum des paquets de status, si le resultat est incorrect, le paquet e
 251:../QS/QS_ax12.c **** 	//#define AX12_STATUS_RETURN_CHECK_CHECKSUM
 252:../QS/QS_ax12.c **** 
 253:../QS/QS_ax12.c **** 	//nous avons besoin d'une place en plus pour pouvoir diffrencier le cas ou le buffer est vide du 
 254:../QS/QS_ax12.c **** 	#define AX12_INSTRUCTION_REAL_NEEDED_BUFFER_SIZE (AX12_INSTRUCTION_BUFFER_SIZE+1)
 255:../QS/QS_ax12.c **** 
 256:../QS/QS_ax12.c **** 	#define MIN_INSTRUCTION_PACKET_SIZE 6
 257:../QS/QS_ax12.c **** 	#define MAX_STATUS_PACKET_SIZE 8
 258:../QS/QS_ax12.c **** 
 259:../QS/QS_ax12.c **** 	//Macro pour simplifier l'incrementation d'index (la fonction modulo fait une division assez lourd
 260:../QS/QS_ax12.c **** 	//le modulo (%) c'est bien, mais c'est aussi beaucoup d'opration pour les cas utiliss (les valeu
 261:../QS/QS_ax12.c **** 	#define INC_WITH_MOD(val,div) (( (val)+1 < div )? (val)+1 : 0)
 262:../QS/QS_ax12.c **** 
 263:../QS/QS_ax12.c **** 	/***********************************************************************/
 264:../QS/QS_ax12.c **** 
 265:../QS/QS_ax12.c **** typedef struct{
 266:../QS/QS_ax12.c **** 	volatile AX12_status_t last_status;
 267:../QS/QS_ax12.c **** 	Uint16 angle_limit[2];	//sauvegarde des angles limites lors d'un passage en mode wheel (rotation c
 268:../QS/QS_ax12.c **** 	bool_e is_wheel_enabled;
 269:../QS/QS_ax12.c **** 	// Possibilit d'ajout de membres ...
 270:../QS/QS_ax12.c **** } AX12_servo_t;
 271:../QS/QS_ax12.c **** 
 272:../QS/QS_ax12.c **** //Paquet instruction a envoyer a l'AX12
 273:../QS/QS_ax12.c **** typedef struct{
 274:../QS/QS_ax12.c **** 	Uint8 id_servo;
 275:../QS/QS_ax12.c **** 	Uint8 type;
 276:../QS/QS_ax12.c **** 	Uint8 address;
 277:../QS/QS_ax12.c **** 	union {
 278:../QS/QS_ax12.c **** 		Uint16 param;
 279:../QS/QS_ax12.c **** 		struct {
 280:../QS/QS_ax12.c **** 			Uint8 param_1;	//poids fort
 281:../QS/QS_ax12.c **** 			Uint8 param_2;	//poids faible
 282:../QS/QS_ax12.c **** 		};
 283:../QS/QS_ax12.c **** 	};
 284:../QS/QS_ax12.c **** 	Uint8 size;
 285:../QS/QS_ax12.c **** } AX12_instruction_packet_t;
 286:../QS/QS_ax12.c **** 
 287:../QS/QS_ax12.c **** 
 288:../QS/QS_ax12.c **** //Paquet renvoy par l'AX12, 2 paramtres 8bits maximum
 289:../QS/QS_ax12.c **** typedef struct{
 290:../QS/QS_ax12.c **** 	Uint8 id_servo;
 291:../QS/QS_ax12.c **** 	Uint8 error;
 292:../QS/QS_ax12.c **** 	union {
 293:../QS/QS_ax12.c **** 		Uint16 param;
 294:../QS/QS_ax12.c **** 		struct {
 295:../QS/QS_ax12.c **** 			Uint8 param_1;	//poids fort
 296:../QS/QS_ax12.c **** 			Uint8 param_2;	//poids faible
 297:../QS/QS_ax12.c **** 		};
 298:../QS/QS_ax12.c **** 	};
 299:../QS/QS_ax12.c **** 	Uint8 size;
 300:../QS/QS_ax12.c **** } AX12_status_packet_t;
 301:../QS/QS_ax12.c **** 
 302:../QS/QS_ax12.c **** typedef struct{
 303:../QS/QS_ax12.c **** 	AX12_instruction_packet_t buffer[AX12_INSTRUCTION_REAL_NEEDED_BUFFER_SIZE];
 304:../QS/QS_ax12.c **** 	Uint8 start_index;
 305:../QS/QS_ax12.c **** 	Uint8 end_index;
 306:../QS/QS_ax12.c **** } AX12_instruction_buffer;
 307:../QS/QS_ax12.c **** 
 308:../QS/QS_ax12.c **** 
 309:../QS/QS_ax12.c **** //Machine  tats
 310:../QS/QS_ax12.c **** 
 311:../QS/QS_ax12.c **** // Raison d'appel de la fonction de la machine  tats
 312:../QS/QS_ax12.c **** typedef enum {
 313:../QS/QS_ax12.c **** 	AX12_SME_NoEvent,
 314:../QS/QS_ax12.c **** 	AX12_SME_RxInterrupt,
 315:../QS/QS_ax12.c **** 	AX12_SME_TxInterrupt,
 316:../QS/QS_ax12.c **** 	AX12_SME_Timeout
 317:../QS/QS_ax12.c **** } AX12_state_machine_event_e;
 318:../QS/QS_ax12.c **** 
 319:../QS/QS_ax12.c **** // Etat de la machine  tats
 320:../QS/QS_ax12.c **** typedef enum {
 321:../QS/QS_ax12.c **** 	AX12_SMS_ReadyToSend = 0,
 322:../QS/QS_ax12.c **** 	AX12_SMS_Sending,
 323:../QS/QS_ax12.c **** 	AX12_SMS_WaitingAnswer
 324:../QS/QS_ax12.c **** } AX12_state_machine_state_e;
 325:../QS/QS_ax12.c **** 
 326:../QS/QS_ax12.c **** 
 327:../QS/QS_ax12.c **** typedef struct {
 328:../QS/QS_ax12.c **** 	volatile AX12_state_machine_state_e state;
 329:../QS/QS_ax12.c **** 	volatile Uint16 timeout_counter;	//compteur dcrment par le timer lorsque que l'tat est AX12_SM
 330:../QS/QS_ax12.c **** 
 331:../QS/QS_ax12.c **** 	AX12_instruction_packet_t current_instruction;
 332:../QS/QS_ax12.c **** 
 333:../QS/QS_ax12.c **** 	//Utilis en mode SEND
 334:../QS/QS_ax12.c **** 	Uint8 sending_index, receive_index;
 335:../QS/QS_ax12.c **** } AX12_state_machine_t;
 336:../QS/QS_ax12.c **** 
 337:../QS/QS_ax12.c **** /*************************************************************************************/
 338:../QS/QS_ax12.c **** 
 339:../QS/QS_ax12.c **** // Variables globales, toutes les variables sont intialise a zero, il n'y a pas de {0} ou autre po
 340:../QS/QS_ax12.c **** 
 341:../QS/QS_ax12.c **** static AX12_servo_t AX12_on_the_robot[AX12_NUMBER];	//Tableau de structure contenant les informatio
 342:../QS/QS_ax12.c **** static AX12_state_machine_t state_machine = {0};	//Machine  tats du driver
 343:../QS/QS_ax12.c **** 
 344:../QS/QS_ax12.c **** //Queue contenant les instructions demande (ce buffer est gr pas les fonctions/macro AX12_instru
 345:../QS/QS_ax12.c **** static volatile AX12_instruction_buffer AX12_special_instruction_buffer;
 346:../QS/QS_ax12.c **** //Cette variable est  TRUE si le driver est en mode prparation de commandes. Voir doc de AX12_sta
 347:../QS/QS_ax12.c **** static bool_e AX12_prepare_commands = FALSE;
 348:../QS/QS_ax12.c **** 
 349:../QS/QS_ax12.c **** /**************************************************************************/
 350:../QS/QS_ax12.c **** /** Fonctions internes au driver de l'AX12+ et macros                    **/
 351:../QS/QS_ax12.c **** /**************************************************************************/
 352:../QS/QS_ax12.c **** 
 353:../QS/QS_ax12.c **** static inline Uint16 AX12_decode_value_range(Uint8 mem_addr, bool_e get_max);	//get_max = 1 pour r
 354:../QS/QS_ax12.c **** static Uint8 AX12_instruction_packet_calc_checksum(AX12_instruction_packet_t* instruction_packet);
 355:../QS/QS_ax12.c **** static Uint8 AX12_get_instruction_packet(Uint8 byte_offset, AX12_instruction_packet_t* instruction_
 356:../QS/QS_ax12.c **** #ifdef AX12_STATUS_RETURN_CHECK_CHECKSUM
 357:../QS/QS_ax12.c **** static Uint8 AX12_status_packet_calc_checksum(AX12_status_packet_t* status_packet);
 358:../QS/QS_ax12.c **** #endif
 359:../QS/QS_ax12.c **** static bool_e AX12_update_status_packet(Uint8 receive_byte, Uint8 byte_offset, AX12_status_packet_t
 360:../QS/QS_ax12.c **** static void AX12_state_machine(AX12_state_machine_event_e event);
 361:../QS/QS_ax12.c **** static void AX12_UART2_init(Uint32 uart_speed);
 362:../QS/QS_ax12.c **** 
 363:../QS/QS_ax12.c **** 
 364:../QS/QS_ax12.c **** /**************************************************************************/
 365:../QS/QS_ax12.c **** /** Fonctions/macro grant les instructions et le buffer d'instruction   **/
 366:../QS/QS_ax12.c **** /**************************************************************************/
 367:../QS/QS_ax12.c **** 
 368:../QS/QS_ax12.c **** /*
 369:../QS/QS_ax12.c ****  * Les fonctions AX12_instruction_async_* sont asynchrones, utiliser AX12_instruction_wait pour att
 370:../QS/QS_ax12.c ****  * Attention, ces fonctions attente que de la place se libre dans le buffer interne, attention lor
 371:../QS/QS_ax12.c ****  * Pour prvenir le problme, vous pouvez utiliser AX12_instruction_buffer_is_full() ou changer la 
 372:../QS/QS_ax12.c ****  * L'interruption de l'UART de l'AX12 a pour priorit 5 (pour Tx et Rx) (Si aucun changement n'est 
 373:../QS/QS_ax12.c ****  */
 374:../QS/QS_ax12.c **** 
 375:../QS/QS_ax12.c **** //Vous ne pouvez pas utiliser la fonction "AX12_instruction_*read" si le mode de retour d'informati
 376:../QS/QS_ax12.c **** 
 377:../QS/QS_ax12.c **** #if AX12_STATUS_RETURN_MODE != AX12_STATUS_RETURN_NEVER
 378:../QS/QS_ax12.c **** 	static bool_e AX12_instruction_async_read(Uint8 id_servo, Uint8 address, Uint8 length);
 379:../QS/QS_ax12.c **** 	static Uint16 AX12_instruction_read16(Uint8 id_servo, Uint8 address, bool_e *isOk);
 380:../QS/QS_ax12.c **** 	static Uint8  AX12_instruction_read8(Uint8 id_servo, Uint8 address, bool_e *isOk);
 381:../QS/QS_ax12.c **** #endif
 382:../QS/QS_ax12.c **** 
 383:../QS/QS_ax12.c **** static bool_e AX12_instruction_write8(Uint8 id_servo, Uint8 address, Uint8 value);
 384:../QS/QS_ax12.c **** static bool_e AX12_instruction_write16(Uint8 id_servo, Uint8 address, Uint16 value);
 385:../QS/QS_ax12.c **** static bool_e AX12_instruction_async_write8(Uint8 id_servo, Uint8 address, Uint8 value);
 386:../QS/QS_ax12.c **** static bool_e AX12_instruction_async_write16(Uint8 id_servo, Uint8 address, Uint16 value);
 387:../QS/QS_ax12.c **** static bool_e AX12_instruction_async_prepare_write8(Uint8 id_servo, Uint8 address, Uint8 value);
 388:../QS/QS_ax12.c **** static bool_e AX12_instruction_async_prepare_write16(Uint8 id_servo, Uint8 address, Uint16 value);
 389:../QS/QS_ax12.c **** static bool_e AX12_instruction_async_execute_write();
 390:../QS/QS_ax12.c **** static bool_e AX12_instruction_ping(Uint8 id_servo);
 391:../QS/QS_ax12.c **** static bool_e AX12_instruction_wait(Uint8 id_servo);
 392:../QS/QS_ax12.c **** static bool_e AX12_instruction_buffer_is_full();
 393:../QS/QS_ax12.c **** static AX12_status_t AX12_instruction_get_last_status(Uint8 id_servo);
 394:../QS/QS_ax12.c **** static void AX12_instruction_reset_last_status(Uint8 id_servo);
 395:../QS/QS_ax12.c **** 
 396:../QS/QS_ax12.c **** static bool_e AX12_instruction_queue_insert(const AX12_instruction_packet_t* inst);
 397:../QS/QS_ax12.c **** #define AX12_status_packet_is_full(status_packet, bytes_received) (((bytes_received) >= 4) && ((byt
 398:../QS/QS_ax12.c **** #define AX12_instruction_queue_is_full() (INC_WITH_MOD(AX12_special_instruction_buffer.end_index, A
 399:../QS/QS_ax12.c **** #define AX12_instruction_queue_is_empty() (AX12_special_instruction_buffer.end_index == AX12_specia
 400:../QS/QS_ax12.c **** #define AX12_instruction_queue_next() \
 401:../QS/QS_ax12.c **** 	(AX12_special_instruction_buffer.start_index = INC_WITH_MOD(AX12_special_instruction_buffer.start_
 402:../QS/QS_ax12.c **** #define AX12_instruction_queue_get_current() \
 403:../QS/QS_ax12.c **** 	AX12_special_instruction_buffer.buffer[AX12_special_instruction_buffer.start_index]
 404:../QS/QS_ax12.c **** 
 405:../QS/QS_ax12.c **** 
 406:../QS/QS_ax12.c **** //retourne TRUE si l'instruction est suivie d'une rponse de l'AX12
 407:../QS/QS_ax12.c **** //inst est de type AX12_instruction_packet_t
 408:../QS/QS_ax12.c **** #define AX12_instruction_has_status_packet(inst) (inst.id_servo != AX12_BROADCAST_ID && (AX12_STATU
 409:../QS/QS_ax12.c **** 
 410:../QS/QS_ax12.c **** /*************************************************************************************/
 411:../QS/QS_ax12.c **** /** Fonctions grant l'envoi de paquet instruction par l'intermdiaire du buffer    **/
 412:../QS/QS_ax12.c **** /*************************************************************************************/
 413:../QS/QS_ax12.c **** 
 414:../QS/QS_ax12.c **** #if AX12_STATUS_RETURN_MODE != AX12_STATUS_RETURN_NEVER
 415:../QS/QS_ax12.c **** static bool_e AX12_instruction_async_read(Uint8 id_servo, Uint8 address, Uint8 length) {
 177              		.loc 2 415 0
 178              		.cfi_startproc
 179              		@ args = 0, pretend = 0, frame = 16
 180              		@ frame_needed = 1, uses_anonymous_args = 0
 181 0074 80B5     		push	{r7, lr}
 182              	.LCFI6:
 183              		.cfi_def_cfa_offset 8
 184              		.cfi_offset 7, -8
 185              		.cfi_offset 14, -4
 186 0076 84B0     		sub	sp, sp, #16
 187              	.LCFI7:
 188              		.cfi_def_cfa_offset 24
 189 0078 00AF     		add	r7, sp, #0
 190              	.LCFI8:
 191              		.cfi_def_cfa_register 7
 192 007a 1346     		mov	r3, r2
 193 007c 0246     		mov	r2, r0
 194 007e FA71     		strb	r2, [r7, #7]
 195 0080 0A46     		mov	r2, r1
 196 0082 BA71     		strb	r2, [r7, #6]
 197 0084 7B71     		strb	r3, [r7, #5]
 416:../QS/QS_ax12.c **** 	AX12_instruction_packet_t inst = {0};
 198              		.loc 2 416 0
 199 0086 4FF00003 		mov	r3, #0
 200 008a BB60     		str	r3, [r7, #8]
 201 008c 4FF00003 		mov	r3, #0
 202 0090 FB60     		str	r3, [r7, #12]
 417:../QS/QS_ax12.c **** 
 418:../QS/QS_ax12.c **** 	inst.id_servo = id_servo;
 203              		.loc 2 418 0
 204 0092 FB79     		ldrb	r3, [r7, #7]
 205 0094 3B72     		strb	r3, [r7, #8]
 419:../QS/QS_ax12.c **** 	inst.type = INST_READ;
 206              		.loc 2 419 0
 207 0096 4FF00203 		mov	r3, #2
 208 009a 7B72     		strb	r3, [r7, #9]
 420:../QS/QS_ax12.c **** 	inst.address = address;
 209              		.loc 2 420 0
 210 009c BB79     		ldrb	r3, [r7, #6]
 211 009e BB72     		strb	r3, [r7, #10]
 421:../QS/QS_ax12.c **** 	inst.param_1 = length;
 212              		.loc 2 421 0
 213 00a0 7B79     		ldrb	r3, [r7, #5]
 214 00a2 3B73     		strb	r3, [r7, #12]
 422:../QS/QS_ax12.c **** 	inst.size = MIN_INSTRUCTION_PACKET_SIZE + 2;
 215              		.loc 2 422 0
 216 00a4 4FF00803 		mov	r3, #8
 217 00a8 BB73     		strb	r3, [r7, #14]
 423:../QS/QS_ax12.c **** 
 424:../QS/QS_ax12.c **** 	return AX12_instruction_queue_insert(&inst);
 218              		.loc 2 424 0
 219 00aa 07F10803 		add	r3, r7, #8
 220 00ae 1846     		mov	r0, r3
 221 00b0 01F014F9 		bl	AX12_instruction_queue_insert
 222 00b4 0346     		mov	r3, r0
 425:../QS/QS_ax12.c **** }
 223              		.loc 2 425 0
 224 00b6 1846     		mov	r0, r3
 225 00b8 07F11007 		add	r7, r7, #16
 226 00bc BD46     		mov	sp, r7
 227 00be 80BD     		pop	{r7, pc}
 228              		.cfi_endproc
 229              	.LFE111:
 231              		.align	2
 232              		.thumb
 233              		.thumb_func
 235              	AX12_instruction_async_write8:
 236              	.LFB112:
 426:../QS/QS_ax12.c **** #endif
 427:../QS/QS_ax12.c **** 
 428:../QS/QS_ax12.c **** static bool_e AX12_instruction_async_write8(Uint8 id_servo, Uint8 address, Uint8 value) {
 237              		.loc 2 428 0
 238              		.cfi_startproc
 239              		@ args = 0, pretend = 0, frame = 16
 240              		@ frame_needed = 1, uses_anonymous_args = 0
 241 00c0 90B5     		push	{r4, r7, lr}
 242              	.LCFI9:
 243              		.cfi_def_cfa_offset 12
 244              		.cfi_offset 4, -12
 245              		.cfi_offset 7, -8
 246              		.cfi_offset 14, -4
 247 00c2 85B0     		sub	sp, sp, #20
 248              	.LCFI10:
 249              		.cfi_def_cfa_offset 32
 250 00c4 00AF     		add	r7, sp, #0
 251              	.LCFI11:
 252              		.cfi_def_cfa_register 7
 253 00c6 1346     		mov	r3, r2
 254 00c8 0246     		mov	r2, r0
 255 00ca FA71     		strb	r2, [r7, #7]
 256 00cc 0A46     		mov	r2, r1
 257 00ce BA71     		strb	r2, [r7, #6]
 258 00d0 7B71     		strb	r3, [r7, #5]
 429:../QS/QS_ax12.c **** 	AX12_instruction_packet_t inst = {0};
 259              		.loc 2 429 0
 260 00d2 4FF00003 		mov	r3, #0
 261 00d6 BB60     		str	r3, [r7, #8]
 262 00d8 4FF00003 		mov	r3, #0
 263 00dc FB60     		str	r3, [r7, #12]
 430:../QS/QS_ax12.c **** 
 431:../QS/QS_ax12.c **** 	if((Uint16)value > AX12_decode_value_range(address, TRUE))
 264              		.loc 2 431 0
 265 00de 7B79     		ldrb	r3, [r7, #5]	@ zero_extendqisi2
 266 00e0 9CB2     		uxth	r4, r3
 267 00e2 BB79     		ldrb	r3, [r7, #6]	@ zero_extendqisi2
 268 00e4 1846     		mov	r0, r3
 269 00e6 4FF00101 		mov	r1, #1
 270 00ea 00F081FB 		bl	AX12_decode_value_range
 271 00ee 0346     		mov	r3, r0
 272 00f0 9C42     		cmp	r4, r3
 273 00f2 07D9     		bls	.L6
 432:../QS/QS_ax12.c **** 		value = AX12_decode_value_range(address, TRUE);
 274              		.loc 2 432 0
 275 00f4 BB79     		ldrb	r3, [r7, #6]	@ zero_extendqisi2
 276 00f6 1846     		mov	r0, r3
 277 00f8 4FF00101 		mov	r1, #1
 278 00fc 00F078FB 		bl	AX12_decode_value_range
 279 0100 0346     		mov	r3, r0
 280 0102 7B71     		strb	r3, [r7, #5]
 281              	.L6:
 433:../QS/QS_ax12.c **** 
 434:../QS/QS_ax12.c **** 	if((Uint16)value < AX12_decode_value_range(address, FALSE))
 282              		.loc 2 434 0
 283 0104 7B79     		ldrb	r3, [r7, #5]	@ zero_extendqisi2
 284 0106 9CB2     		uxth	r4, r3
 285 0108 BB79     		ldrb	r3, [r7, #6]	@ zero_extendqisi2
 286 010a 1846     		mov	r0, r3
 287 010c 4FF00001 		mov	r1, #0
 288 0110 00F06EFB 		bl	AX12_decode_value_range
 289 0114 0346     		mov	r3, r0
 290 0116 9C42     		cmp	r4, r3
 291 0118 07D2     		bcs	.L7
 435:../QS/QS_ax12.c **** 		value = AX12_decode_value_range(address, FALSE);
 292              		.loc 2 435 0
 293 011a BB79     		ldrb	r3, [r7, #6]	@ zero_extendqisi2
 294 011c 1846     		mov	r0, r3
 295 011e 4FF00001 		mov	r1, #0
 296 0122 00F065FB 		bl	AX12_decode_value_range
 297 0126 0346     		mov	r3, r0
 298 0128 7B71     		strb	r3, [r7, #5]
 299              	.L7:
 436:../QS/QS_ax12.c **** 
 437:../QS/QS_ax12.c **** 	inst.id_servo = id_servo;
 300              		.loc 2 437 0
 301 012a FB79     		ldrb	r3, [r7, #7]
 302 012c 3B72     		strb	r3, [r7, #8]
 438:../QS/QS_ax12.c **** 	inst.type = INST_WRITE;
 303              		.loc 2 438 0
 304 012e 4FF00303 		mov	r3, #3
 305 0132 7B72     		strb	r3, [r7, #9]
 439:../QS/QS_ax12.c **** 	inst.address = address;
 306              		.loc 2 439 0
 307 0134 BB79     		ldrb	r3, [r7, #6]
 308 0136 BB72     		strb	r3, [r7, #10]
 440:../QS/QS_ax12.c **** 	inst.param_1 = value;
 309              		.loc 2 440 0
 310 0138 7B79     		ldrb	r3, [r7, #5]
 311 013a 3B73     		strb	r3, [r7, #12]
 441:../QS/QS_ax12.c **** 	inst.size = MIN_INSTRUCTION_PACKET_SIZE + 2;
 312              		.loc 2 441 0
 313 013c 4FF00803 		mov	r3, #8
 314 0140 BB73     		strb	r3, [r7, #14]
 442:../QS/QS_ax12.c **** 
 443:../QS/QS_ax12.c **** 	return AX12_instruction_queue_insert(&inst);
 315              		.loc 2 443 0
 316 0142 07F10803 		add	r3, r7, #8
 317 0146 1846     		mov	r0, r3
 318 0148 01F0C8F8 		bl	AX12_instruction_queue_insert
 319 014c 0346     		mov	r3, r0
 444:../QS/QS_ax12.c **** }
 320              		.loc 2 444 0
 321 014e 1846     		mov	r0, r3
 322 0150 07F11407 		add	r7, r7, #20
 323 0154 BD46     		mov	sp, r7
 324 0156 90BD     		pop	{r4, r7, pc}
 325              		.cfi_endproc
 326              	.LFE112:
 328              		.align	2
 329              		.thumb
 330              		.thumb_func
 332              	AX12_instruction_async_write16:
 333              	.LFB113:
 445:../QS/QS_ax12.c **** 
 446:../QS/QS_ax12.c **** static bool_e AX12_instruction_async_write16(Uint8 id_servo, Uint8 address, Uint16 value) {
 334              		.loc 2 446 0
 335              		.cfi_startproc
 336              		@ args = 0, pretend = 0, frame = 16
 337              		@ frame_needed = 1, uses_anonymous_args = 0
 338 0158 80B5     		push	{r7, lr}
 339              	.LCFI12:
 340              		.cfi_def_cfa_offset 8
 341              		.cfi_offset 7, -8
 342              		.cfi_offset 14, -4
 343 015a 84B0     		sub	sp, sp, #16
 344              	.LCFI13:
 345              		.cfi_def_cfa_offset 24
 346 015c 00AF     		add	r7, sp, #0
 347              	.LCFI14:
 348              		.cfi_def_cfa_register 7
 349 015e 1346     		mov	r3, r2
 350 0160 0246     		mov	r2, r0
 351 0162 FA71     		strb	r2, [r7, #7]
 352 0164 0A46     		mov	r2, r1
 353 0166 BA71     		strb	r2, [r7, #6]
 354 0168 BB80     		strh	r3, [r7, #4]	@ movhi
 447:../QS/QS_ax12.c **** 	AX12_instruction_packet_t inst = {0};
 355              		.loc 2 447 0
 356 016a 4FF00003 		mov	r3, #0
 357 016e BB60     		str	r3, [r7, #8]
 358 0170 4FF00003 		mov	r3, #0
 359 0174 FB60     		str	r3, [r7, #12]
 448:../QS/QS_ax12.c **** 
 449:../QS/QS_ax12.c **** 	if(value > AX12_decode_value_range(address, TRUE))
 360              		.loc 2 449 0
 361 0176 BB79     		ldrb	r3, [r7, #6]	@ zero_extendqisi2
 362 0178 1846     		mov	r0, r3
 363 017a 4FF00101 		mov	r1, #1
 364 017e 00F037FB 		bl	AX12_decode_value_range
 365 0182 0346     		mov	r3, r0
 366 0184 BA88     		ldrh	r2, [r7, #4]
 367 0186 9A42     		cmp	r2, r3
 368 0188 07D9     		bls	.L10
 450:../QS/QS_ax12.c **** 		value = AX12_decode_value_range(address, TRUE);
 369              		.loc 2 450 0
 370 018a BB79     		ldrb	r3, [r7, #6]	@ zero_extendqisi2
 371 018c 1846     		mov	r0, r3
 372 018e 4FF00101 		mov	r1, #1
 373 0192 00F02DFB 		bl	AX12_decode_value_range
 374 0196 0346     		mov	r3, r0
 375 0198 BB80     		strh	r3, [r7, #4]	@ movhi
 376              	.L10:
 451:../QS/QS_ax12.c **** 
 452:../QS/QS_ax12.c **** 	if(value < AX12_decode_value_range(address, FALSE))
 377              		.loc 2 452 0
 378 019a BB79     		ldrb	r3, [r7, #6]	@ zero_extendqisi2
 379 019c 1846     		mov	r0, r3
 380 019e 4FF00001 		mov	r1, #0
 381 01a2 00F025FB 		bl	AX12_decode_value_range
 382 01a6 0346     		mov	r3, r0
 383 01a8 BA88     		ldrh	r2, [r7, #4]
 384 01aa 9A42     		cmp	r2, r3
 385 01ac 07D2     		bcs	.L11
 453:../QS/QS_ax12.c **** 		value = AX12_decode_value_range(address, FALSE);
 386              		.loc 2 453 0
 387 01ae BB79     		ldrb	r3, [r7, #6]	@ zero_extendqisi2
 388 01b0 1846     		mov	r0, r3
 389 01b2 4FF00001 		mov	r1, #0
 390 01b6 00F01BFB 		bl	AX12_decode_value_range
 391 01ba 0346     		mov	r3, r0
 392 01bc BB80     		strh	r3, [r7, #4]	@ movhi
 393              	.L11:
 454:../QS/QS_ax12.c **** 
 455:../QS/QS_ax12.c **** 	inst.id_servo = id_servo;
 394              		.loc 2 455 0
 395 01be FB79     		ldrb	r3, [r7, #7]
 396 01c0 3B72     		strb	r3, [r7, #8]
 456:../QS/QS_ax12.c **** 	inst.type = INST_WRITE;
 397              		.loc 2 456 0
 398 01c2 4FF00303 		mov	r3, #3
 399 01c6 7B72     		strb	r3, [r7, #9]
 457:../QS/QS_ax12.c **** 	inst.address = address;
 400              		.loc 2 457 0
 401 01c8 BB79     		ldrb	r3, [r7, #6]
 402 01ca BB72     		strb	r3, [r7, #10]
 458:../QS/QS_ax12.c **** 	inst.param = value;
 403              		.loc 2 458 0
 404 01cc BB88     		ldrh	r3, [r7, #4]	@ movhi
 405 01ce BB81     		strh	r3, [r7, #12]	@ movhi
 459:../QS/QS_ax12.c **** 	inst.size = MIN_INSTRUCTION_PACKET_SIZE + 3;	//param is 16bits
 406              		.loc 2 459 0
 407 01d0 4FF00903 		mov	r3, #9
 408 01d4 BB73     		strb	r3, [r7, #14]
 460:../QS/QS_ax12.c **** 
 461:../QS/QS_ax12.c **** 	return AX12_instruction_queue_insert(&inst);
 409              		.loc 2 461 0
 410 01d6 07F10803 		add	r3, r7, #8
 411 01da 1846     		mov	r0, r3
 412 01dc 01F07EF8 		bl	AX12_instruction_queue_insert
 413 01e0 0346     		mov	r3, r0
 462:../QS/QS_ax12.c **** }
 414              		.loc 2 462 0
 415 01e2 1846     		mov	r0, r3
 416 01e4 07F11007 		add	r7, r7, #16
 417 01e8 BD46     		mov	sp, r7
 418 01ea 80BD     		pop	{r7, pc}
 419              		.cfi_endproc
 420              	.LFE113:
 422              		.align	2
 423              		.thumb
 424              		.thumb_func
 426              	AX12_instruction_async_prepare_write8:
 427              	.LFB114:
 463:../QS/QS_ax12.c **** 
 464:../QS/QS_ax12.c **** static bool_e AX12_instruction_async_prepare_write8(Uint8 id_servo, Uint8 address, Uint8 value) {
 428              		.loc 2 464 0
 429              		.cfi_startproc
 430              		@ args = 0, pretend = 0, frame = 16
 431              		@ frame_needed = 1, uses_anonymous_args = 0
 432 01ec 90B5     		push	{r4, r7, lr}
 433              	.LCFI15:
 434              		.cfi_def_cfa_offset 12
 435              		.cfi_offset 4, -12
 436              		.cfi_offset 7, -8
 437              		.cfi_offset 14, -4
 438 01ee 85B0     		sub	sp, sp, #20
 439              	.LCFI16:
 440              		.cfi_def_cfa_offset 32
 441 01f0 00AF     		add	r7, sp, #0
 442              	.LCFI17:
 443              		.cfi_def_cfa_register 7
 444 01f2 1346     		mov	r3, r2
 445 01f4 0246     		mov	r2, r0
 446 01f6 FA71     		strb	r2, [r7, #7]
 447 01f8 0A46     		mov	r2, r1
 448 01fa BA71     		strb	r2, [r7, #6]
 449 01fc 7B71     		strb	r3, [r7, #5]
 465:../QS/QS_ax12.c **** 	AX12_instruction_packet_t inst = {0};
 450              		.loc 2 465 0
 451 01fe 4FF00003 		mov	r3, #0
 452 0202 BB60     		str	r3, [r7, #8]
 453 0204 4FF00003 		mov	r3, #0
 454 0208 FB60     		str	r3, [r7, #12]
 466:../QS/QS_ax12.c **** 
 467:../QS/QS_ax12.c **** 	if((Uint16)value > AX12_decode_value_range(address, TRUE))
 455              		.loc 2 467 0
 456 020a 7B79     		ldrb	r3, [r7, #5]	@ zero_extendqisi2
 457 020c 9CB2     		uxth	r4, r3
 458 020e BB79     		ldrb	r3, [r7, #6]	@ zero_extendqisi2
 459 0210 1846     		mov	r0, r3
 460 0212 4FF00101 		mov	r1, #1
 461 0216 00F0EBFA 		bl	AX12_decode_value_range
 462 021a 0346     		mov	r3, r0
 463 021c 9C42     		cmp	r4, r3
 464 021e 07D9     		bls	.L14
 468:../QS/QS_ax12.c **** 		value = AX12_decode_value_range(address, TRUE);
 465              		.loc 2 468 0
 466 0220 BB79     		ldrb	r3, [r7, #6]	@ zero_extendqisi2
 467 0222 1846     		mov	r0, r3
 468 0224 4FF00101 		mov	r1, #1
 469 0228 00F0E2FA 		bl	AX12_decode_value_range
 470 022c 0346     		mov	r3, r0
 471 022e 7B71     		strb	r3, [r7, #5]
 472              	.L14:
 469:../QS/QS_ax12.c **** 
 470:../QS/QS_ax12.c **** 	if((Uint16)value < AX12_decode_value_range(address, FALSE))
 473              		.loc 2 470 0
 474 0230 7B79     		ldrb	r3, [r7, #5]	@ zero_extendqisi2
 475 0232 9CB2     		uxth	r4, r3
 476 0234 BB79     		ldrb	r3, [r7, #6]	@ zero_extendqisi2
 477 0236 1846     		mov	r0, r3
 478 0238 4FF00001 		mov	r1, #0
 479 023c 00F0D8FA 		bl	AX12_decode_value_range
 480 0240 0346     		mov	r3, r0
 481 0242 9C42     		cmp	r4, r3
 482 0244 07D2     		bcs	.L15
 471:../QS/QS_ax12.c **** 		value = AX12_decode_value_range(address, FALSE);
 483              		.loc 2 471 0
 484 0246 BB79     		ldrb	r3, [r7, #6]	@ zero_extendqisi2
 485 0248 1846     		mov	r0, r3
 486 024a 4FF00001 		mov	r1, #0
 487 024e 00F0CFFA 		bl	AX12_decode_value_range
 488 0252 0346     		mov	r3, r0
 489 0254 7B71     		strb	r3, [r7, #5]
 490              	.L15:
 472:../QS/QS_ax12.c **** 
 473:../QS/QS_ax12.c **** 	inst.id_servo = id_servo;
 491              		.loc 2 473 0
 492 0256 FB79     		ldrb	r3, [r7, #7]
 493 0258 3B72     		strb	r3, [r7, #8]
 474:../QS/QS_ax12.c **** 	inst.type = INST_REG_WRITE;
 494              		.loc 2 474 0
 495 025a 4FF00403 		mov	r3, #4
 496 025e 7B72     		strb	r3, [r7, #9]
 475:../QS/QS_ax12.c **** 	inst.address = address;
 497              		.loc 2 475 0
 498 0260 BB79     		ldrb	r3, [r7, #6]
 499 0262 BB72     		strb	r3, [r7, #10]
 476:../QS/QS_ax12.c **** 	inst.param_1 = value;
 500              		.loc 2 476 0
 501 0264 7B79     		ldrb	r3, [r7, #5]
 502 0266 3B73     		strb	r3, [r7, #12]
 477:../QS/QS_ax12.c **** 	inst.size = MIN_INSTRUCTION_PACKET_SIZE + 2;
 503              		.loc 2 477 0
 504 0268 4FF00803 		mov	r3, #8
 505 026c BB73     		strb	r3, [r7, #14]
 478:../QS/QS_ax12.c **** 
 479:../QS/QS_ax12.c **** 	return AX12_instruction_queue_insert(&inst);
 506              		.loc 2 479 0
 507 026e 07F10803 		add	r3, r7, #8
 508 0272 1846     		mov	r0, r3
 509 0274 01F032F8 		bl	AX12_instruction_queue_insert
 510 0278 0346     		mov	r3, r0
 480:../QS/QS_ax12.c **** }
 511              		.loc 2 480 0
 512 027a 1846     		mov	r0, r3
 513 027c 07F11407 		add	r7, r7, #20
 514 0280 BD46     		mov	sp, r7
 515 0282 90BD     		pop	{r4, r7, pc}
 516              		.cfi_endproc
 517              	.LFE114:
 519              		.align	2
 520              		.thumb
 521              		.thumb_func
 523              	AX12_instruction_async_prepare_write16:
 524              	.LFB115:
 481:../QS/QS_ax12.c **** 
 482:../QS/QS_ax12.c **** static bool_e AX12_instruction_async_prepare_write16(Uint8 id_servo, Uint8 address, Uint16 value) {
 525              		.loc 2 482 0
 526              		.cfi_startproc
 527              		@ args = 0, pretend = 0, frame = 16
 528              		@ frame_needed = 1, uses_anonymous_args = 0
 529 0284 80B5     		push	{r7, lr}
 530              	.LCFI18:
 531              		.cfi_def_cfa_offset 8
 532              		.cfi_offset 7, -8
 533              		.cfi_offset 14, -4
 534 0286 84B0     		sub	sp, sp, #16
 535              	.LCFI19:
 536              		.cfi_def_cfa_offset 24
 537 0288 00AF     		add	r7, sp, #0
 538              	.LCFI20:
 539              		.cfi_def_cfa_register 7
 540 028a 1346     		mov	r3, r2
 541 028c 0246     		mov	r2, r0
 542 028e FA71     		strb	r2, [r7, #7]
 543 0290 0A46     		mov	r2, r1
 544 0292 BA71     		strb	r2, [r7, #6]
 545 0294 BB80     		strh	r3, [r7, #4]	@ movhi
 483:../QS/QS_ax12.c **** 	AX12_instruction_packet_t inst = {0};
 546              		.loc 2 483 0
 547 0296 4FF00003 		mov	r3, #0
 548 029a BB60     		str	r3, [r7, #8]
 549 029c 4FF00003 		mov	r3, #0
 550 02a0 FB60     		str	r3, [r7, #12]
 484:../QS/QS_ax12.c **** 
 485:../QS/QS_ax12.c **** 	if(value > AX12_decode_value_range(address, TRUE))
 551              		.loc 2 485 0
 552 02a2 BB79     		ldrb	r3, [r7, #6]	@ zero_extendqisi2
 553 02a4 1846     		mov	r0, r3
 554 02a6 4FF00101 		mov	r1, #1
 555 02aa 00F0A1FA 		bl	AX12_decode_value_range
 556 02ae 0346     		mov	r3, r0
 557 02b0 BA88     		ldrh	r2, [r7, #4]
 558 02b2 9A42     		cmp	r2, r3
 559 02b4 07D9     		bls	.L18
 486:../QS/QS_ax12.c **** 		value = AX12_decode_value_range(address, TRUE);
 560              		.loc 2 486 0
 561 02b6 BB79     		ldrb	r3, [r7, #6]	@ zero_extendqisi2
 562 02b8 1846     		mov	r0, r3
 563 02ba 4FF00101 		mov	r1, #1
 564 02be 00F097FA 		bl	AX12_decode_value_range
 565 02c2 0346     		mov	r3, r0
 566 02c4 BB80     		strh	r3, [r7, #4]	@ movhi
 567              	.L18:
 487:../QS/QS_ax12.c **** 
 488:../QS/QS_ax12.c **** 	if(value < AX12_decode_value_range(address, FALSE))
 568              		.loc 2 488 0
 569 02c6 BB79     		ldrb	r3, [r7, #6]	@ zero_extendqisi2
 570 02c8 1846     		mov	r0, r3
 571 02ca 4FF00001 		mov	r1, #0
 572 02ce 00F08FFA 		bl	AX12_decode_value_range
 573 02d2 0346     		mov	r3, r0
 574 02d4 BA88     		ldrh	r2, [r7, #4]
 575 02d6 9A42     		cmp	r2, r3
 576 02d8 07D2     		bcs	.L19
 489:../QS/QS_ax12.c **** 		value = AX12_decode_value_range(address, FALSE);
 577              		.loc 2 489 0
 578 02da BB79     		ldrb	r3, [r7, #6]	@ zero_extendqisi2
 579 02dc 1846     		mov	r0, r3
 580 02de 4FF00001 		mov	r1, #0
 581 02e2 00F085FA 		bl	AX12_decode_value_range
 582 02e6 0346     		mov	r3, r0
 583 02e8 BB80     		strh	r3, [r7, #4]	@ movhi
 584              	.L19:
 490:../QS/QS_ax12.c **** 
 491:../QS/QS_ax12.c **** 	inst.id_servo = id_servo;
 585              		.loc 2 491 0
 586 02ea FB79     		ldrb	r3, [r7, #7]
 587 02ec 3B72     		strb	r3, [r7, #8]
 492:../QS/QS_ax12.c **** 	inst.type = INST_REG_WRITE;
 588              		.loc 2 492 0
 589 02ee 4FF00403 		mov	r3, #4
 590 02f2 7B72     		strb	r3, [r7, #9]
 493:../QS/QS_ax12.c **** 	inst.address = address;
 591              		.loc 2 493 0
 592 02f4 BB79     		ldrb	r3, [r7, #6]
 593 02f6 BB72     		strb	r3, [r7, #10]
 494:../QS/QS_ax12.c **** 	inst.param = value;
 594              		.loc 2 494 0
 595 02f8 BB88     		ldrh	r3, [r7, #4]	@ movhi
 596 02fa BB81     		strh	r3, [r7, #12]	@ movhi
 495:../QS/QS_ax12.c **** 	inst.size = MIN_INSTRUCTION_PACKET_SIZE + 3;	//param is 16bits
 597              		.loc 2 495 0
 598 02fc 4FF00903 		mov	r3, #9
 599 0300 BB73     		strb	r3, [r7, #14]
 496:../QS/QS_ax12.c **** 
 497:../QS/QS_ax12.c **** 	return AX12_instruction_queue_insert(&inst);
 600              		.loc 2 497 0
 601 0302 07F10803 		add	r3, r7, #8
 602 0306 1846     		mov	r0, r3
 603 0308 00F0E8FF 		bl	AX12_instruction_queue_insert
 604 030c 0346     		mov	r3, r0
 498:../QS/QS_ax12.c **** }
 605              		.loc 2 498 0
 606 030e 1846     		mov	r0, r3
 607 0310 07F11007 		add	r7, r7, #16
 608 0314 BD46     		mov	sp, r7
 609 0316 80BD     		pop	{r7, pc}
 610              		.cfi_endproc
 611              	.LFE115:
 613              		.align	2
 614              		.thumb
 615              		.thumb_func
 617              	AX12_instruction_async_execute_write:
 618              	.LFB116:
 499:../QS/QS_ax12.c **** 
 500:../QS/QS_ax12.c **** static bool_e AX12_instruction_async_execute_write() {
 619              		.loc 2 500 0
 620              		.cfi_startproc
 621              		@ args = 0, pretend = 0, frame = 8
 622              		@ frame_needed = 1, uses_anonymous_args = 0
 623 0318 80B5     		push	{r7, lr}
 624              	.LCFI21:
 625              		.cfi_def_cfa_offset 8
 626              		.cfi_offset 7, -8
 627              		.cfi_offset 14, -4
 628 031a 82B0     		sub	sp, sp, #8
 629              	.LCFI22:
 630              		.cfi_def_cfa_offset 16
 631 031c 00AF     		add	r7, sp, #0
 632              	.LCFI23:
 633              		.cfi_def_cfa_register 7
 501:../QS/QS_ax12.c **** 	AX12_instruction_packet_t inst = {0};
 634              		.loc 2 501 0
 635 031e 4FF00003 		mov	r3, #0
 636 0322 3B60     		str	r3, [r7, #0]
 637 0324 4FF00003 		mov	r3, #0
 638 0328 7B60     		str	r3, [r7, #4]
 502:../QS/QS_ax12.c **** 
 503:../QS/QS_ax12.c **** 	inst.id_servo = AX12_BROADCAST_ID;
 639              		.loc 2 503 0
 640 032a 4FF0FE03 		mov	r3, #254
 641 032e 3B70     		strb	r3, [r7, #0]
 504:../QS/QS_ax12.c **** 	inst.type = INST_ACTION;
 642              		.loc 2 504 0
 643 0330 4FF00503 		mov	r3, #5
 644 0334 7B70     		strb	r3, [r7, #1]
 505:../QS/QS_ax12.c **** 	inst.size = MIN_INSTRUCTION_PACKET_SIZE;
 645              		.loc 2 505 0
 646 0336 4FF00603 		mov	r3, #6
 647 033a BB71     		strb	r3, [r7, #6]
 506:../QS/QS_ax12.c **** 
 507:../QS/QS_ax12.c **** 	return AX12_instruction_queue_insert(&inst);
 648              		.loc 2 507 0
 649 033c 3B46     		mov	r3, r7
 650 033e 1846     		mov	r0, r3
 651 0340 00F0CCFF 		bl	AX12_instruction_queue_insert
 652 0344 0346     		mov	r3, r0
 508:../QS/QS_ax12.c **** }
 653              		.loc 2 508 0
 654 0346 1846     		mov	r0, r3
 655 0348 07F10807 		add	r7, r7, #8
 656 034c BD46     		mov	sp, r7
 657 034e 80BD     		pop	{r7, pc}
 658              		.cfi_endproc
 659              	.LFE116:
 661              		.align	2
 662              		.thumb
 663              		.thumb_func
 665              	AX12_instruction_read8:
 666              	.LFB117:
 509:../QS/QS_ax12.c **** 
 510:../QS/QS_ax12.c **** #if AX12_STATUS_RETURN_MODE != AX12_STATUS_RETURN_NEVER
 511:../QS/QS_ax12.c **** static Uint8 AX12_instruction_read8(Uint8 id_servo, Uint8 address, bool_e *isOk) {
 667              		.loc 2 511 0
 668              		.cfi_startproc
 669              		@ args = 0, pretend = 0, frame = 24
 670              		@ frame_needed = 1, uses_anonymous_args = 0
 671 0350 80B5     		push	{r7, lr}
 672              	.LCFI24:
 673              		.cfi_def_cfa_offset 8
 674              		.cfi_offset 7, -8
 675              		.cfi_offset 14, -4
 676 0352 86B0     		sub	sp, sp, #24
 677              	.LCFI25:
 678              		.cfi_def_cfa_offset 32
 679 0354 00AF     		add	r7, sp, #0
 680              	.LCFI26:
 681              		.cfi_def_cfa_register 7
 682 0356 0B46     		mov	r3, r1
 683 0358 BA60     		str	r2, [r7, #8]
 684 035a 0246     		mov	r2, r0
 685 035c FA73     		strb	r2, [r7, #15]
 686 035e BB73     		strb	r3, [r7, #14]
 512:../QS/QS_ax12.c **** 	if(!AX12_instruction_async_read(id_servo, address, 1)) {
 687              		.loc 2 512 0
 688 0360 FA7B     		ldrb	r2, [r7, #15]	@ zero_extendqisi2
 689 0362 BB7B     		ldrb	r3, [r7, #14]	@ zero_extendqisi2
 690 0364 1046     		mov	r0, r2
 691 0366 1946     		mov	r1, r3
 692 0368 4FF00102 		mov	r2, #1
 693 036c FFF782FE 		bl	AX12_instruction_async_read
 694 0370 0346     		mov	r3, r0
 695 0372 002B     		cmp	r3, #0
 696 0374 09D1     		bne	.L24
 513:../QS/QS_ax12.c **** 		if(isOk) *isOk = FALSE;
 697              		.loc 2 513 0
 698 0376 BB68     		ldr	r3, [r7, #8]
 699 0378 002B     		cmp	r3, #0
 700 037a 03D0     		beq	.L25
 701              		.loc 2 513 0 is_stmt 0 discriminator 1
 702 037c BB68     		ldr	r3, [r7, #8]
 703 037e 4FF00002 		mov	r2, #0
 704 0382 1A70     		strb	r2, [r3, #0]
 705              	.L25:
 514:../QS/QS_ax12.c **** 		return 0;
 706              		.loc 2 514 0 is_stmt 1
 707 0384 4FF00003 		mov	r3, #0
 708 0388 22E0     		b	.L26
 709              	.L24:
 515:../QS/QS_ax12.c **** 	}
 516:../QS/QS_ax12.c **** 
 517:../QS/QS_ax12.c **** 	if(!AX12_instruction_wait(id_servo)) {
 710              		.loc 2 517 0
 711 038a FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 712 038c 1846     		mov	r0, r3
 713 038e 00F079F9 		bl	AX12_instruction_wait
 714 0392 0346     		mov	r3, r0
 715 0394 002B     		cmp	r3, #0
 716 0396 09D1     		bne	.L27
 518:../QS/QS_ax12.c **** 		if(isOk) *isOk = FALSE;
 717              		.loc 2 518 0
 718 0398 BB68     		ldr	r3, [r7, #8]
 719 039a 002B     		cmp	r3, #0
 720 039c 03D0     		beq	.L28
 721              		.loc 2 518 0 is_stmt 0 discriminator 1
 722 039e BB68     		ldr	r3, [r7, #8]
 723 03a0 4FF00002 		mov	r2, #0
 724 03a4 1A70     		strb	r2, [r3, #0]
 725              	.L28:
 519:../QS/QS_ax12.c **** 		return 0;
 726              		.loc 2 519 0 is_stmt 1
 727 03a6 4FF00003 		mov	r3, #0
 728 03aa 11E0     		b	.L26
 729              	.L27:
 520:../QS/QS_ax12.c **** 	}
 521:../QS/QS_ax12.c **** 
 522:../QS/QS_ax12.c **** 	if(isOk) *isOk = TRUE;
 730              		.loc 2 522 0
 731 03ac BB68     		ldr	r3, [r7, #8]
 732 03ae 002B     		cmp	r3, #0
 733 03b0 03D0     		beq	.L29
 734              		.loc 2 522 0 is_stmt 0 discriminator 1
 735 03b2 BB68     		ldr	r3, [r7, #8]
 736 03b4 4FF00102 		mov	r2, #1
 737 03b8 1A70     		strb	r2, [r3, #0]
 738              	.L29:
 523:../QS/QS_ax12.c **** 	return AX12_instruction_get_last_status(id_servo).param_1;
 739              		.loc 2 523 0 is_stmt 1
 740 03ba FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 741 03bc 1846     		mov	r0, r3
 742 03be 00F0CBF9 		bl	AX12_instruction_get_last_status
 743 03c2 3880     		strh	r0, [r7, #0]	@ movhi
 744 03c4 C0F30F43 		ubfx	r3, r0, #16, #16
 745 03c8 7B80     		strh	r3, [r7, #2]	@ movhi
 746 03ca 3B68     		ldr	r3, [r7, #0]
 747 03cc 7B61     		str	r3, [r7, #20]
 748 03ce BB7D     		ldrb	r3, [r7, #22]	@ zero_extendqisi2
 749              	.L26:
 524:../QS/QS_ax12.c **** }
 750              		.loc 2 524 0
 751 03d0 1846     		mov	r0, r3
 752 03d2 07F11807 		add	r7, r7, #24
 753 03d6 BD46     		mov	sp, r7
 754 03d8 80BD     		pop	{r7, pc}
 755              		.cfi_endproc
 756              	.LFE117:
 758 03da 00BF     		.align	2
 759              		.thumb
 760              		.thumb_func
 762              	AX12_instruction_read16:
 763              	.LFB118:
 525:../QS/QS_ax12.c **** 
 526:../QS/QS_ax12.c **** static Uint16 AX12_instruction_read16(Uint8 id_servo, Uint8 address, bool_e *isOk) {
 764              		.loc 2 526 0
 765              		.cfi_startproc
 766              		@ args = 0, pretend = 0, frame = 24
 767              		@ frame_needed = 1, uses_anonymous_args = 0
 768 03dc 80B5     		push	{r7, lr}
 769              	.LCFI27:
 770              		.cfi_def_cfa_offset 8
 771              		.cfi_offset 7, -8
 772              		.cfi_offset 14, -4
 773 03de 86B0     		sub	sp, sp, #24
 774              	.LCFI28:
 775              		.cfi_def_cfa_offset 32
 776 03e0 00AF     		add	r7, sp, #0
 777              	.LCFI29:
 778              		.cfi_def_cfa_register 7
 779 03e2 0B46     		mov	r3, r1
 780 03e4 BA60     		str	r2, [r7, #8]
 781 03e6 0246     		mov	r2, r0
 782 03e8 FA73     		strb	r2, [r7, #15]
 783 03ea BB73     		strb	r3, [r7, #14]
 527:../QS/QS_ax12.c **** 	if(!AX12_instruction_async_read(id_servo, address, 2)) {
 784              		.loc 2 527 0
 785 03ec FA7B     		ldrb	r2, [r7, #15]	@ zero_extendqisi2
 786 03ee BB7B     		ldrb	r3, [r7, #14]	@ zero_extendqisi2
 787 03f0 1046     		mov	r0, r2
 788 03f2 1946     		mov	r1, r3
 789 03f4 4FF00202 		mov	r2, #2
 790 03f8 FFF73CFE 		bl	AX12_instruction_async_read
 791 03fc 0346     		mov	r3, r0
 792 03fe 002B     		cmp	r3, #0
 793 0400 09D1     		bne	.L31
 528:../QS/QS_ax12.c **** 		if(isOk) *isOk = FALSE;
 794              		.loc 2 528 0
 795 0402 BB68     		ldr	r3, [r7, #8]
 796 0404 002B     		cmp	r3, #0
 797 0406 03D0     		beq	.L32
 798              		.loc 2 528 0 is_stmt 0 discriminator 1
 799 0408 BB68     		ldr	r3, [r7, #8]
 800 040a 4FF00002 		mov	r2, #0
 801 040e 1A70     		strb	r2, [r3, #0]
 802              	.L32:
 529:../QS/QS_ax12.c **** 		return 0;
 803              		.loc 2 529 0 is_stmt 1
 804 0410 4FF00003 		mov	r3, #0
 805 0414 22E0     		b	.L33
 806              	.L31:
 530:../QS/QS_ax12.c **** 	}
 531:../QS/QS_ax12.c **** 
 532:../QS/QS_ax12.c **** 	if(!AX12_instruction_wait(id_servo)) {
 807              		.loc 2 532 0
 808 0416 FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 809 0418 1846     		mov	r0, r3
 810 041a 00F033F9 		bl	AX12_instruction_wait
 811 041e 0346     		mov	r3, r0
 812 0420 002B     		cmp	r3, #0
 813 0422 09D1     		bne	.L34
 533:../QS/QS_ax12.c **** 		if(isOk) *isOk = FALSE;
 814              		.loc 2 533 0
 815 0424 BB68     		ldr	r3, [r7, #8]
 816 0426 002B     		cmp	r3, #0
 817 0428 03D0     		beq	.L35
 818              		.loc 2 533 0 is_stmt 0 discriminator 1
 819 042a BB68     		ldr	r3, [r7, #8]
 820 042c 4FF00002 		mov	r2, #0
 821 0430 1A70     		strb	r2, [r3, #0]
 822              	.L35:
 534:../QS/QS_ax12.c **** 		return 0;
 823              		.loc 2 534 0 is_stmt 1
 824 0432 4FF00003 		mov	r3, #0
 825 0436 11E0     		b	.L33
 826              	.L34:
 535:../QS/QS_ax12.c **** 	}
 536:../QS/QS_ax12.c **** 
 537:../QS/QS_ax12.c **** 	if(isOk) *isOk = TRUE;
 827              		.loc 2 537 0
 828 0438 BB68     		ldr	r3, [r7, #8]
 829 043a 002B     		cmp	r3, #0
 830 043c 03D0     		beq	.L36
 831              		.loc 2 537 0 is_stmt 0 discriminator 1
 832 043e BB68     		ldr	r3, [r7, #8]
 833 0440 4FF00102 		mov	r2, #1
 834 0444 1A70     		strb	r2, [r3, #0]
 835              	.L36:
 538:../QS/QS_ax12.c **** 	return AX12_instruction_get_last_status(id_servo).param;
 836              		.loc 2 538 0 is_stmt 1
 837 0446 FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 838 0448 1846     		mov	r0, r3
 839 044a 00F085F9 		bl	AX12_instruction_get_last_status
 840 044e 3880     		strh	r0, [r7, #0]	@ movhi
 841 0450 C0F30F43 		ubfx	r3, r0, #16, #16
 842 0454 7B80     		strh	r3, [r7, #2]	@ movhi
 843 0456 3B68     		ldr	r3, [r7, #0]
 844 0458 7B61     		str	r3, [r7, #20]
 845 045a FB8A     		ldrh	r3, [r7, #22]
 846              	.L33:
 539:../QS/QS_ax12.c **** }
 847              		.loc 2 539 0
 848 045c 1846     		mov	r0, r3
 849 045e 07F11807 		add	r7, r7, #24
 850 0462 BD46     		mov	sp, r7
 851 0464 80BD     		pop	{r7, pc}
 852              		.cfi_endproc
 853              	.LFE118:
 855 0466 00BF     		.align	2
 856              		.thumb
 857              		.thumb_func
 859              	AX12_instruction_write8:
 860              	.LFB119:
 540:../QS/QS_ax12.c **** #endif
 541:../QS/QS_ax12.c **** 
 542:../QS/QS_ax12.c **** static bool_e AX12_instruction_write8(Uint8 id_servo, Uint8 address, Uint8 value) {
 861              		.loc 2 542 0
 862              		.cfi_startproc
 863              		@ args = 0, pretend = 0, frame = 24
 864              		@ frame_needed = 1, uses_anonymous_args = 0
 865 0468 80B5     		push	{r7, lr}
 866              	.LCFI30:
 867              		.cfi_def_cfa_offset 8
 868              		.cfi_offset 7, -8
 869              		.cfi_offset 14, -4
 870 046a 86B0     		sub	sp, sp, #24
 871              	.LCFI31:
 872              		.cfi_def_cfa_offset 32
 873 046c 00AF     		add	r7, sp, #0
 874              	.LCFI32:
 875              		.cfi_def_cfa_register 7
 876 046e 1346     		mov	r3, r2
 877 0470 0246     		mov	r2, r0
 878 0472 FA73     		strb	r2, [r7, #15]
 879 0474 0A46     		mov	r2, r1
 880 0476 BA73     		strb	r2, [r7, #14]
 881 0478 7B73     		strb	r3, [r7, #13]
 543:../QS/QS_ax12.c **** 	if(AX12_prepare_commands) {
 882              		.loc 2 543 0
 883 047a 40F20003 		movw	r3, #:lower16:AX12_prepare_commands
 884 047e C0F20003 		movt	r3, #:upper16:AX12_prepare_commands
 885 0482 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 886 0484 002B     		cmp	r3, #0
 887 0486 0DD0     		beq	.L38
 544:../QS/QS_ax12.c **** 		if(!AX12_instruction_async_prepare_write8(id_servo, address, value))
 888              		.loc 2 544 0
 889 0488 F97B     		ldrb	r1, [r7, #15]	@ zero_extendqisi2
 890 048a BA7B     		ldrb	r2, [r7, #14]	@ zero_extendqisi2
 891 048c 7B7B     		ldrb	r3, [r7, #13]	@ zero_extendqisi2
 892 048e 0846     		mov	r0, r1
 893 0490 1146     		mov	r1, r2
 894 0492 1A46     		mov	r2, r3
 895 0494 FFF7AAFE 		bl	AX12_instruction_async_prepare_write8
 896 0498 0346     		mov	r3, r0
 897 049a 002B     		cmp	r3, #0
 898 049c 10D1     		bne	.L39
 545:../QS/QS_ax12.c **** 			return FALSE;
 899              		.loc 2 545 0
 900 049e 4FF00003 		mov	r3, #0
 901 04a2 2DE0     		b	.L40
 902              	.L38:
 546:../QS/QS_ax12.c **** 	} else {
 547:../QS/QS_ax12.c **** 		if(!AX12_instruction_async_write8(id_servo, address, value))
 903              		.loc 2 547 0
 904 04a4 F97B     		ldrb	r1, [r7, #15]	@ zero_extendqisi2
 905 04a6 BA7B     		ldrb	r2, [r7, #14]	@ zero_extendqisi2
 906 04a8 7B7B     		ldrb	r3, [r7, #13]	@ zero_extendqisi2
 907 04aa 0846     		mov	r0, r1
 908 04ac 1146     		mov	r1, r2
 909 04ae 1A46     		mov	r2, r3
 910 04b0 FFF706FE 		bl	AX12_instruction_async_write8
 911 04b4 0346     		mov	r3, r0
 912 04b6 002B     		cmp	r3, #0
 913 04b8 02D1     		bne	.L39
 548:../QS/QS_ax12.c **** 			return FALSE;
 914              		.loc 2 548 0
 915 04ba 4FF00003 		mov	r3, #0
 916 04be 1FE0     		b	.L40
 917              	.L39:
 549:../QS/QS_ax12.c **** 	}
 550:../QS/QS_ax12.c **** 
 551:../QS/QS_ax12.c **** 	#if AX12_STATUS_RETURN_MODE == AX12_STATUS_RETURN_ALWAYS
 552:../QS/QS_ax12.c **** 		if(id_servo == AX12_BROADCAST_ID)
 918              		.loc 2 552 0
 919 04c0 FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 920 04c2 FE2B     		cmp	r3, #254
 921 04c4 02D1     		bne	.L41
 553:../QS/QS_ax12.c **** 			return TRUE;
 922              		.loc 2 553 0
 923 04c6 4FF00103 		mov	r3, #1
 924 04ca 19E0     		b	.L40
 925              	.L41:
 554:../QS/QS_ax12.c **** 		if(!AX12_instruction_wait(id_servo))
 926              		.loc 2 554 0
 927 04cc FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 928 04ce 1846     		mov	r0, r3
 929 04d0 00F0D8F8 		bl	AX12_instruction_wait
 930 04d4 0346     		mov	r3, r0
 931 04d6 002B     		cmp	r3, #0
 932 04d8 02D1     		bne	.L42
 555:../QS/QS_ax12.c **** 			return FALSE;
 933              		.loc 2 555 0
 934 04da 4FF00003 		mov	r3, #0
 935 04de 0FE0     		b	.L40
 936              	.L42:
 556:../QS/QS_ax12.c **** 		return AX12_instruction_get_last_status(id_servo).error == 0;
 937              		.loc 2 556 0
 938 04e0 FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 939 04e2 1846     		mov	r0, r3
 940 04e4 00F038F9 		bl	AX12_instruction_get_last_status
 941 04e8 3880     		strh	r0, [r7, #0]	@ movhi
 942 04ea C0F30F43 		ubfx	r3, r0, #16, #16
 943 04ee 7B80     		strh	r3, [r7, #2]	@ movhi
 944 04f0 3B68     		ldr	r3, [r7, #0]
 945 04f2 7B61     		str	r3, [r7, #20]
 946 04f4 3B7D     		ldrb	r3, [r7, #20]	@ zero_extendqisi2
 947 04f6 002B     		cmp	r3, #0
 948 04f8 14BF     		ite	ne
 949 04fa 0023     		movne	r3, #0
 950 04fc 0123     		moveq	r3, #1
 951 04fe DBB2     		uxtb	r3, r3
 952              	.L40:
 557:../QS/QS_ax12.c **** 	#endif
 558:../QS/QS_ax12.c **** 
 559:../QS/QS_ax12.c **** 	return TRUE;
 560:../QS/QS_ax12.c **** }
 953              		.loc 2 560 0
 954 0500 1846     		mov	r0, r3
 955 0502 07F11807 		add	r7, r7, #24
 956 0506 BD46     		mov	sp, r7
 957 0508 80BD     		pop	{r7, pc}
 958              		.cfi_endproc
 959              	.LFE119:
 961 050a 00BF     		.align	2
 962              		.thumb
 963              		.thumb_func
 965              	AX12_instruction_write16:
 966              	.LFB120:
 561:../QS/QS_ax12.c **** 
 562:../QS/QS_ax12.c **** static bool_e AX12_instruction_write16(Uint8 id_servo, Uint8 address, Uint16 value) {
 967              		.loc 2 562 0
 968              		.cfi_startproc
 969              		@ args = 0, pretend = 0, frame = 24
 970              		@ frame_needed = 1, uses_anonymous_args = 0
 971 050c 80B5     		push	{r7, lr}
 972              	.LCFI33:
 973              		.cfi_def_cfa_offset 8
 974              		.cfi_offset 7, -8
 975              		.cfi_offset 14, -4
 976 050e 86B0     		sub	sp, sp, #24
 977              	.LCFI34:
 978              		.cfi_def_cfa_offset 32
 979 0510 00AF     		add	r7, sp, #0
 980              	.LCFI35:
 981              		.cfi_def_cfa_register 7
 982 0512 1346     		mov	r3, r2
 983 0514 0246     		mov	r2, r0
 984 0516 FA73     		strb	r2, [r7, #15]
 985 0518 0A46     		mov	r2, r1
 986 051a BA73     		strb	r2, [r7, #14]
 987 051c BB81     		strh	r3, [r7, #12]	@ movhi
 563:../QS/QS_ax12.c **** 	if(AX12_prepare_commands) {
 988              		.loc 2 563 0
 989 051e 40F20003 		movw	r3, #:lower16:AX12_prepare_commands
 990 0522 C0F20003 		movt	r3, #:upper16:AX12_prepare_commands
 991 0526 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 992 0528 002B     		cmp	r3, #0
 993 052a 0DD0     		beq	.L44
 564:../QS/QS_ax12.c **** 		if(!AX12_instruction_async_prepare_write16(id_servo, address, value))
 994              		.loc 2 564 0
 995 052c F97B     		ldrb	r1, [r7, #15]	@ zero_extendqisi2
 996 052e BA7B     		ldrb	r2, [r7, #14]	@ zero_extendqisi2
 997 0530 BB89     		ldrh	r3, [r7, #12]
 998 0532 0846     		mov	r0, r1
 999 0534 1146     		mov	r1, r2
 1000 0536 1A46     		mov	r2, r3
 1001 0538 FFF7A4FE 		bl	AX12_instruction_async_prepare_write16
 1002 053c 0346     		mov	r3, r0
 1003 053e 002B     		cmp	r3, #0
 1004 0540 10D1     		bne	.L45
 565:../QS/QS_ax12.c **** 			return FALSE;
 1005              		.loc 2 565 0
 1006 0542 4FF00003 		mov	r3, #0
 1007 0546 2DE0     		b	.L46
 1008              	.L44:
 566:../QS/QS_ax12.c **** 	} else {
 567:../QS/QS_ax12.c **** 		if(!AX12_instruction_async_write16(id_servo, address, value))
 1009              		.loc 2 567 0
 1010 0548 F97B     		ldrb	r1, [r7, #15]	@ zero_extendqisi2
 1011 054a BA7B     		ldrb	r2, [r7, #14]	@ zero_extendqisi2
 1012 054c BB89     		ldrh	r3, [r7, #12]
 1013 054e 0846     		mov	r0, r1
 1014 0550 1146     		mov	r1, r2
 1015 0552 1A46     		mov	r2, r3
 1016 0554 FFF700FE 		bl	AX12_instruction_async_write16
 1017 0558 0346     		mov	r3, r0
 1018 055a 002B     		cmp	r3, #0
 1019 055c 02D1     		bne	.L45
 568:../QS/QS_ax12.c **** 			return FALSE;
 1020              		.loc 2 568 0
 1021 055e 4FF00003 		mov	r3, #0
 1022 0562 1FE0     		b	.L46
 1023              	.L45:
 569:../QS/QS_ax12.c **** 	}
 570:../QS/QS_ax12.c **** 
 571:../QS/QS_ax12.c **** 	#if AX12_STATUS_RETURN_MODE == AX12_STATUS_RETURN_ALWAYS
 572:../QS/QS_ax12.c **** 		if(id_servo == AX12_BROADCAST_ID)
 1024              		.loc 2 572 0
 1025 0564 FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 1026 0566 FE2B     		cmp	r3, #254
 1027 0568 02D1     		bne	.L47
 573:../QS/QS_ax12.c **** 			return TRUE;
 1028              		.loc 2 573 0
 1029 056a 4FF00103 		mov	r3, #1
 1030 056e 19E0     		b	.L46
 1031              	.L47:
 574:../QS/QS_ax12.c **** 		if(!AX12_instruction_wait(id_servo))
 1032              		.loc 2 574 0
 1033 0570 FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 1034 0572 1846     		mov	r0, r3
 1035 0574 00F086F8 		bl	AX12_instruction_wait
 1036 0578 0346     		mov	r3, r0
 1037 057a 002B     		cmp	r3, #0
 1038 057c 02D1     		bne	.L48
 575:../QS/QS_ax12.c **** 			return FALSE;
 1039              		.loc 2 575 0
 1040 057e 4FF00003 		mov	r3, #0
 1041 0582 0FE0     		b	.L46
 1042              	.L48:
 576:../QS/QS_ax12.c **** 		return AX12_instruction_get_last_status(id_servo).error == 0;
 1043              		.loc 2 576 0
 1044 0584 FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 1045 0586 1846     		mov	r0, r3
 1046 0588 00F0E6F8 		bl	AX12_instruction_get_last_status
 1047 058c 3880     		strh	r0, [r7, #0]	@ movhi
 1048 058e C0F30F43 		ubfx	r3, r0, #16, #16
 1049 0592 7B80     		strh	r3, [r7, #2]	@ movhi
 1050 0594 3B68     		ldr	r3, [r7, #0]
 1051 0596 7B61     		str	r3, [r7, #20]
 1052 0598 3B7D     		ldrb	r3, [r7, #20]	@ zero_extendqisi2
 1053 059a 002B     		cmp	r3, #0
 1054 059c 14BF     		ite	ne
 1055 059e 0023     		movne	r3, #0
 1056 05a0 0123     		moveq	r3, #1
 1057 05a2 DBB2     		uxtb	r3, r3
 1058              	.L46:
 577:../QS/QS_ax12.c **** 	#endif
 578:../QS/QS_ax12.c **** 
 579:../QS/QS_ax12.c **** 	return TRUE;
 580:../QS/QS_ax12.c **** }
 1059              		.loc 2 580 0
 1060 05a4 1846     		mov	r0, r3
 1061 05a6 07F11807 		add	r7, r7, #24
 1062 05aa BD46     		mov	sp, r7
 1063 05ac 80BD     		pop	{r7, pc}
 1064              		.cfi_endproc
 1065              	.LFE120:
 1067 05ae 00BF     		.align	2
 1068              		.thumb
 1069              		.thumb_func
 1071              	AX12_instruction_ping:
 1072              	.LFB121:
 581:../QS/QS_ax12.c **** 
 582:../QS/QS_ax12.c **** static bool_e AX12_instruction_ping(Uint8 id_servo) {
 1073              		.loc 2 582 0
 1074              		.cfi_startproc
 1075              		@ args = 0, pretend = 0, frame = 32
 1076              		@ frame_needed = 1, uses_anonymous_args = 0
 1077 05b0 80B5     		push	{r7, lr}
 1078              	.LCFI36:
 1079              		.cfi_def_cfa_offset 8
 1080              		.cfi_offset 7, -8
 1081              		.cfi_offset 14, -4
 1082 05b2 88B0     		sub	sp, sp, #32
 1083              	.LCFI37:
 1084              		.cfi_def_cfa_offset 40
 1085 05b4 00AF     		add	r7, sp, #0
 1086              	.LCFI38:
 1087              		.cfi_def_cfa_register 7
 1088 05b6 0346     		mov	r3, r0
 1089 05b8 FB73     		strb	r3, [r7, #15]
 583:../QS/QS_ax12.c **** 	AX12_instruction_packet_t inst = {0};
 1090              		.loc 2 583 0
 1091 05ba 4FF00003 		mov	r3, #0
 1092 05be 7B61     		str	r3, [r7, #20]
 1093 05c0 4FF00003 		mov	r3, #0
 1094 05c4 BB61     		str	r3, [r7, #24]
 584:../QS/QS_ax12.c **** 
 585:../QS/QS_ax12.c **** 	inst.id_servo = id_servo;
 1095              		.loc 2 585 0
 1096 05c6 FB7B     		ldrb	r3, [r7, #15]
 1097 05c8 3B75     		strb	r3, [r7, #20]
 586:../QS/QS_ax12.c **** 	inst.type = INST_PING;
 1098              		.loc 2 586 0
 1099 05ca 4FF00103 		mov	r3, #1
 1100 05ce 7B75     		strb	r3, [r7, #21]
 587:../QS/QS_ax12.c **** 	inst.size = MIN_INSTRUCTION_PACKET_SIZE;
 1101              		.loc 2 587 0
 1102 05d0 4FF00603 		mov	r3, #6
 1103 05d4 BB76     		strb	r3, [r7, #26]
 588:../QS/QS_ax12.c **** 
 589:../QS/QS_ax12.c **** 	if(!AX12_instruction_queue_insert(&inst))
 1104              		.loc 2 589 0
 1105 05d6 07F11403 		add	r3, r7, #20
 1106 05da 1846     		mov	r0, r3
 1107 05dc 00F07EFE 		bl	AX12_instruction_queue_insert
 1108 05e0 0346     		mov	r3, r0
 1109 05e2 002B     		cmp	r3, #0
 1110 05e4 02D1     		bne	.L50
 590:../QS/QS_ax12.c **** 		return FALSE;
 1111              		.loc 2 590 0
 1112 05e6 4FF00003 		mov	r3, #0
 1113 05ea 1BE0     		b	.L53
 1114              	.L50:
 591:../QS/QS_ax12.c **** 
 592:../QS/QS_ax12.c **** 	if(!AX12_instruction_wait(id_servo))
 1115              		.loc 2 592 0
 1116 05ec FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 1117 05ee 1846     		mov	r0, r3
 1118 05f0 00F048F8 		bl	AX12_instruction_wait
 1119 05f4 0346     		mov	r3, r0
 1120 05f6 002B     		cmp	r3, #0
 1121 05f8 02D1     		bne	.L52
 593:../QS/QS_ax12.c **** 		return FALSE;
 1122              		.loc 2 593 0
 1123 05fa 4FF00003 		mov	r3, #0
 1124 05fe 11E0     		b	.L53
 1125              	.L52:
 594:../QS/QS_ax12.c **** 
 595:../QS/QS_ax12.c **** 	return (AX12_instruction_get_last_status(id_servo).error & AX12_ERROR_TIMEOUT) == 0;
 1126              		.loc 2 595 0
 1127 0600 FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 1128 0602 1846     		mov	r0, r3
 1129 0604 00F0A8F8 		bl	AX12_instruction_get_last_status
 1130 0608 3880     		strh	r0, [r7, #0]	@ movhi
 1131 060a C0F30F43 		ubfx	r3, r0, #16, #16
 1132 060e 7B80     		strh	r3, [r7, #2]	@ movhi
 1133 0610 3B68     		ldr	r3, [r7, #0]
 1134 0612 FB61     		str	r3, [r7, #28]
 1135 0614 3B7F     		ldrb	r3, [r7, #28]	@ zero_extendqisi2
 1136 0616 DBB2     		uxtb	r3, r3
 1137 0618 6FEA0303 		mvn	r3, r3
 1138 061c DBB2     		uxtb	r3, r3
 1139 061e 4FEAD313 		lsr	r3, r3, #7
 1140 0622 DBB2     		uxtb	r3, r3
 1141              	.L53:
 596:../QS/QS_ax12.c **** }
 1142              		.loc 2 596 0
 1143 0624 1846     		mov	r0, r3
 1144 0626 07F12007 		add	r7, r7, #32
 1145 062a BD46     		mov	sp, r7
 1146 062c 80BD     		pop	{r7, pc}
 1147              		.cfi_endproc
 1148              	.LFE121:
 1150 062e 00BF     		.align	2
 1151              		.thumb
 1152              		.thumb_func
 1154              	AX12_instruction_buffer_is_full:
 1155              	.LFB122:
 597:../QS/QS_ax12.c **** 
 598:../QS/QS_ax12.c **** static bool_e AX12_instruction_buffer_is_full() {
 1156              		.loc 2 598 0
 1157              		.cfi_startproc
 1158              		@ args = 0, pretend = 0, frame = 0
 1159              		@ frame_needed = 1, uses_anonymous_args = 0
 1160              		@ link register save eliminated.
 1161 0630 80B4     		push	{r7}
 1162              	.LCFI39:
 1163              		.cfi_def_cfa_offset 4
 1164              		.cfi_offset 7, -4
 1165 0632 00AF     		add	r7, sp, #0
 1166              	.LCFI40:
 1167              		.cfi_def_cfa_register 7
 599:../QS/QS_ax12.c **** 	return AX12_instruction_queue_is_full();
 1168              		.loc 2 599 0
 1169 0634 40F20003 		movw	r3, #:lower16:AX12_special_instruction_buffer
 1170 0638 C0F20003 		movt	r3, #:upper16:AX12_special_instruction_buffer
 1171 063c 93F84936 		ldrb	r3, [r3, #1609]
 1172 0640 DBB2     		uxtb	r3, r3
 1173 0642 03F10103 		add	r3, r3, #1
 1174 0646 C82B     		cmp	r3, #200
 1175 0648 09DC     		bgt	.L55
 1176              		.loc 2 599 0 is_stmt 0 discriminator 1
 1177 064a 40F20003 		movw	r3, #:lower16:AX12_special_instruction_buffer
 1178 064e C0F20003 		movt	r3, #:upper16:AX12_special_instruction_buffer
 1179 0652 93F84936 		ldrb	r3, [r3, #1609]
 1180 0656 DBB2     		uxtb	r3, r3
 1181 0658 03F10102 		add	r2, r3, #1
 1182 065c 01E0     		b	.L56
 1183              	.L55:
 1184              		.loc 2 599 0 discriminator 2
 1185 065e 4FF00002 		mov	r2, #0
 1186              	.L56:
 1187              		.loc 2 599 0 discriminator 3
 1188 0662 40F20003 		movw	r3, #:lower16:AX12_special_instruction_buffer
 1189 0666 C0F20003 		movt	r3, #:upper16:AX12_special_instruction_buffer
 1190 066a 93F84836 		ldrb	r3, [r3, #1608]
 1191 066e DBB2     		uxtb	r3, r3
 1192 0670 9A42     		cmp	r2, r3
 1193 0672 14BF     		ite	ne
 1194 0674 0023     		movne	r3, #0
 1195 0676 0123     		moveq	r3, #1
 1196 0678 DBB2     		uxtb	r3, r3
 600:../QS/QS_ax12.c **** }
 1197              		.loc 2 600 0 is_stmt 1 discriminator 3
 1198 067a 1846     		mov	r0, r3
 1199 067c BD46     		mov	sp, r7
 1200 067e 80BC     		pop	{r7}
 1201 0680 7047     		bx	lr
 1202              		.cfi_endproc
 1203              	.LFE122:
 1205              		.section	.rodata
 1206 0032 0000     		.align	2
 1207              	.LC0:
 1208 0034 41583132 		.ascii	"AX12 Wait too long %d / %d\012\000"
 1208      20576169 
 1208      7420746F 
 1208      6F206C6F 
 1208      6E672025 
 1209              		.text
 1210 0682 00BF     		.align	2
 1211              		.thumb
 1212              		.thumb_func
 1214              	AX12_instruction_wait:
 1215              	.LFB123:
 601:../QS/QS_ax12.c **** 
 602:../QS/QS_ax12.c **** static bool_e AX12_instruction_wait(Uint8 id_servo) {
 1216              		.loc 2 602 0
 1217              		.cfi_startproc
 1218              		@ args = 0, pretend = 0, frame = 16
 1219              		@ frame_needed = 1, uses_anonymous_args = 0
 1220 0684 80B5     		push	{r7, lr}
 1221              	.LCFI41:
 1222              		.cfi_def_cfa_offset 8
 1223              		.cfi_offset 7, -8
 1224              		.cfi_offset 14, -4
 1225 0686 84B0     		sub	sp, sp, #16
 1226              	.LCFI42:
 1227              		.cfi_def_cfa_offset 24
 1228 0688 00AF     		add	r7, sp, #0
 1229              	.LCFI43:
 1230              		.cfi_def_cfa_register 7
 1231 068a 0346     		mov	r3, r0
 1232 068c FB71     		strb	r3, [r7, #7]
 603:../QS/QS_ax12.c **** 	Uint32 i = 0;
 1233              		.loc 2 603 0
 1234 068e 4FF00003 		mov	r3, #0
 1235 0692 FB60     		str	r3, [r7, #12]
 604:../QS/QS_ax12.c **** 	//debug_printf("+1\n");
 605:../QS/QS_ax12.c **** 	while(!AX12_instruction_queue_is_empty() && i < 65000000)	//si i atteint 65000, on stop, on a atte
 1236              		.loc 2 605 0
 1237 0694 03E0     		b	.L59
 1238              	.L61:
 606:../QS/QS_ax12.c **** 		i++;
 1239              		.loc 2 606 0
 1240 0696 FB68     		ldr	r3, [r7, #12]
 1241 0698 03F10103 		add	r3, r3, #1
 1242 069c FB60     		str	r3, [r7, #12]
 1243              	.L59:
 605:../QS/QS_ax12.c **** 	while(!AX12_instruction_queue_is_empty() && i < 65000000)	//si i atteint 65000, on stop, on a atte
 1244              		.loc 2 605 0 discriminator 1
 1245 069e 40F20003 		movw	r3, #:lower16:AX12_special_instruction_buffer
 1246 06a2 C0F20003 		movt	r3, #:upper16:AX12_special_instruction_buffer
 1247 06a6 93F84936 		ldrb	r3, [r3, #1609]
 1248 06aa DAB2     		uxtb	r2, r3
 1249 06ac 40F20003 		movw	r3, #:lower16:AX12_special_instruction_buffer
 1250 06b0 C0F20003 		movt	r3, #:upper16:AX12_special_instruction_buffer
 1251 06b4 93F84836 		ldrb	r3, [r3, #1608]
 1252 06b8 DBB2     		uxtb	r3, r3
 1253 06ba 9A42     		cmp	r2, r3
 1254 06bc 06D0     		beq	.L60
 605:../QS/QS_ax12.c **** 	while(!AX12_instruction_queue_is_empty() && i < 65000000)	//si i atteint 65000, on stop, on a atte
 1255              		.loc 2 605 0 is_stmt 0 discriminator 2
 1256 06be FA68     		ldr	r2, [r7, #12]
 1257 06c0 4DF23F23 		movw	r3, #53823
 1258 06c4 C0F2DF33 		movt	r3, 991
 1259 06c8 9A42     		cmp	r2, r3
 1260 06ca E4D9     		bls	.L61
 1261              	.L60:
 607:../QS/QS_ax12.c **** 
 608:../QS/QS_ax12.c **** 	if(i < 65000000) return TRUE;
 1262              		.loc 2 608 0 is_stmt 1
 1263 06cc FA68     		ldr	r2, [r7, #12]
 1264 06ce 4DF23F23 		movw	r3, #53823
 1265 06d2 C0F2DF33 		movt	r3, 991
 1266 06d6 9A42     		cmp	r2, r3
 1267 06d8 02D8     		bhi	.L62
 1268              		.loc 2 608 0 is_stmt 0 discriminator 1
 1269 06da 4FF00103 		mov	r3, #1
 1270 06de 36E0     		b	.L63
 1271              	.L62:
 609:../QS/QS_ax12.c **** 
 610:../QS/QS_ax12.c **** 	debug_printf("AX12 Wait too long %d / %d\n", AX12_special_instruction_buffer.start_index, AX12_spe
 1272              		.loc 2 610 0 is_stmt 1
 1273 06e0 40F20003 		movw	r3, #:lower16:AX12_special_instruction_buffer
 1274 06e4 C0F20003 		movt	r3, #:upper16:AX12_special_instruction_buffer
 1275 06e8 93F84836 		ldrb	r3, [r3, #1608]
 1276 06ec DBB2     		uxtb	r3, r3
 1277 06ee 1A46     		mov	r2, r3
 1278 06f0 40F20003 		movw	r3, #:lower16:AX12_special_instruction_buffer
 1279 06f4 C0F20003 		movt	r3, #:upper16:AX12_special_instruction_buffer
 1280 06f8 93F84936 		ldrb	r3, [r3, #1609]
 1281 06fc DBB2     		uxtb	r3, r3
 1282 06fe 4FF00500 		mov	r0, #5
 1283 0702 40F20001 		movw	r1, #:lower16:.LC0
 1284 0706 C0F20001 		movt	r1, #:upper16:.LC0
 1285 070a FFF7FEFF 		bl	OUTPUTLOG_printf
 611:../QS/QS_ax12.c **** 	AX12_on_the_robot[id_servo].last_status.error = AX12_ERROR_TIMEOUT | AX12_ERROR_RANGE;	//On a atte
 1286              		.loc 2 611 0
 1287 070e F979     		ldrb	r1, [r7, #7]	@ zero_extendqisi2
 1288 0710 40F20002 		movw	r2, #:lower16:AX12_on_the_robot
 1289 0714 C0F20002 		movt	r2, #:upper16:AX12_on_the_robot
 1290 0718 0B46     		mov	r3, r1
 1291 071a 4FEA8303 		lsl	r3, r3, #2
 1292 071e 5B18     		adds	r3, r3, r1
 1293 0720 4FEA4303 		lsl	r3, r3, #1
 1294 0724 D318     		adds	r3, r2, r3
 1295 0726 4FF08802 		mov	r2, #136
 1296 072a 1A70     		strb	r2, [r3, #0]
 612:../QS/QS_ax12.c **** 	AX12_on_the_robot[id_servo].last_status.param = 0;
 1297              		.loc 2 612 0
 1298 072c F979     		ldrb	r1, [r7, #7]	@ zero_extendqisi2
 1299 072e 40F20002 		movw	r2, #:lower16:AX12_on_the_robot
 1300 0732 C0F20002 		movt	r2, #:upper16:AX12_on_the_robot
 1301 0736 0B46     		mov	r3, r1
 1302 0738 4FEA8303 		lsl	r3, r3, #2
 1303 073c 5B18     		adds	r3, r3, r1
 1304 073e 4FEA4303 		lsl	r3, r3, #1
 1305 0742 D318     		adds	r3, r2, r3
 1306 0744 4FF00002 		mov	r2, #0
 1307 0748 5A80     		strh	r2, [r3, #2]	@ movhi
 613:../QS/QS_ax12.c **** 	return FALSE;
 1308              		.loc 2 613 0
 1309 074a 4FF00003 		mov	r3, #0
 1310              	.L63:
 614:../QS/QS_ax12.c **** }
 1311              		.loc 2 614 0
 1312 074e 1846     		mov	r0, r3
 1313 0750 07F11007 		add	r7, r7, #16
 1314 0754 BD46     		mov	sp, r7
 1315 0756 80BD     		pop	{r7, pc}
 1316              		.cfi_endproc
 1317              	.LFE123:
 1319              		.align	2
 1320              		.thumb
 1321              		.thumb_func
 1323              	AX12_instruction_get_last_status:
 1324              	.LFB124:
 615:../QS/QS_ax12.c **** 
 616:../QS/QS_ax12.c **** static AX12_status_t AX12_instruction_get_last_status(Uint8 id_servo)
 617:../QS/QS_ax12.c **** {
 1325              		.loc 2 617 0
 1326              		.cfi_startproc
 1327              		@ args = 0, pretend = 0, frame = 16
 1328              		@ frame_needed = 1, uses_anonymous_args = 0
 1329              		@ link register save eliminated.
 1330 0758 80B4     		push	{r7}
 1331              	.LCFI44:
 1332              		.cfi_def_cfa_offset 4
 1333              		.cfi_offset 7, -4
 1334 075a 85B0     		sub	sp, sp, #20
 1335              	.LCFI45:
 1336              		.cfi_def_cfa_offset 24
 1337 075c 00AF     		add	r7, sp, #0
 1338              	.LCFI46:
 1339              		.cfi_def_cfa_register 7
 1340 075e 0346     		mov	r3, r0
 1341 0760 FB71     		strb	r3, [r7, #7]
 618:../QS/QS_ax12.c **** 	return AX12_on_the_robot[id_servo].last_status;
 1342              		.loc 2 618 0
 1343 0762 F979     		ldrb	r1, [r7, #7]	@ zero_extendqisi2
 1344 0764 40F20002 		movw	r2, #:lower16:AX12_on_the_robot
 1345 0768 C0F20002 		movt	r2, #:upper16:AX12_on_the_robot
 1346 076c 0B46     		mov	r3, r1
 1347 076e 4FEA8303 		lsl	r3, r3, #2
 1348 0772 5B18     		adds	r3, r3, r1
 1349 0774 4FEA4303 		lsl	r3, r3, #1
 1350 0778 D218     		adds	r2, r2, r3
 1351 077a 07F10C03 		add	r3, r7, #12
 1352 077e 1068     		ldr	r0, [r2, #0]	@ unaligned
 1353 0780 1860     		str	r0, [r3, #0]	@ unaligned
 1354 0782 4FF00003 		mov	r3, #0
 1355 0786 BA89     		ldrh	r2, [r7, #12]
 1356 0788 62F30F03 		bfi	r3, r2, #0, #16
 1357 078c FA89     		ldrh	r2, [r7, #14]
 1358 078e 62F31F43 		bfi	r3, r2, #16, #16
 619:../QS/QS_ax12.c **** }
 1359              		.loc 2 619 0
 1360 0792 1846     		mov	r0, r3
 1361 0794 07F11407 		add	r7, r7, #20
 1362 0798 BD46     		mov	sp, r7
 1363 079a 80BC     		pop	{r7}
 1364 079c 7047     		bx	lr
 1365              		.cfi_endproc
 1366              	.LFE124:
 1368 079e 00BF     		.align	2
 1369              		.thumb
 1370              		.thumb_func
 1372              	AX12_instruction_reset_last_status:
 1373              	.LFB125:
 620:../QS/QS_ax12.c **** 
 621:../QS/QS_ax12.c **** static void AX12_instruction_reset_last_status(Uint8 id_servo) {
 1374              		.loc 2 621 0
 1375              		.cfi_startproc
 1376              		@ args = 0, pretend = 0, frame = 8
 1377              		@ frame_needed = 1, uses_anonymous_args = 0
 1378              		@ link register save eliminated.
 1379 07a0 80B4     		push	{r7}
 1380              	.LCFI47:
 1381              		.cfi_def_cfa_offset 4
 1382              		.cfi_offset 7, -4
 1383 07a2 83B0     		sub	sp, sp, #12
 1384              	.LCFI48:
 1385              		.cfi_def_cfa_offset 16
 1386 07a4 00AF     		add	r7, sp, #0
 1387              	.LCFI49:
 1388              		.cfi_def_cfa_register 7
 1389 07a6 0346     		mov	r3, r0
 1390 07a8 FB71     		strb	r3, [r7, #7]
 622:../QS/QS_ax12.c **** 	AX12_on_the_robot[id_servo].last_status.error = AX12_ERROR_OK;
 1391              		.loc 2 622 0
 1392 07aa F979     		ldrb	r1, [r7, #7]	@ zero_extendqisi2
 1393 07ac 40F20002 		movw	r2, #:lower16:AX12_on_the_robot
 1394 07b0 C0F20002 		movt	r2, #:upper16:AX12_on_the_robot
 1395 07b4 0B46     		mov	r3, r1
 1396 07b6 4FEA8303 		lsl	r3, r3, #2
 1397 07ba 5B18     		adds	r3, r3, r1
 1398 07bc 4FEA4303 		lsl	r3, r3, #1
 1399 07c0 D318     		adds	r3, r2, r3
 1400 07c2 4FF00002 		mov	r2, #0
 1401 07c6 1A70     		strb	r2, [r3, #0]
 623:../QS/QS_ax12.c **** 	AX12_on_the_robot[id_servo].last_status.param = 0;
 1402              		.loc 2 623 0
 1403 07c8 F979     		ldrb	r1, [r7, #7]	@ zero_extendqisi2
 1404 07ca 40F20002 		movw	r2, #:lower16:AX12_on_the_robot
 1405 07ce C0F20002 		movt	r2, #:upper16:AX12_on_the_robot
 1406 07d2 0B46     		mov	r3, r1
 1407 07d4 4FEA8303 		lsl	r3, r3, #2
 1408 07d8 5B18     		adds	r3, r3, r1
 1409 07da 4FEA4303 		lsl	r3, r3, #1
 1410 07de D318     		adds	r3, r2, r3
 1411 07e0 4FF00002 		mov	r2, #0
 1412 07e4 5A80     		strh	r2, [r3, #2]	@ movhi
 624:../QS/QS_ax12.c **** }
 1413              		.loc 2 624 0
 1414 07e6 07F10C07 		add	r7, r7, #12
 1415 07ea BD46     		mov	sp, r7
 1416 07ec 80BC     		pop	{r7}
 1417 07ee 7047     		bx	lr
 1418              		.cfi_endproc
 1419              	.LFE125:
 1421              		.align	2
 1422              		.thumb
 1423              		.thumb_func
 1425              	AX12_decode_value_range:
 1426              	.LFB126:
 625:../QS/QS_ax12.c **** 
 626:../QS/QS_ax12.c **** /*****************************************************************************/
 627:../QS/QS_ax12.c **** /** Fonctions internes pour la gestion des paquets et les limites de valeur **/
 628:../QS/QS_ax12.c **** /*****************************************************************************/
 629:../QS/QS_ax12.c **** 
 630:../QS/QS_ax12.c **** static inline Uint16 AX12_decode_value_range(Uint8 mem_addr, bool_e get_max) {
 1427              		.loc 2 630 0
 1428              		.cfi_startproc
 1429              		@ args = 0, pretend = 0, frame = 8
 1430              		@ frame_needed = 1, uses_anonymous_args = 0
 1431              		@ link register save eliminated.
 1432 07f0 80B4     		push	{r7}
 1433              	.LCFI50:
 1434              		.cfi_def_cfa_offset 4
 1435              		.cfi_offset 7, -4
 1436 07f2 83B0     		sub	sp, sp, #12
 1437              	.LCFI51:
 1438              		.cfi_def_cfa_offset 16
 1439 07f4 00AF     		add	r7, sp, #0
 1440              	.LCFI52:
 1441              		.cfi_def_cfa_register 7
 1442 07f6 0246     		mov	r2, r0
 1443 07f8 0B46     		mov	r3, r1
 1444 07fa FA71     		strb	r2, [r7, #7]
 1445 07fc BB71     		strb	r3, [r7, #6]
 631:../QS/QS_ax12.c **** 	if(mem_addr >= AX12_MEM_SIZE) return 0;
 1446              		.loc 2 631 0
 1447 07fe FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 1448 0800 312B     		cmp	r3, #49
 1449 0802 02D9     		bls	.L68
 1450              		.loc 2 631 0 is_stmt 0 discriminator 1
 1451 0804 4FF00003 		mov	r3, #0
 1452 0808 5DE0     		b	.L69
 1453              	.L68:
 632:../QS/QS_ax12.c **** 
 633:../QS/QS_ax12.c **** 	if(!get_max) {
 1454              		.loc 2 633 0 is_stmt 1
 1455 080a BB79     		ldrb	r3, [r7, #6]	@ zero_extendqisi2
 1456 080c 002B     		cmp	r3, #0
 1457 080e 21D1     		bne	.L70
 634:../QS/QS_ax12.c **** 		switch(AX12_values_ranges[mem_addr] & 0x0F) {
 1458              		.loc 2 634 0
 1459 0810 FA79     		ldrb	r2, [r7, #7]	@ zero_extendqisi2
 1460 0812 40F20003 		movw	r3, #:lower16:AX12_values_ranges
 1461 0816 C0F20003 		movt	r3, #:upper16:AX12_values_ranges
 1462 081a 9B5C     		ldrb	r3, [r3, r2]	@ zero_extendqisi2
 1463 081c 03F00F03 		and	r3, r3, #15
 1464 0820 032B     		cmp	r3, #3
 1465 0822 4ED8     		bhi	.L71
 1466 0824 01A2     		adr	r2, .L76
 1467 0826 52F823F0 		ldr	pc, [r2, r3, lsl #2]
 1468 082a 00BF     		.align	2
 1469              	.L76:
 1470 082c 3D080000 		.word	.L72+1
 1471 0830 43080000 		.word	.L73+1
 1472 0834 49080000 		.word	.L74+1
 1473 0838 4F080000 		.word	.L75+1
 1474              	.L72:
 635:../QS/QS_ax12.c **** 			case AX12_MIN_VALUE_0:  return 0;
 1475              		.loc 2 635 0
 1476 083c 4FF00003 		mov	r3, #0
 1477 0840 41E0     		b	.L69
 1478              	.L73:
 636:../QS/QS_ax12.c **** 			case AX12_MIN_VALUE_1:  return 1;
 1479              		.loc 2 636 0
 1480 0842 4FF00103 		mov	r3, #1
 1481 0846 3EE0     		b	.L69
 1482              	.L74:
 637:../QS/QS_ax12.c **** 			case AX12_MIN_VALUE_34: return 34;
 1483              		.loc 2 637 0
 1484 0848 4FF02203 		mov	r3, #34
 1485 084c 3BE0     		b	.L69
 1486              	.L75:
 638:../QS/QS_ax12.c **** 			case AX12_MIN_VALUE_50: return 50;
 1487              		.loc 2 638 0
 1488 084e 4FF03203 		mov	r3, #50
 1489 0852 38E0     		b	.L69
 1490              	.L70:
 639:../QS/QS_ax12.c **** 		}
 640:../QS/QS_ax12.c **** 	} else {
 641:../QS/QS_ax12.c **** 		switch(AX12_values_ranges[mem_addr] & 0xF0) {
 1491              		.loc 2 641 0
 1492 0854 FA79     		ldrb	r2, [r7, #7]	@ zero_extendqisi2
 1493 0856 40F20003 		movw	r3, #:lower16:AX12_values_ranges
 1494 085a C0F20003 		movt	r3, #:upper16:AX12_values_ranges
 1495 085e 9B5C     		ldrb	r3, [r3, r2]	@ zero_extendqisi2
 1496 0860 03F0F003 		and	r3, r3, #240
 1497 0864 302B     		cmp	r3, #48
 1498 0866 1DD0     		beq	.L80
 1499 0868 302B     		cmp	r3, #48
 1500 086a 06DC     		bgt	.L85
 1501 086c 102B     		cmp	r3, #16
 1502 086e 13D0     		beq	.L78
 1503 0870 202B     		cmp	r3, #32
 1504 0872 14D0     		beq	.L79
 1505 0874 002B     		cmp	r3, #0
 1506 0876 0CD0     		beq	.L77
 1507 0878 23E0     		b	.L71
 1508              	.L85:
 1509 087a 502B     		cmp	r3, #80
 1510 087c 18D0     		beq	.L82
 1511 087e 502B     		cmp	r3, #80
 1512 0880 02DC     		bgt	.L86
 1513 0882 402B     		cmp	r3, #64
 1514 0884 11D0     		beq	.L81
 1515 0886 1CE0     		b	.L71
 1516              	.L86:
 1517 0888 602B     		cmp	r3, #96
 1518 088a 14D0     		beq	.L83
 1519 088c 702B     		cmp	r3, #112
 1520 088e 15D0     		beq	.L84
 1521 0890 17E0     		b	.L71
 1522              	.L77:
 642:../QS/QS_ax12.c **** 			case AX12_MAX_VALUE_1023: return 1023;
 1523              		.loc 2 642 0
 1524 0892 40F2FF33 		movw	r3, #1023
 1525 0896 16E0     		b	.L69
 1526              	.L78:
 643:../QS/QS_ax12.c **** 			case AX12_MAX_VALUE_254:  return 254;
 1527              		.loc 2 643 0
 1528 0898 4FF0FE03 		mov	r3, #254
 1529 089c 13E0     		b	.L69
 1530              	.L79:
 644:../QS/QS_ax12.c **** 			case AX12_MAX_VALUE_253:  return 253;
 1531              		.loc 2 644 0
 1532 089e 4FF0FD03 		mov	r3, #253
 1533 08a2 10E0     		b	.L69
 1534              	.L80:
 645:../QS/QS_ax12.c **** 			case AX12_MAX_VALUE_250:  return 250;
 1535              		.loc 2 645 0
 1536 08a4 4FF0FA03 		mov	r3, #250
 1537 08a8 0DE0     		b	.L69
 1538              	.L81:
 646:../QS/QS_ax12.c **** 			case AX12_MAX_VALUE_150:  return 150;
 1539              		.loc 2 646 0
 1540 08aa 4FF09603 		mov	r3, #150
 1541 08ae 0AE0     		b	.L69
 1542              	.L82:
 647:../QS/QS_ax12.c **** 			case AX12_MAX_VALUE_127:  return 127;
 1543              		.loc 2 647 0
 1544 08b0 4FF07F03 		mov	r3, #127
 1545 08b4 07E0     		b	.L69
 1546              	.L83:
 648:../QS/QS_ax12.c **** 			case AX12_MAX_VALUE_2:    return 2;
 1547              		.loc 2 648 0
 1548 08b6 4FF00203 		mov	r3, #2
 1549 08ba 04E0     		b	.L69
 1550              	.L84:
 649:../QS/QS_ax12.c **** 			case AX12_MAX_VALUE_1:    return 1;
 1551              		.loc 2 649 0
 1552 08bc 4FF00103 		mov	r3, #1
 1553 08c0 01E0     		b	.L69
 1554              	.L71:
 650:../QS/QS_ax12.c **** 		}
 651:../QS/QS_ax12.c **** 	}
 652:../QS/QS_ax12.c **** 
 653:../QS/QS_ax12.c **** 	return 0;
 1555              		.loc 2 653 0
 1556 08c2 4FF00003 		mov	r3, #0
 1557              	.L69:
 654:../QS/QS_ax12.c **** }
 1558              		.loc 2 654 0
 1559 08c6 1846     		mov	r0, r3
 1560 08c8 07F10C07 		add	r7, r7, #12
 1561 08cc BD46     		mov	sp, r7
 1562 08ce 80BC     		pop	{r7}
 1563 08d0 7047     		bx	lr
 1564              		.cfi_endproc
 1565              	.LFE126:
 1567              		.section	.rodata
 1568              		.align	2
 1569              	.LC1:
 1570 0050 41583132 		.ascii	"AX12: Error: in AX12_instruction_packet_calc_checks"
 1570      3A204572 
 1570      726F723A 
 1570      20696E20 
 1570      41583132 
 1571 0083 756D2829 		.ascii	"um(): paquet trop petit\000"
 1571      3A207061 
 1571      71756574 
 1571      2074726F 
 1571      70207065 
 1572 009b 00       		.align	2
 1573              	.LC2:
 1574 009c 41583132 		.ascii	"AX12: Error: AX12_instruction_packet_calc_checksum("
 1574      3A204572 
 1574      726F723A 
 1574      20415831 
 1574      325F696E 
 1575 00cf 293A2070 		.ascii	"): paquet trop grand\000"
 1575      61717565 
 1575      74207472 
 1575      6F702067 
 1575      72616E64 
 1576              		.text
 1577 08d2 00BF     		.align	2
 1578              		.thumb
 1579              		.thumb_func
 1581              	AX12_instruction_packet_calc_checksum:
 1582              	.LFB127:
 655:../QS/QS_ax12.c **** 
 656:../QS/QS_ax12.c **** static Uint8 AX12_instruction_packet_calc_checksum(AX12_instruction_packet_t* instruction_packet) {
 1583              		.loc 2 656 0
 1584              		.cfi_startproc
 1585              		@ args = 0, pretend = 0, frame = 16
 1586              		@ frame_needed = 1, uses_anonymous_args = 0
 1587 08d4 80B5     		push	{r7, lr}
 1588              	.LCFI53:
 1589              		.cfi_def_cfa_offset 8
 1590              		.cfi_offset 7, -8
 1591              		.cfi_offset 14, -4
 1592 08d6 84B0     		sub	sp, sp, #16
 1593              	.LCFI54:
 1594              		.cfi_def_cfa_offset 24
 1595 08d8 00AF     		add	r7, sp, #0
 1596              	.LCFI55:
 1597              		.cfi_def_cfa_register 7
 1598 08da 7860     		str	r0, [r7, #4]
 657:../QS/QS_ax12.c **** 	Uint8 checksum = 0;
 1599              		.loc 2 657 0
 1600 08dc 4FF00003 		mov	r3, #0
 1601 08e0 FB73     		strb	r3, [r7, #15]
 658:../QS/QS_ax12.c **** 	Uint8 packet_length = instruction_packet->size - 4;
 1602              		.loc 2 658 0
 1603 08e2 7B68     		ldr	r3, [r7, #4]
 1604 08e4 9B79     		ldrb	r3, [r3, #6]	@ zero_extendqisi2
 1605 08e6 A3F10403 		sub	r3, r3, #4
 1606 08ea BB73     		strb	r3, [r7, #14]
 659:../QS/QS_ax12.c **** 
 660:../QS/QS_ax12.c **** 	if(instruction_packet->size < 6)
 1607              		.loc 2 660 0
 1608 08ec 7B68     		ldr	r3, [r7, #4]
 1609 08ee 9B79     		ldrb	r3, [r3, #6]	@ zero_extendqisi2
 1610 08f0 052B     		cmp	r3, #5
 1611 08f2 07D8     		bhi	.L88
 661:../QS/QS_ax12.c **** 		debug_printf("AX12: Error: in AX12_instruction_packet_calc_checksum(): paquet trop petit");
 1612              		.loc 2 661 0
 1613 08f4 4FF00500 		mov	r0, #5
 1614 08f8 40F20001 		movw	r1, #:lower16:.LC1
 1615 08fc C0F20001 		movt	r1, #:upper16:.LC1
 1616 0900 FFF7FEFF 		bl	OUTPUTLOG_printf
 1617              	.L88:
 662:../QS/QS_ax12.c **** 
 663:../QS/QS_ax12.c **** 	//packet_length est forcment >= 2 (voir datasheet de l'ax12)
 664:../QS/QS_ax12.c **** 	//PAS de break, si il y a 3 paramtres (packet_length = 3 +2), on fait toutes les additions
 665:../QS/QS_ax12.c **** 	switch(packet_length) {
 1618              		.loc 2 665 0
 1619 0904 BB7B     		ldrb	r3, [r7, #14]	@ zero_extendqisi2
 1620 0906 A3F10203 		sub	r3, r3, #2
 1621 090a 032B     		cmp	r3, #3
 1622 090c 26D8     		bhi	.L89
 1623 090e 01A2     		adr	r2, .L94
 1624 0910 52F823F0 		ldr	pc, [r2, r3, lsl #2]
 1625              		.align	2
 1626              	.L94:
 1627 0914 43090000 		.word	.L90+1
 1628 0918 39090000 		.word	.L91+1
 1629 091c 2F090000 		.word	.L92+1
 1630 0920 25090000 		.word	.L93+1
 1631              	.L93:
 666:../QS/QS_ax12.c **** 		case 5:	//3 paramtres
 667:../QS/QS_ax12.c **** 			checksum += instruction_packet->param_2;
 1632              		.loc 2 667 0
 1633 0924 7B68     		ldr	r3, [r7, #4]
 1634 0926 5A79     		ldrb	r2, [r3, #5]	@ zero_extendqisi2
 1635 0928 FB7B     		ldrb	r3, [r7, #15]
 1636 092a D318     		adds	r3, r2, r3
 1637 092c FB73     		strb	r3, [r7, #15]
 1638              	.L92:
 668:../QS/QS_ax12.c **** 		case 4:	//2 paramtres
 669:../QS/QS_ax12.c **** 			checksum += instruction_packet->param_1;
 1639              		.loc 2 669 0
 1640 092e 7B68     		ldr	r3, [r7, #4]
 1641 0930 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
 1642 0932 FB7B     		ldrb	r3, [r7, #15]
 1643 0934 D318     		adds	r3, r2, r3
 1644 0936 FB73     		strb	r3, [r7, #15]
 1645              	.L91:
 670:../QS/QS_ax12.c **** 		case 3:	//1 paramtre
 671:../QS/QS_ax12.c **** 			checksum += instruction_packet->address;
 1646              		.loc 2 671 0
 1647 0938 7B68     		ldr	r3, [r7, #4]
 1648 093a 9A78     		ldrb	r2, [r3, #2]	@ zero_extendqisi2
 1649 093c FB7B     		ldrb	r3, [r7, #15]
 1650 093e D318     		adds	r3, r2, r3
 1651 0940 FB73     		strb	r3, [r7, #15]
 1652              	.L90:
 672:../QS/QS_ax12.c **** 		case 2:	//pas de paramtre
 673:../QS/QS_ax12.c **** 			checksum += instruction_packet->id_servo + packet_length + instruction_packet->type;
 1653              		.loc 2 673 0
 1654 0942 7B68     		ldr	r3, [r7, #4]
 1655 0944 1A78     		ldrb	r2, [r3, #0]	@ zero_extendqisi2
 1656 0946 BB7B     		ldrb	r3, [r7, #14]
 1657 0948 D318     		adds	r3, r2, r3
 1658 094a DAB2     		uxtb	r2, r3
 1659 094c 7B68     		ldr	r3, [r7, #4]
 1660 094e 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 1661 0950 D318     		adds	r3, r2, r3
 1662 0952 DAB2     		uxtb	r2, r3
 1663 0954 FB7B     		ldrb	r3, [r7, #15]
 1664 0956 D318     		adds	r3, r2, r3
 1665 0958 FB73     		strb	r3, [r7, #15]
 674:../QS/QS_ax12.c **** 			break;
 1666              		.loc 2 674 0
 1667 095a 07E0     		b	.L95
 1668              	.L89:
 675:../QS/QS_ax12.c **** 
 676:../QS/QS_ax12.c **** 		default:
 677:../QS/QS_ax12.c **** 			debug_printf("AX12: Error: AX12_instruction_packet_calc_checksum(): paquet trop grand");
 1669              		.loc 2 677 0
 1670 095c 4FF00500 		mov	r0, #5
 1671 0960 40F20001 		movw	r1, #:lower16:.LC2
 1672 0964 C0F20001 		movt	r1, #:upper16:.LC2
 1673 0968 FFF7FEFF 		bl	OUTPUTLOG_printf
 1674              	.L95:
 678:../QS/QS_ax12.c **** 	}
 679:../QS/QS_ax12.c **** 
 680:../QS/QS_ax12.c **** 	return ~checksum;
 1675              		.loc 2 680 0
 1676 096c FB7B     		ldrb	r3, [r7, #15]
 1677 096e 6FEA0303 		mvn	r3, r3
 1678 0972 DBB2     		uxtb	r3, r3
 681:../QS/QS_ax12.c **** }
 1679              		.loc 2 681 0
 1680 0974 1846     		mov	r0, r3
 1681 0976 07F11007 		add	r7, r7, #16
 1682 097a BD46     		mov	sp, r7
 1683 097c 80BD     		pop	{r7, pc}
 1684              		.cfi_endproc
 1685              	.LFE127:
 1687              		.section	.rodata
 1688              		.align	2
 1689              	.LC3:
 1690 00e4 41583132 		.ascii	"AX12: Warning: byte_offset > 7\015\012\000"
 1690      3A205761 
 1690      726E696E 
 1690      673A2062 
 1690      7974655F 
 1691              		.text
 1692 097e 00BF     		.align	2
 1693              		.thumb
 1694              		.thumb_func
 1696              	AX12_get_instruction_packet:
 1697              	.LFB128:
 682:../QS/QS_ax12.c **** 
 683:../QS/QS_ax12.c **** static Uint8 AX12_get_instruction_packet(Uint8 byte_offset, AX12_instruction_packet_t* instruction_
 1698              		.loc 2 683 0
 1699              		.cfi_startproc
 1700              		@ args = 0, pretend = 0, frame = 8
 1701              		@ frame_needed = 1, uses_anonymous_args = 0
 1702 0980 80B5     		push	{r7, lr}
 1703              	.LCFI56:
 1704              		.cfi_def_cfa_offset 8
 1705              		.cfi_offset 7, -8
 1706              		.cfi_offset 14, -4
 1707 0982 82B0     		sub	sp, sp, #8
 1708              	.LCFI57:
 1709              		.cfi_def_cfa_offset 16
 1710 0984 00AF     		add	r7, sp, #0
 1711              	.LCFI58:
 1712              		.cfi_def_cfa_register 7
 1713 0986 0346     		mov	r3, r0
 1714 0988 3960     		str	r1, [r7, #0]
 1715 098a FB71     		strb	r3, [r7, #7]
 684:../QS/QS_ax12.c **** 
 685:../QS/QS_ax12.c **** 	if(byte_offset == instruction_packet->size - 1)	//si c'est le dernier octet, envoyer le checksum
 1716              		.loc 2 685 0
 1717 098c FA79     		ldrb	r2, [r7, #7]	@ zero_extendqisi2
 1718 098e 3B68     		ldr	r3, [r7, #0]
 1719 0990 9B79     		ldrb	r3, [r3, #6]	@ zero_extendqisi2
 1720 0992 03F1FF33 		add	r3, r3, #-1
 1721 0996 9A42     		cmp	r2, r3
 1722 0998 04D1     		bne	.L98
 686:../QS/QS_ax12.c **** 		return AX12_instruction_packet_calc_checksum(instruction_packet);
 1723              		.loc 2 686 0
 1724 099a 3868     		ldr	r0, [r7, #0]
 1725 099c FFF79AFF 		bl	AX12_instruction_packet_calc_checksum
 1726 09a0 0346     		mov	r3, r0
 1727 09a2 3AE0     		b	.L99
 1728              	.L98:
 687:../QS/QS_ax12.c **** 
 688:../QS/QS_ax12.c **** 	switch(byte_offset)
 1729              		.loc 2 688 0
 1730 09a4 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 1731 09a6 072B     		cmp	r3, #7
 1732 09a8 2AD8     		bhi	.L100
 1733 09aa 01A2     		adr	r2, .L108
 1734 09ac 52F823F0 		ldr	pc, [r2, r3, lsl #2]
 1735              		.align	2
 1736              	.L108:
 1737 09b0 D1090000 		.word	.L101+1
 1738 09b4 D1090000 		.word	.L101+1
 1739 09b8 D7090000 		.word	.L102+1
 1740 09bc DD090000 		.word	.L103+1
 1741 09c0 E9090000 		.word	.L104+1
 1742 09c4 EF090000 		.word	.L105+1
 1743 09c8 F5090000 		.word	.L106+1
 1744 09cc FB090000 		.word	.L107+1
 1745              	.L101:
 689:../QS/QS_ax12.c **** 	{
 690:../QS/QS_ax12.c **** 		case 0:	//PAS de break, on retourne 0xFF pour les octets numro 0 et 1
 691:../QS/QS_ax12.c **** 		case 1: return 0xFF;
 1746              		.loc 2 691 0
 1747 09d0 4FF0FF03 		mov	r3, #255
 1748 09d4 21E0     		b	.L99
 1749              	.L102:
 692:../QS/QS_ax12.c **** 		case 2: return instruction_packet->id_servo;
 1750              		.loc 2 692 0
 1751 09d6 3B68     		ldr	r3, [r7, #0]
 1752 09d8 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 1753 09da 1EE0     		b	.L99
 1754              	.L103:
 693:../QS/QS_ax12.c **** 		case 3: return instruction_packet->size - 4;
 1755              		.loc 2 693 0
 1756 09dc 3B68     		ldr	r3, [r7, #0]
 1757 09de 9B79     		ldrb	r3, [r3, #6]	@ zero_extendqisi2
 1758 09e0 A3F10403 		sub	r3, r3, #4
 1759 09e4 DBB2     		uxtb	r3, r3
 1760 09e6 18E0     		b	.L99
 1761              	.L104:
 694:../QS/QS_ax12.c **** 		case 4: return instruction_packet->type;
 1762              		.loc 2 694 0
 1763 09e8 3B68     		ldr	r3, [r7, #0]
 1764 09ea 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 1765 09ec 15E0     		b	.L99
 1766              	.L105:
 695:../QS/QS_ax12.c **** 		case 5:	return instruction_packet->address;
 1767              		.loc 2 695 0
 1768 09ee 3B68     		ldr	r3, [r7, #0]
 1769 09f0 9B78     		ldrb	r3, [r3, #2]	@ zero_extendqisi2
 1770 09f2 12E0     		b	.L99
 1771              	.L106:
 696:../QS/QS_ax12.c **** 		case 6: return instruction_packet->param_1;
 1772              		.loc 2 696 0
 1773 09f4 3B68     		ldr	r3, [r7, #0]
 1774 09f6 1B79     		ldrb	r3, [r3, #4]	@ zero_extendqisi2
 1775 09f8 0FE0     		b	.L99
 1776              	.L107:
 697:../QS/QS_ax12.c **** 		case 7: return instruction_packet->param_2;
 1777              		.loc 2 697 0
 1778 09fa 3B68     		ldr	r3, [r7, #0]
 1779 09fc 5B79     		ldrb	r3, [r3, #5]	@ zero_extendqisi2
 1780 09fe 0CE0     		b	.L99
 1781              	.L100:
 698:../QS/QS_ax12.c **** 
 699:../QS/QS_ax12.c **** 		default:
 700:../QS/QS_ax12.c **** 			if(byte_offset > 7)
 1782              		.loc 2 700 0
 1783 0a00 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 1784 0a02 072B     		cmp	r3, #7
 1785 0a04 07D9     		bls	.L109
 701:../QS/QS_ax12.c **** 				debug_printf("AX12: Warning: byte_offset > 7\r\n");
 1786              		.loc 2 701 0
 1787 0a06 4FF00500 		mov	r0, #5
 1788 0a0a 40F20001 		movw	r1, #:lower16:.LC3
 1789 0a0e C0F20001 		movt	r1, #:upper16:.LC3
 1790 0a12 FFF7FEFF 		bl	OUTPUTLOG_printf
 1791              	.L109:
 702:../QS/QS_ax12.c **** 	}
 703:../QS/QS_ax12.c **** 
 704:../QS/QS_ax12.c **** 	//Si on atteint cette ligne, byte_offset > 7, on retourne 0 par dfaut (a ne devrais jamais arriv
 705:../QS/QS_ax12.c **** 	return 0;
 1792              		.loc 2 705 0
 1793 0a16 4FF00003 		mov	r3, #0
 1794              	.L99:
 706:../QS/QS_ax12.c **** }
 1795              		.loc 2 706 0
 1796 0a1a 1846     		mov	r0, r3
 1797 0a1c 07F10807 		add	r7, r7, #8
 1798 0a20 BD46     		mov	sp, r7
 1799 0a22 80BD     		pop	{r7, pc}
 1800              		.cfi_endproc
 1801              	.LFE128:
 1803              		.section	.rodata
 1804 0105 000000   		.align	2
 1805              	.LC4:
 1806 0108 41583132 		.ascii	"AX12: Error: in AX12_status_packet_calc_checksum():"
 1806      3A204572 
 1806      726F723A 
 1806      20696E20 
 1806      41583132 
 1807 013b 20706171 		.ascii	" paquet trop petit\000"
 1807      75657420 
 1807      74726F70 
 1807      20706574 
 1807      697400
 1808 014e 0000     		.align	2
 1809              	.LC5:
 1810 0150 41583132 		.ascii	"AX12: Error: AX12_status_packet_calc_checksum(): pa"
 1810      3A204572 
 1810      726F723A 
 1810      20415831 
 1810      325F7374 
 1811 0183 71756574 		.ascii	"quet trop grand\000"
 1811      2074726F 
 1811      70206772 
 1811      616E6400 
 1812              		.text
 1813              		.align	2
 1814              		.thumb
 1815              		.thumb_func
 1817              	AX12_status_packet_calc_checksum:
 1818              	.LFB129:
 707:../QS/QS_ax12.c **** 
 708:../QS/QS_ax12.c **** #ifdef AX12_STATUS_RETURN_CHECK_CHECKSUM
 709:../QS/QS_ax12.c **** static Uint8 AX12_status_packet_calc_checksum(AX12_status_packet_t* status_packet) {
 1819              		.loc 2 709 0
 1820              		.cfi_startproc
 1821              		@ args = 0, pretend = 0, frame = 16
 1822              		@ frame_needed = 1, uses_anonymous_args = 0
 1823 0a24 80B5     		push	{r7, lr}
 1824              	.LCFI59:
 1825              		.cfi_def_cfa_offset 8
 1826              		.cfi_offset 7, -8
 1827              		.cfi_offset 14, -4
 1828 0a26 84B0     		sub	sp, sp, #16
 1829              	.LCFI60:
 1830              		.cfi_def_cfa_offset 24
 1831 0a28 00AF     		add	r7, sp, #0
 1832              	.LCFI61:
 1833              		.cfi_def_cfa_register 7
 1834 0a2a 7860     		str	r0, [r7, #4]
 710:../QS/QS_ax12.c **** 	Uint8 checksum = 0;
 1835              		.loc 2 710 0
 1836 0a2c 4FF00003 		mov	r3, #0
 1837 0a30 FB73     		strb	r3, [r7, #15]
 711:../QS/QS_ax12.c **** 	Uint8 packet_length = status_packet->size - 4;
 1838              		.loc 2 711 0
 1839 0a32 7B68     		ldr	r3, [r7, #4]
 1840 0a34 1B79     		ldrb	r3, [r3, #4]	@ zero_extendqisi2
 1841 0a36 A3F10403 		sub	r3, r3, #4
 1842 0a3a BB73     		strb	r3, [r7, #14]
 712:../QS/QS_ax12.c **** 
 713:../QS/QS_ax12.c **** 	if(status_packet->size < 6)
 1843              		.loc 2 713 0
 1844 0a3c 7B68     		ldr	r3, [r7, #4]
 1845 0a3e 1B79     		ldrb	r3, [r3, #4]	@ zero_extendqisi2
 1846 0a40 052B     		cmp	r3, #5
 1847 0a42 07D8     		bhi	.L111
 714:../QS/QS_ax12.c **** 		debug_printf("AX12: Error: in AX12_status_packet_calc_checksum(): paquet trop petit");
 1848              		.loc 2 714 0
 1849 0a44 4FF00500 		mov	r0, #5
 1850 0a48 40F20001 		movw	r1, #:lower16:.LC4
 1851 0a4c C0F20001 		movt	r1, #:upper16:.LC4
 1852 0a50 FFF7FEFF 		bl	OUTPUTLOG_printf
 1853              	.L111:
 715:../QS/QS_ax12.c **** 
 716:../QS/QS_ax12.c **** 	//packet_length est forcment >= 2 (voir datasheet de l'ax12)
 717:../QS/QS_ax12.c **** 	//PAS de break, si il y a 2 paramtre, on fait toutes les additions
 718:../QS/QS_ax12.c **** 	switch(packet_length) {
 1854              		.loc 2 718 0
 1855 0a54 BB7B     		ldrb	r3, [r7, #14]	@ zero_extendqisi2
 1856 0a56 032B     		cmp	r3, #3
 1857 0a58 09D0     		beq	.L114
 1858 0a5a 042B     		cmp	r3, #4
 1859 0a5c 02D0     		beq	.L115
 1860 0a5e 022B     		cmp	r3, #2
 1861 0a60 0AD0     		beq	.L113
 1862 0a62 16E0     		b	.L118
 1863              	.L115:
 719:../QS/QS_ax12.c **** 		case 4:	//2 paramtres
 720:../QS/QS_ax12.c **** 			checksum += status_packet->param_2;
 1864              		.loc 2 720 0
 1865 0a64 7B68     		ldr	r3, [r7, #4]
 1866 0a66 DA78     		ldrb	r2, [r3, #3]	@ zero_extendqisi2
 1867 0a68 FB7B     		ldrb	r3, [r7, #15]
 1868 0a6a D318     		adds	r3, r2, r3
 1869 0a6c FB73     		strb	r3, [r7, #15]
 1870              	.L114:
 721:../QS/QS_ax12.c **** 		case 3:	//1 paramtre
 722:../QS/QS_ax12.c **** 			checksum += status_packet->param_1;
 1871              		.loc 2 722 0
 1872 0a6e 7B68     		ldr	r3, [r7, #4]
 1873 0a70 9A78     		ldrb	r2, [r3, #2]	@ zero_extendqisi2
 1874 0a72 FB7B     		ldrb	r3, [r7, #15]
 1875 0a74 D318     		adds	r3, r2, r3
 1876 0a76 FB73     		strb	r3, [r7, #15]
 1877              	.L113:
 723:../QS/QS_ax12.c **** 		case 2:	//pas de paramtre
 724:../QS/QS_ax12.c **** 			checksum += status_packet->id_servo + packet_length + status_packet->error;
 1878              		.loc 2 724 0
 1879 0a78 7B68     		ldr	r3, [r7, #4]
 1880 0a7a 1A78     		ldrb	r2, [r3, #0]	@ zero_extendqisi2
 1881 0a7c BB7B     		ldrb	r3, [r7, #14]
 1882 0a7e D318     		adds	r3, r2, r3
 1883 0a80 DAB2     		uxtb	r2, r3
 1884 0a82 7B68     		ldr	r3, [r7, #4]
 1885 0a84 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 1886 0a86 D318     		adds	r3, r2, r3
 1887 0a88 DAB2     		uxtb	r2, r3
 1888 0a8a FB7B     		ldrb	r3, [r7, #15]
 1889 0a8c D318     		adds	r3, r2, r3
 1890 0a8e FB73     		strb	r3, [r7, #15]
 725:../QS/QS_ax12.c **** 			break;
 1891              		.loc 2 725 0
 1892 0a90 07E0     		b	.L116
 1893              	.L118:
 726:../QS/QS_ax12.c **** 
 727:../QS/QS_ax12.c **** 		default:
 728:../QS/QS_ax12.c **** 			debug_printf("AX12: Error: AX12_status_packet_calc_checksum(): paquet trop grand");
 1894              		.loc 2 728 0
 1895 0a92 4FF00500 		mov	r0, #5
 1896 0a96 40F20001 		movw	r1, #:lower16:.LC5
 1897 0a9a C0F20001 		movt	r1, #:upper16:.LC5
 1898 0a9e FFF7FEFF 		bl	OUTPUTLOG_printf
 1899              	.L116:
 729:../QS/QS_ax12.c **** 	}
 730:../QS/QS_ax12.c **** 
 731:../QS/QS_ax12.c **** 	return ~checksum;
 1900              		.loc 2 731 0
 1901 0aa2 FB7B     		ldrb	r3, [r7, #15]
 1902 0aa4 6FEA0303 		mvn	r3, r3
 1903 0aa8 DBB2     		uxtb	r3, r3
 732:../QS/QS_ax12.c **** }
 1904              		.loc 2 732 0
 1905 0aaa 1846     		mov	r0, r3
 1906 0aac 07F11007 		add	r7, r7, #16
 1907 0ab0 BD46     		mov	sp, r7
 1908 0ab2 80BD     		pop	{r7, pc}
 1909              		.cfi_endproc
 1910              	.LFE129:
 1912              		.section	.rodata
 1913 0193 00       		.align	2
 1914              	.LC6:
 1915 0194 41583132 		.ascii	"AX12[%d]: invalid checksum\012\000"
 1915      5B25645D 
 1915      3A20696E 
 1915      76616C69 
 1915      64206368 
 1916              		.align	2
 1917              	.LC7:
 1918 01b0 41583132 		.ascii	"AX12: Error: AX12_update_status_packet(): trop d'oc"
 1918      3A204572 
 1918      726F723A 
 1918      20415831 
 1918      325F7570 
 1919 01e3 74657420 		.ascii	"tet re\347u > 6\012\000"
 1919      7265E775 
 1919      203E2036 
 1919      0A00
 1920              		.text
 1921              		.align	2
 1922              		.thumb
 1923              		.thumb_func
 1925              	AX12_update_status_packet:
 1926              	.LFB130:
 733:../QS/QS_ax12.c **** #endif
 734:../QS/QS_ax12.c **** 
 735:../QS/QS_ax12.c **** static bool_e AX12_update_status_packet(Uint8 receive_byte, Uint8 byte_offset, AX12_status_packet_t
 736:../QS/QS_ax12.c **** {
 1927              		.loc 2 736 0
 1928              		.cfi_startproc
 1929              		@ args = 0, pretend = 0, frame = 8
 1930              		@ frame_needed = 1, uses_anonymous_args = 0
 1931 0ab4 80B5     		push	{r7, lr}
 1932              	.LCFI62:
 1933              		.cfi_def_cfa_offset 8
 1934              		.cfi_offset 7, -8
 1935              		.cfi_offset 14, -4
 1936 0ab6 82B0     		sub	sp, sp, #8
 1937              	.LCFI63:
 1938              		.cfi_def_cfa_offset 16
 1939 0ab8 00AF     		add	r7, sp, #0
 1940              	.LCFI64:
 1941              		.cfi_def_cfa_register 7
 1942 0aba 0B46     		mov	r3, r1
 1943 0abc 3A60     		str	r2, [r7, #0]
 1944 0abe 0246     		mov	r2, r0
 1945 0ac0 FA71     		strb	r2, [r7, #7]
 1946 0ac2 BB71     		strb	r3, [r7, #6]
 737:../QS/QS_ax12.c **** 	//Si c'est le dernier octet, verifier le checksum si AX12_STATUS_RETURN_CHECK_CHECKSUM est defini
 738:../QS/QS_ax12.c **** 	if(byte_offset > 3 && byte_offset == status_packet->size - 1) {
 1947              		.loc 2 738 0
 1948 0ac4 BB79     		ldrb	r3, [r7, #6]	@ zero_extendqisi2
 1949 0ac6 032B     		cmp	r3, #3
 1950 0ac8 1ED9     		bls	.L120
 1951              		.loc 2 738 0 is_stmt 0 discriminator 1
 1952 0aca BA79     		ldrb	r2, [r7, #6]	@ zero_extendqisi2
 1953 0acc 3B68     		ldr	r3, [r7, #0]
 1954 0ace 1B79     		ldrb	r3, [r3, #4]	@ zero_extendqisi2
 1955 0ad0 03F1FF33 		add	r3, r3, #-1
 1956 0ad4 9A42     		cmp	r2, r3
 1957 0ad6 17D1     		bne	.L120
 739:../QS/QS_ax12.c **** 	#ifdef AX12_STATUS_RETURN_CHECK_CHECKSUM
 740:../QS/QS_ax12.c **** 		if(receive_byte != AX12_status_packet_calc_checksum(status_packet)) {
 1958              		.loc 2 740 0 is_stmt 1
 1959 0ad8 3868     		ldr	r0, [r7, #0]
 1960 0ada FFF7A3FF 		bl	AX12_status_packet_calc_checksum
 1961 0ade 0346     		mov	r3, r0
 1962 0ae0 FA79     		ldrb	r2, [r7, #7]	@ zero_extendqisi2
 1963 0ae2 9A42     		cmp	r2, r3
 1964 0ae4 0DD0     		beq	.L121
 741:../QS/QS_ax12.c **** 			debug_printf("AX12[%d]: invalid checksum\n", status_packet->id_servo);
 1965              		.loc 2 741 0
 1966 0ae6 3B68     		ldr	r3, [r7, #0]
 1967 0ae8 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 1968 0aea 4FF00500 		mov	r0, #5
 1969 0aee 40F20001 		movw	r1, #:lower16:.LC6
 1970 0af2 C0F20001 		movt	r1, #:upper16:.LC6
 1971 0af6 1A46     		mov	r2, r3
 1972 0af8 FFF7FEFF 		bl	OUTPUTLOG_printf
 742:../QS/QS_ax12.c **** 			return FALSE;
 1973              		.loc 2 742 0
 1974 0afc 4FF00003 		mov	r3, #0
 1975 0b00 5AE0     		b	.L122
 1976              	.L121:
 743:../QS/QS_ax12.c **** 		} else return TRUE;
 1977              		.loc 2 743 0
 1978 0b02 4FF00103 		mov	r3, #1
 1979 0b06 57E0     		b	.L122
 1980              	.L120:
 744:../QS/QS_ax12.c **** 	#else
 745:../QS/QS_ax12.c **** 		return TRUE;
 746:../QS/QS_ax12.c **** 	#endif
 747:../QS/QS_ax12.c **** 	}
 748:../QS/QS_ax12.c **** 
 749:../QS/QS_ax12.c **** 	//mise a jour de la structure instruction avec les octets reus
 750:../QS/QS_ax12.c **** 	switch(byte_offset)
 1981              		.loc 2 750 0
 1982 0b08 BB79     		ldrb	r3, [r7, #6]	@ zero_extendqisi2
 1983 0b0a 062B     		cmp	r3, #6
 1984 0b0c 43D8     		bhi	.L123
 1985 0b0e 01A2     		adr	r2, .L131
 1986 0b10 52F823F0 		ldr	pc, [r2, r3, lsl #2]
 1987              		.align	2
 1988              	.L131:
 1989 0b14 310B0000 		.word	.L124+1
 1990 0b18 5D0B0000 		.word	.L125+1
 1991 0b1c 690B0000 		.word	.L126+1
 1992 0b20 710B0000 		.word	.L127+1
 1993 0b24 7F0B0000 		.word	.L128+1
 1994 0b28 870B0000 		.word	.L129+1
 1995 0b2c 8F0B0000 		.word	.L130+1
 1996              	.L124:
 751:../QS/QS_ax12.c **** 	{
 752:../QS/QS_ax12.c **** 		case 0:
 753:../QS/QS_ax12.c **** 			//Initialisation de a structure a des valeurs par dfaut
 754:../QS/QS_ax12.c **** 			status_packet->id_servo = 0;
 1997              		.loc 2 754 0
 1998 0b30 3B68     		ldr	r3, [r7, #0]
 1999 0b32 4FF00002 		mov	r2, #0
 2000 0b36 1A70     		strb	r2, [r3, #0]
 755:../QS/QS_ax12.c **** 			status_packet->size = 0;
 2001              		.loc 2 755 0
 2002 0b38 3B68     		ldr	r3, [r7, #0]
 2003 0b3a 4FF00002 		mov	r2, #0
 2004 0b3e 1A71     		strb	r2, [r3, #4]
 756:../QS/QS_ax12.c **** 			status_packet->error = 0;
 2005              		.loc 2 756 0
 2006 0b40 3B68     		ldr	r3, [r7, #0]
 2007 0b42 4FF00002 		mov	r2, #0
 2008 0b46 5A70     		strb	r2, [r3, #1]
 757:../QS/QS_ax12.c **** 			status_packet->param = 0;
 2009              		.loc 2 757 0
 2010 0b48 3B68     		ldr	r3, [r7, #0]
 2011 0b4a 4FF00002 		mov	r2, #0
 2012 0b4e 5A80     		strh	r2, [r3, #2]	@ movhi
 758:../QS/QS_ax12.c **** 
 759:../QS/QS_ax12.c **** 			if(receive_byte != 0xFF)
 2013              		.loc 2 759 0
 2014 0b50 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 2015 0b52 FF2B     		cmp	r3, #255
 2016 0b54 2BD0     		beq	.L135
 760:../QS/QS_ax12.c **** 				return FALSE;
 2017              		.loc 2 760 0
 2018 0b56 4FF00003 		mov	r3, #0
 2019 0b5a 2DE0     		b	.L122
 2020              	.L125:
 761:../QS/QS_ax12.c **** 			break;
 762:../QS/QS_ax12.c **** 
 763:../QS/QS_ax12.c **** 		case 1:
 764:../QS/QS_ax12.c **** 			if(receive_byte != 0xFF)
 2021              		.loc 2 764 0
 2022 0b5c FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 2023 0b5e FF2B     		cmp	r3, #255
 2024 0b60 27D0     		beq	.L136
 765:../QS/QS_ax12.c **** 				return FALSE;
 2025              		.loc 2 765 0
 2026 0b62 4FF00003 		mov	r3, #0
 2027 0b66 27E0     		b	.L122
 2028              	.L126:
 766:../QS/QS_ax12.c **** 			break;
 767:../QS/QS_ax12.c **** 
 768:../QS/QS_ax12.c **** 		case 2:
 769:../QS/QS_ax12.c **** 			status_packet->id_servo = receive_byte;
 2029              		.loc 2 769 0
 2030 0b68 3B68     		ldr	r3, [r7, #0]
 2031 0b6a FA79     		ldrb	r2, [r7, #7]
 2032 0b6c 1A70     		strb	r2, [r3, #0]
 770:../QS/QS_ax12.c **** 			break;
 2033              		.loc 2 770 0
 2034 0b6e 21E0     		b	.L133
 2035              	.L127:
 771:../QS/QS_ax12.c **** 
 772:../QS/QS_ax12.c **** 		case 3:
 773:../QS/QS_ax12.c **** 			status_packet->size = receive_byte + 4;
 2036              		.loc 2 773 0
 2037 0b70 FB79     		ldrb	r3, [r7, #7]
 2038 0b72 03F10403 		add	r3, r3, #4
 2039 0b76 DAB2     		uxtb	r2, r3
 2040 0b78 3B68     		ldr	r3, [r7, #0]
 2041 0b7a 1A71     		strb	r2, [r3, #4]
 774:../QS/QS_ax12.c **** 			break;
 2042              		.loc 2 774 0
 2043 0b7c 1AE0     		b	.L133
 2044              	.L128:
 775:../QS/QS_ax12.c **** 
 776:../QS/QS_ax12.c **** 		case 4:
 777:../QS/QS_ax12.c **** 			status_packet->error = receive_byte;
 2045              		.loc 2 777 0
 2046 0b7e 3B68     		ldr	r3, [r7, #0]
 2047 0b80 FA79     		ldrb	r2, [r7, #7]
 2048 0b82 5A70     		strb	r2, [r3, #1]
 778:../QS/QS_ax12.c **** 			break;
 2049              		.loc 2 778 0
 2050 0b84 16E0     		b	.L133
 2051              	.L129:
 779:../QS/QS_ax12.c **** 
 780:../QS/QS_ax12.c **** 		case 5:
 781:../QS/QS_ax12.c **** 			status_packet->param_1 = receive_byte;
 2052              		.loc 2 781 0
 2053 0b86 3B68     		ldr	r3, [r7, #0]
 2054 0b88 FA79     		ldrb	r2, [r7, #7]
 2055 0b8a 9A70     		strb	r2, [r3, #2]
 782:../QS/QS_ax12.c **** 			break;
 2056              		.loc 2 782 0
 2057 0b8c 12E0     		b	.L133
 2058              	.L130:
 783:../QS/QS_ax12.c **** 
 784:../QS/QS_ax12.c **** 		case 6:
 785:../QS/QS_ax12.c **** 			status_packet->param_2 = receive_byte;
 2059              		.loc 2 785 0
 2060 0b8e 3B68     		ldr	r3, [r7, #0]
 2061 0b90 FA79     		ldrb	r2, [r7, #7]
 2062 0b92 DA70     		strb	r2, [r3, #3]
 786:../QS/QS_ax12.c **** 			break;
 2063              		.loc 2 786 0
 2064 0b94 0EE0     		b	.L133
 2065              	.L123:
 787:../QS/QS_ax12.c **** 
 788:../QS/QS_ax12.c **** 		default:
 789:../QS/QS_ax12.c **** 			if(byte_offset > 6)
 2066              		.loc 2 789 0
 2067 0b96 BB79     		ldrb	r3, [r7, #6]	@ zero_extendqisi2
 2068 0b98 062B     		cmp	r3, #6
 2069 0b9a 0BD9     		bls	.L133
 790:../QS/QS_ax12.c **** 				debug_printf("AX12: Error: AX12_update_status_packet(): trop d'octet reu > 6\n");
 2070              		.loc 2 790 0
 2071 0b9c 4FF00500 		mov	r0, #5
 2072 0ba0 40F20001 		movw	r1, #:lower16:.LC7
 2073 0ba4 C0F20001 		movt	r1, #:upper16:.LC7
 2074 0ba8 FFF7FEFF 		bl	OUTPUTLOG_printf
 2075 0bac 02E0     		b	.L133
 2076              	.L135:
 761:../QS/QS_ax12.c **** 			break;
 2077              		.loc 2 761 0
 2078 0bae 00BF     		nop
 2079 0bb0 00E0     		b	.L133
 2080              	.L136:
 766:../QS/QS_ax12.c **** 			break;
 2081              		.loc 2 766 0
 2082 0bb2 00BF     		nop
 2083              	.L133:
 791:../QS/QS_ax12.c **** 	}
 792:../QS/QS_ax12.c **** 
 793:../QS/QS_ax12.c **** 	return TRUE;
 2084              		.loc 2 793 0
 2085 0bb4 4FF00103 		mov	r3, #1
 2086              	.L122:
 794:../QS/QS_ax12.c **** }
 2087              		.loc 2 794 0
 2088 0bb8 1846     		mov	r0, r3
 2089 0bba 07F10807 		add	r7, r7, #8
 2090 0bbe BD46     		mov	sp, r7
 2091 0bc0 80BD     		pop	{r7, pc}
 2092              		.cfi_endproc
 2093              	.LFE130:
 2095              		.section	.rodata
 2096 01f1 000000   		.align	2
 2097              	.LC8:
 2098 01f4 41583132 		.ascii	"AX12[%d]: send timeout !!\012\000"
 2098      5B25645D 
 2098      3A207365 
 2098      6E642074 
 2098      696D656F 
 2099 020f 00       		.align	2
 2100              	.LC9:
 2101 0210 57726F6E 		.ascii	"Wrong servo ID: %d instead of %d\012\000"
 2101      67207365 
 2101      72766F20 
 2101      49443A20 
 2101      25642069 
 2102 0232 0000     		.align	2
 2103              	.LC10:
 2104 0234 41583132 		.ascii	"AX12[%d] timeout Rx:\000"
 2104      5B25645D 
 2104      2074696D 
 2104      656F7574 
 2104      2052783A 
 2105 0249 000000   		.align	2
 2106              	.LC11:
 2107 024c 41583132 		.ascii	"AX12 timeout too small\012\000"
 2107      2074696D 
 2107      656F7574 
 2107      20746F6F 
 2107      20736D61 
 2108              		.text
 2109 0bc2 00BF     		.align	2
 2110              		.thumb
 2111              		.thumb_func
 2113              	AX12_state_machine:
 2114              	.LFB131:
 795:../QS/QS_ax12.c **** 
 796:../QS/QS_ax12.c **** //La machine a tats est appele par les interruptions de l'UART et par le timer
 797:../QS/QS_ax12.c **** static void AX12_state_machine(AX12_state_machine_event_e event) {
 2115              		.loc 2 797 0
 2116              		.cfi_startproc
 2117              		@ args = 0, pretend = 0, frame = 16
 2118              		@ frame_needed = 1, uses_anonymous_args = 0
 2119 0bc4 90B5     		push	{r4, r7, lr}
 2120              	.LCFI65:
 2121              		.cfi_def_cfa_offset 12
 2122              		.cfi_offset 4, -12
 2123              		.cfi_offset 7, -8
 2124              		.cfi_offset 14, -4
 2125 0bc6 85B0     		sub	sp, sp, #20
 2126              	.LCFI66:
 2127              		.cfi_def_cfa_offset 32
 2128 0bc8 00AF     		add	r7, sp, #0
 2129              	.LCFI67:
 2130              		.cfi_def_cfa_register 7
 2131 0bca 0346     		mov	r3, r0
 2132 0bcc FB71     		strb	r3, [r7, #7]
 798:../QS/QS_ax12.c **** 	static volatile int processing_state = 0;
 799:../QS/QS_ax12.c **** 
 800:../QS/QS_ax12.c **** 	#if defined(VERBOSE_MODE) && defined(AX12_DEBUG_PACKETS)
 801:../QS/QS_ax12.c **** 		//Pour le deboggage (avec debug_printf  la fin de l'envoi/reception d'un paquet)
 802:../QS/QS_ax12.c **** 		static Uint8 AX12_UART2_reception_buffer[MAX_STATUS_PACKET_SIZE*2] = {0};
 803:../QS/QS_ax12.c **** 		Uint8 i, pos;
 804:../QS/QS_ax12.c **** 	#endif
 805:../QS/QS_ax12.c **** 
 806:../QS/QS_ax12.c **** //scurisation des appels  cette fonction lorsque event == AX12_SME_NoEvent pour eviter que l'tat
 807:../QS/QS_ax12.c **** //si une IT arrive a un certain moment, elle sera execute compltement, donc processing_state revi
 808:../QS/QS_ax12.c **** 	if(event == AX12_SME_NoEvent) {
 2133              		.loc 2 808 0
 2134 0bce FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 2135 0bd0 002B     		cmp	r3, #0
 2136 0bd2 0FD1     		bne	.L138
 809:../QS/QS_ax12.c **** //1) Si une IT arrive a ce moment, elle s'execute entirement et change l'tat de AX12_SMS_ReadyToS
 810:../QS/QS_ax12.c **** 		if(processing_state > 0)
 2137              		.loc 2 810 0
 2138 0bd4 40F20003 		movw	r3, #:lower16:processing_state.6601
 2139 0bd8 C0F20003 		movt	r3, #:upper16:processing_state.6601
 2140 0bdc 1B68     		ldr	r3, [r3, #0]
 2141 0bde 002B     		cmp	r3, #0
 2142 0be0 00F37683 		bgt	.L180
 2143              	.L139:
 811:../QS/QS_ax12.c **** //2) Si une IT arrive a ce moment, elle s'executera pas, elle retournera sans rien faire car proces
 812:../QS/QS_ax12.c **** 			return;
 813:../QS/QS_ax12.c **** //3) Si une IT arrive a ce moment, elle s'executera entirement car processing_state == 0, l'tat p
 814:../QS/QS_ax12.c **** 		processing_state = 1;
 2144              		.loc 2 814 0
 2145 0be4 40F20003 		movw	r3, #:lower16:processing_state.6601
 2146 0be8 C0F20003 		movt	r3, #:upper16:processing_state.6601
 2147 0bec 4FF00102 		mov	r2, #1
 2148 0bf0 1A60     		str	r2, [r3, #0]
 2149 0bf2 0FE0     		b	.L141
 2150              	.L138:
 815:../QS/QS_ax12.c **** //4) Si une IT arrive a ce moment, elle ne s'executera pas car processing_state > 0
 816:../QS/QS_ax12.c **** 	} else if(event == AX12_SME_Timeout) {
 2151              		.loc 2 816 0
 2152 0bf4 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 2153 0bf6 032B     		cmp	r3, #3
 2154 0bf8 04D1     		bne	.L142
 817:../QS/QS_ax12.c **** 		NVIC_DisableIRQ(AX12_UART_Interrupt_IRQn);
 2155              		.loc 2 817 0
 2156 0bfa 4FF02600 		mov	r0, #38
 2157 0bfe FFF71BFA 		bl	NVIC_DisableIRQ
 2158 0c02 07E0     		b	.L141
 2159              	.L142:
 818:../QS/QS_ax12.c **** 	} else if(event == AX12_SME_RxInterrupt || event == AX12_SME_TxInterrupt) {
 2160              		.loc 2 818 0
 2161 0c04 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 2162 0c06 012B     		cmp	r3, #1
 2163 0c08 02D0     		beq	.L143
 2164              		.loc 2 818 0 is_stmt 0 discriminator 1
 2165 0c0a FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 2166 0c0c 022B     		cmp	r3, #2
 2167 0c0e 01D1     		bne	.L141
 2168              	.L143:
 819:../QS/QS_ax12.c **** 		TIMER_SRC_TIMER_DisableIT();
 2169              		.loc 2 819 0 is_stmt 1
 2170 0c10 FFF7FEFF 		bl	TIMER2_disableInt
 2171              	.L141:
 820:../QS/QS_ax12.c **** 	}
 821:../QS/QS_ax12.c **** 
 822:../QS/QS_ax12.c **** //Si une IT arrive avec event == AX12_SME_TxInterrupt, elle n'aura un effet que dans l'tat AX12_SM
 823:../QS/QS_ax12.c **** //Si une IT arrive avec event == AX12_SME_RxInterrupt, elle n'aura un effet que dans l'tat AX12_SM
 824:../QS/QS_ax12.c **** 
 825:../QS/QS_ax12.c **** 	switch(state_machine.state)
 2172              		.loc 2 825 0
 2173 0c14 40F20003 		movw	r3, #:lower16:state_machine
 2174 0c18 C0F20003 		movt	r3, #:upper16:state_machine
 2175 0c1c 1B78     		ldrb	r3, [r3, #0]
 2176 0c1e DBB2     		uxtb	r3, r3
 2177 0c20 012B     		cmp	r3, #1
 2178 0c22 00F09580 		beq	.L146
 2179 0c26 022B     		cmp	r3, #2
 2180 0c28 00F09C81 		beq	.L147
 2181 0c2c 002B     		cmp	r3, #0
 2182 0c2e 40F03383 		bne	.L144
 2183              	.L145:
 826:../QS/QS_ax12.c **** 	{
 827:../QS/QS_ax12.c **** 		case AX12_SMS_ReadyToSend:
 828:../QS/QS_ax12.c **** 			if(event == AX12_SME_NoEvent)
 2184              		.loc 2 828 0
 2185 0c32 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 2186 0c34 002B     		cmp	r3, #0
 2187 0c36 40F02A83 		bne	.L181
 829:../QS/QS_ax12.c **** 			{
 830:../QS/QS_ax12.c **** 				// Choix du paquet  envoyer et dbut d'envoi
 831:../QS/QS_ax12.c **** 				if(!AX12_instruction_queue_is_empty())
 2188              		.loc 2 831 0
 2189 0c3a 40F20003 		movw	r3, #:lower16:AX12_special_instruction_buffer
 2190 0c3e C0F20003 		movt	r3, #:upper16:AX12_special_instruction_buffer
 2191 0c42 93F84936 		ldrb	r3, [r3, #1609]
 2192 0c46 DAB2     		uxtb	r2, r3
 2193 0c48 40F20003 		movw	r3, #:lower16:AX12_special_instruction_buffer
 2194 0c4c C0F20003 		movt	r3, #:upper16:AX12_special_instruction_buffer
 2195 0c50 93F84836 		ldrb	r3, [r3, #1608]
 2196 0c54 DBB2     		uxtb	r3, r3
 2197 0c56 9A42     		cmp	r2, r3
 2198 0c58 65D0     		beq	.L182
 832:../QS/QS_ax12.c **** 					state_machine.current_instruction = AX12_instruction_queue_get_current();
 2199              		.loc 2 832 0
 2200 0c5a 40F20003 		movw	r3, #:lower16:AX12_special_instruction_buffer
 2201 0c5e C0F20003 		movt	r3, #:upper16:AX12_special_instruction_buffer
 2202 0c62 93F84836 		ldrb	r3, [r3, #1608]
 2203 0c66 DBB2     		uxtb	r3, r3
 2204 0c68 1946     		mov	r1, r3
 2205 0c6a 40F20003 		movw	r3, #:lower16:state_machine
 2206 0c6e C0F20003 		movt	r3, #:upper16:state_machine
 2207 0c72 40F20002 		movw	r2, #:lower16:AX12_special_instruction_buffer
 2208 0c76 C0F20002 		movt	r2, #:upper16:AX12_special_instruction_buffer
 2209 0c7a 03F10404 		add	r4, r3, #4
 2210 0c7e 4FEAC103 		lsl	r3, r1, #3
 2211 0c82 D318     		adds	r3, r2, r3
 2212 0c84 93E80300 		ldmia	r3, {r0, r1}
 2213 0c88 84E80300 		stmia	r4, {r0, r1}
 833:../QS/QS_ax12.c **** 				else {	//s'il n'y a rien a faire, mettre en veille la machine a tat, l'UART sera donc inactif 
 834:../QS/QS_ax12.c **** 					while(!USART_GetFlagStatus(AX12_UART_Ptr, USART_FLAG_TC));
 835:../QS/QS_ax12.c **** 					AX12_DIRECTION_PORT = RX_DIRECTION;
 836:../QS/QS_ax12.c **** 					break;
 837:../QS/QS_ax12.c **** 				}
 838:../QS/QS_ax12.c **** 
 839:../QS/QS_ax12.c **** 				state_machine.state = AX12_SMS_Sending;
 2214              		.loc 2 839 0
 2215 0c8c 40F20003 		movw	r3, #:lower16:state_machine
 2216 0c90 C0F20003 		movt	r3, #:upper16:state_machine
 2217 0c94 4FF00102 		mov	r2, #1
 2218 0c98 1A70     		strb	r2, [r3, #0]
 840:../QS/QS_ax12.c **** 				state_machine.sending_index = 0;
 2219              		.loc 2 840 0
 2220 0c9a 40F20003 		movw	r3, #:lower16:state_machine
 2221 0c9e C0F20003 		movt	r3, #:upper16:state_machine
 2222 0ca2 4FF00002 		mov	r2, #0
 2223 0ca6 1A73     		strb	r2, [r3, #12]
 841:../QS/QS_ax12.c **** 				state_machine.receive_index = 0;
 2224              		.loc 2 841 0
 2225 0ca8 40F20003 		movw	r3, #:lower16:state_machine
 2226 0cac C0F20003 		movt	r3, #:upper16:state_machine
 2227 0cb0 4FF00002 		mov	r2, #0
 2228 0cb4 5A73     		strb	r2, [r3, #13]
 842:../QS/QS_ax12.c **** 
 843:../QS/QS_ax12.c **** 
 844:../QS/QS_ax12.c **** 				#if defined(VERBOSE_MODE) && defined(AX12_DEBUG_PACKETS)
 845:../QS/QS_ax12.c **** 					debug_printf("AX12 Tx:");
 846:../QS/QS_ax12.c **** 					for(i = 0; i<state_machine.current_instruction.size; i++)
 847:../QS/QS_ax12.c **** 						debug_printf(" %02x", AX12_get_instruction_packet(i, &state_machine.current_instruction));
 848:../QS/QS_ax12.c **** 					debug_printf("\n");
 849:../QS/QS_ax12.c **** 				#endif
 850:../QS/QS_ax12.c **** 
 851:../QS/QS_ax12.c **** 
 852:../QS/QS_ax12.c **** 				AX12_DIRECTION_PORT = TX_DIRECTION;
 2229              		.loc 2 852 0
 2230 0cb6 4FF48063 		mov	r3, #1024
 2231 0cba C4F20203 		movt	r3, 16386
 2232 0cbe 5A69     		ldr	r2, [r3, #20]
 2233 0cc0 42F40062 		orr	r2, r2, #2048
 2234 0cc4 5A61     		str	r2, [r3, #20]
 853:../QS/QS_ax12.c **** 
 854:../QS/QS_ax12.c **** 				TIMER_SRC_TIMER_start_ms(AX12_STATUS_SEND_TIMEOUT);	//Pour le timeout d'envoi, ne devrait pas a
 2235              		.loc 2 854 0
 2236 0cc6 4FF00A00 		mov	r0, #10
 2237 0cca FFF7FEFF 		bl	TIMER2_run
 855:../QS/QS_ax12.c **** 
 856:../QS/QS_ax12.c **** 				state_machine.sending_index++;	//Attention! Nous devons incrementer sending_index AVANT car il 
 2238              		.loc 2 856 0
 2239 0cce 40F20003 		movw	r3, #:lower16:state_machine
 2240 0cd2 C0F20003 		movt	r3, #:upper16:state_machine
 2241 0cd6 1B7B     		ldrb	r3, [r3, #12]	@ zero_extendqisi2
 2242 0cd8 03F10103 		add	r3, r3, #1
 2243 0cdc DAB2     		uxtb	r2, r3
 2244 0cde 40F20003 		movw	r3, #:lower16:state_machine
 2245 0ce2 C0F20003 		movt	r3, #:upper16:state_machine
 2246 0ce6 1A73     		strb	r2, [r3, #12]
 857:../QS/QS_ax12.c **** 
 858:../QS/QS_ax12.c **** 				USART_SendData(AX12_UART_Ptr, AX12_get_instruction_packet(state_machine.sending_index-1, &state
 2247              		.loc 2 858 0
 2248 0ce8 40F20003 		movw	r3, #:lower16:state_machine
 2249 0cec C0F20003 		movt	r3, #:upper16:state_machine
 2250 0cf0 1B7B     		ldrb	r3, [r3, #12]	@ zero_extendqisi2
 2251 0cf2 03F1FF33 		add	r3, r3, #-1
 2252 0cf6 DBB2     		uxtb	r3, r3
 2253 0cf8 1846     		mov	r0, r3
 2254 0cfa BC49     		ldr	r1, .L185
 2255 0cfc FFF740FE 		bl	AX12_get_instruction_packet
 2256 0d00 0346     		mov	r3, r0
 2257 0d02 4FF48840 		mov	r0, #17408
 2258 0d06 C4F20000 		movt	r0, 16384
 2259 0d0a 1946     		mov	r1, r3
 2260 0d0c FFF7FEFF 		bl	USART_SendData
 859:../QS/QS_ax12.c **** 				USART_ITConfig(AX12_UART_Ptr, USART_IT_TXE, ENABLE);
 2261              		.loc 2 859 0
 2262 0d10 4FF48840 		mov	r0, #17408
 2263 0d14 C4F20000 		movt	r0, 16384
 2264 0d18 40F22771 		movw	r1, #1831
 2265 0d1c 4FF00102 		mov	r2, #1
 2266 0d20 FFF7FEFF 		bl	USART_ITConfig
 860:../QS/QS_ax12.c **** 			} /*else if(event == AX12_SME_TxInterrupt) {
 861:../QS/QS_ax12.c **** 				USART_ITConfig(AX12_UART_Ptr, USART_IT_TXE, DISABLE);
 862:../QS/QS_ax12.c **** 			}*/
 863:../QS/QS_ax12.c **** 		break;
 2267              		.loc 2 863 0
 2268 0d24 B3E2     		b	.L181
 2269              	.L182:
 834:../QS/QS_ax12.c **** 					while(!USART_GetFlagStatus(AX12_UART_Ptr, USART_FLAG_TC));
 2270              		.loc 2 834 0
 2271 0d26 00BF     		nop
 2272              	.L150:
 834:../QS/QS_ax12.c **** 					while(!USART_GetFlagStatus(AX12_UART_Ptr, USART_FLAG_TC));
 2273              		.loc 2 834 0 is_stmt 0 discriminator 1
 2274 0d28 4FF48840 		mov	r0, #17408
 2275 0d2c C4F20000 		movt	r0, 16384
 2276 0d30 4FF04001 		mov	r1, #64
 2277 0d34 FFF7FEFF 		bl	USART_GetFlagStatus
 2278 0d38 0346     		mov	r3, r0
 2279 0d3a 002B     		cmp	r3, #0
 2280 0d3c F4D0     		beq	.L150
 835:../QS/QS_ax12.c **** 					AX12_DIRECTION_PORT = RX_DIRECTION;
 2281              		.loc 2 835 0 is_stmt 1
 2282 0d3e 4FF48063 		mov	r3, #1024
 2283 0d42 C4F20203 		movt	r3, 16386
 2284 0d46 5A69     		ldr	r2, [r3, #20]
 2285 0d48 6FF3CB22 		bfc	r2, #11, #1
 2286 0d4c 5A61     		str	r2, [r3, #20]
 836:../QS/QS_ax12.c **** 					break;
 2287              		.loc 2 836 0
 2288 0d4e A3E2     		b	.L144
 2289              	.L146:
 864:../QS/QS_ax12.c **** 
 865:../QS/QS_ax12.c **** 		case AX12_SMS_Sending:
 866:../QS/QS_ax12.c **** 			if(event == AX12_SME_TxInterrupt)
 2290              		.loc 2 866 0
 2291 0d50 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 2292 0d52 022B     		cmp	r3, #2
 2293 0d54 40F0AE80 		bne	.L151
 867:../QS/QS_ax12.c **** 			{
 868:../QS/QS_ax12.c **** 				if(state_machine.sending_index < state_machine.current_instruction.size) {
 2294              		.loc 2 868 0
 2295 0d58 40F20003 		movw	r3, #:lower16:state_machine
 2296 0d5c C0F20003 		movt	r3, #:upper16:state_machine
 2297 0d60 1A7B     		ldrb	r2, [r3, #12]	@ zero_extendqisi2
 2298 0d62 40F20003 		movw	r3, #:lower16:state_machine
 2299 0d66 C0F20003 		movt	r3, #:upper16:state_machine
 2300 0d6a 9B7A     		ldrb	r3, [r3, #10]	@ zero_extendqisi2
 2301 0d6c 9A42     		cmp	r2, r3
 2302 0d6e 1ED2     		bcs	.L152
 869:../QS/QS_ax12.c **** 					USART_SendData(AX12_UART_Ptr, AX12_get_instruction_packet(state_machine.sending_index, &state_
 2303              		.loc 2 869 0
 2304 0d70 40F20003 		movw	r3, #:lower16:state_machine
 2305 0d74 C0F20003 		movt	r3, #:upper16:state_machine
 2306 0d78 1B7B     		ldrb	r3, [r3, #12]	@ zero_extendqisi2
 2307 0d7a 1846     		mov	r0, r3
 2308 0d7c 9B49     		ldr	r1, .L185
 2309 0d7e FFF7FFFD 		bl	AX12_get_instruction_packet
 2310 0d82 0346     		mov	r3, r0
 2311 0d84 4FF48840 		mov	r0, #17408
 2312 0d88 C4F20000 		movt	r0, 16384
 2313 0d8c 1946     		mov	r1, r3
 2314 0d8e FFF7FEFF 		bl	USART_SendData
 870:../QS/QS_ax12.c **** 					state_machine.sending_index++;
 2315              		.loc 2 870 0
 2316 0d92 40F20003 		movw	r3, #:lower16:state_machine
 2317 0d96 C0F20003 		movt	r3, #:upper16:state_machine
 2318 0d9a 1B7B     		ldrb	r3, [r3, #12]	@ zero_extendqisi2
 2319 0d9c 03F10103 		add	r3, r3, #1
 2320 0da0 DAB2     		uxtb	r2, r3
 2321 0da2 40F20003 		movw	r3, #:lower16:state_machine
 2322 0da6 C0F20003 		movt	r3, #:upper16:state_machine
 2323 0daa 1A73     		strb	r2, [r3, #12]
 2324 0dac C6E0     		b	.L153
 2325              	.L152:
 871:../QS/QS_ax12.c **** 				}
 872:../QS/QS_ax12.c **** 				else	//Le dernier paquet a t envoy, passage en mode reception et attente de la rponse dans 
 873:../QS/QS_ax12.c **** 				{
 874:../QS/QS_ax12.c **** 					TIMER_SRC_TIMER_stop();
 2326              		.loc 2 874 0
 2327 0dae FFF7FEFF 		bl	TIMER2_stop
 875:../QS/QS_ax12.c **** 					TIMER_SRC_TIMER_resetFlag();
 2328              		.loc 2 875 0
 2329 0db2 4FF4C050 		mov	r0, #6144
 2330 0db6 C4F20000 		movt	r0, 16384
 2331 0dba 4FF00101 		mov	r1, #1
 2332 0dbe FFF7FEFF 		bl	TIM_ClearITPendingBit
 876:../QS/QS_ax12.c **** 
 877:../QS/QS_ax12.c **** 					if(AX12_instruction_has_status_packet(state_machine.current_instruction))
 2333              		.loc 2 877 0
 2334 0dc2 40F20003 		movw	r3, #:lower16:state_machine
 2335 0dc6 C0F20003 		movt	r3, #:upper16:state_machine
 2336 0dca 1B79     		ldrb	r3, [r3, #4]	@ zero_extendqisi2
 2337 0dcc FE2B     		cmp	r3, #254
 2338 0dce 47D0     		beq	.L154
 878:../QS/QS_ax12.c **** 					{
 879:../QS/QS_ax12.c **** 						#if defined(VERBOSE_MODE) && defined(AX12_DEBUG_PACKETS)
 880:../QS/QS_ax12.c **** 							for(i=0; i<MAX_STATUS_PACKET_SIZE*2; i++)
 881:../QS/QS_ax12.c **** 								AX12_UART2_reception_buffer[i] = 0;
 882:../QS/QS_ax12.c **** 							pos = 0;
 883:../QS/QS_ax12.c **** 						#endif
 884:../QS/QS_ax12.c **** 
 885:../QS/QS_ax12.c **** 						//Attente de la fin de la transmition des octets
 886:../QS/QS_ax12.c **** 						//TRMT passe a 1 quand tout est envoy (bit de stop inclu)
 887:../QS/QS_ax12.c **** 						//plus d'info ici: http://books.google.fr/books?id=ZNngQv_E0_MC&lpg=PA250&ots=_ZTiXKt-8p&hl=f
 888:../QS/QS_ax12.c **** 						while(!USART_GetFlagStatus(AX12_UART_Ptr, USART_FLAG_TC));
 2339              		.loc 2 888 0
 2340 0dd0 00BF     		nop
 2341              	.L155:
 2342              		.loc 2 888 0 is_stmt 0 discriminator 1
 2343 0dd2 4FF48840 		mov	r0, #17408
 2344 0dd6 C4F20000 		movt	r0, 16384
 2345 0dda 4FF04001 		mov	r1, #64
 2346 0dde FFF7FEFF 		bl	USART_GetFlagStatus
 2347 0de2 0346     		mov	r3, r0
 2348 0de4 002B     		cmp	r3, #0
 2349 0de6 F4D0     		beq	.L155
 889:../QS/QS_ax12.c **** 
 890:../QS/QS_ax12.c **** 						AX12_DIRECTION_PORT = RX_DIRECTION;
 2350              		.loc 2 890 0 is_stmt 1
 2351 0de8 4FF48063 		mov	r3, #1024
 2352 0dec C4F20203 		movt	r3, 16386
 2353 0df0 5A69     		ldr	r2, [r3, #20]
 2354 0df2 6FF3CB22 		bfc	r2, #11, #1
 2355 0df6 5A61     		str	r2, [r3, #20]
 891:../QS/QS_ax12.c **** 
 892:../QS/QS_ax12.c **** 						//flush recv buffer
 893:../QS/QS_ax12.c **** 						while(USART_GetFlagStatus(AX12_UART_Ptr, USART_FLAG_ORE) || USART_GetFlagStatus(AX12_UART_Ptr
 2356              		.loc 2 893 0
 2357 0df8 05E0     		b	.L156
 2358              	.L157:
 894:../QS/QS_ax12.c **** 							USART_ReceiveData(AX12_UART_Ptr);
 2359              		.loc 2 894 0
 2360 0dfa 4FF48840 		mov	r0, #17408
 2361 0dfe C4F20000 		movt	r0, 16384
 2362 0e02 FFF7FEFF 		bl	USART_ReceiveData
 2363              	.L156:
 893:../QS/QS_ax12.c **** 						while(USART_GetFlagStatus(AX12_UART_Ptr, USART_FLAG_ORE) || USART_GetFlagStatus(AX12_UART_Ptr
 2364              		.loc 2 893 0 discriminator 1
 2365 0e06 4FF48840 		mov	r0, #17408
 2366 0e0a C4F20000 		movt	r0, 16384
 2367 0e0e 4FF00801 		mov	r1, #8
 2368 0e12 FFF7FEFF 		bl	USART_GetFlagStatus
 2369 0e16 0346     		mov	r3, r0
 2370 0e18 002B     		cmp	r3, #0
 2371 0e1a EED1     		bne	.L157
 893:../QS/QS_ax12.c **** 						while(USART_GetFlagStatus(AX12_UART_Ptr, USART_FLAG_ORE) || USART_GetFlagStatus(AX12_UART_Ptr
 2372              		.loc 2 893 0 is_stmt 0 discriminator 2
 2373 0e1c 4FF48840 		mov	r0, #17408
 2374 0e20 C4F20000 		movt	r0, 16384
 2375 0e24 4FF00201 		mov	r1, #2
 2376 0e28 FFF7FEFF 		bl	USART_GetFlagStatus
 2377 0e2c 0346     		mov	r3, r0
 2378 0e2e 002B     		cmp	r3, #0
 2379 0e30 E3D1     		bne	.L157
 893:../QS/QS_ax12.c **** 						while(USART_GetFlagStatus(AX12_UART_Ptr, USART_FLAG_ORE) || USART_GetFlagStatus(AX12_UART_Ptr
 2380              		.loc 2 893 0 discriminator 1
 2381 0e32 4FF48840 		mov	r0, #17408
 2382 0e36 C4F20000 		movt	r0, 16384
 2383 0e3a 4FF00401 		mov	r1, #4
 2384 0e3e FFF7FEFF 		bl	USART_GetFlagStatus
 2385 0e42 0346     		mov	r3, r0
 2386 0e44 002B     		cmp	r3, #0
 2387 0e46 D8D1     		bne	.L157
 895:../QS/QS_ax12.c **** 
 896:../QS/QS_ax12.c **** 						state_machine.state = AX12_SMS_WaitingAnswer;
 2388              		.loc 2 896 0 is_stmt 1
 2389 0e48 40F20003 		movw	r3, #:lower16:state_machine
 2390 0e4c C0F20003 		movt	r3, #:upper16:state_machine
 2391 0e50 4FF00202 		mov	r2, #2
 2392 0e54 1A70     		strb	r2, [r3, #0]
 897:../QS/QS_ax12.c **** 
 898:../QS/QS_ax12.c **** 						TIMER_SRC_TIMER_start_ms(AX12_STATUS_RETURN_TIMEOUT);	//Pour le timeout de reception, ne devr
 2393              		.loc 2 898 0
 2394 0e56 4FF03200 		mov	r0, #50
 2395 0e5a FFF7FEFF 		bl	TIMER2_run
 2396 0e5e 6DE0     		b	.L153
 2397              	.L154:
 899:../QS/QS_ax12.c **** 					}
 900:../QS/QS_ax12.c **** 					else
 901:../QS/QS_ax12.c **** 					{
 902:../QS/QS_ax12.c **** 						AX12_instruction_queue_next();
 2398              		.loc 2 902 0
 2399 0e60 40F20003 		movw	r3, #:lower16:AX12_special_instruction_buffer
 2400 0e64 C0F20003 		movt	r3, #:upper16:AX12_special_instruction_buffer
 2401 0e68 93F84836 		ldrb	r3, [r3, #1608]
 2402 0e6c DBB2     		uxtb	r3, r3
 2403 0e6e 03F10103 		add	r3, r3, #1
 2404 0e72 C82B     		cmp	r3, #200
 2405 0e74 0ADC     		bgt	.L158
 2406              		.loc 2 902 0 is_stmt 0 discriminator 1
 2407 0e76 40F20003 		movw	r3, #:lower16:AX12_special_instruction_buffer
 2408 0e7a C0F20003 		movt	r3, #:upper16:AX12_special_instruction_buffer
 2409 0e7e 93F84836 		ldrb	r3, [r3, #1608]
 2410 0e82 DBB2     		uxtb	r3, r3
 2411 0e84 03F10103 		add	r3, r3, #1
 2412 0e88 DAB2     		uxtb	r2, r3
 2413 0e8a 01E0     		b	.L159
 2414              	.L158:
 2415              		.loc 2 902 0 discriminator 2
 2416 0e8c 4FF00002 		mov	r2, #0
 2417              	.L159:
 2418              		.loc 2 902 0 discriminator 3
 2419 0e90 40F20003 		movw	r3, #:lower16:AX12_special_instruction_buffer
 2420 0e94 C0F20003 		movt	r3, #:upper16:AX12_special_instruction_buffer
 2421 0e98 83F84826 		strb	r2, [r3, #1608]
 903:../QS/QS_ax12.c **** 						state_machine.state = AX12_SMS_ReadyToSend;
 2422              		.loc 2 903 0 is_stmt 1 discriminator 3
 2423 0e9c 40F20003 		movw	r3, #:lower16:state_machine
 2424 0ea0 C0F20003 		movt	r3, #:upper16:state_machine
 2425 0ea4 4FF00002 		mov	r2, #0
 2426 0ea8 1A70     		strb	r2, [r3, #0]
 904:../QS/QS_ax12.c **** 						AX12_state_machine(AX12_SME_NoEvent);
 2427              		.loc 2 904 0 discriminator 3
 2428 0eaa 4FF00000 		mov	r0, #0
 2429 0eae FFF789FE 		bl	AX12_state_machine
 2430 0eb2 43E0     		b	.L153
 2431              	.L151:
 905:../QS/QS_ax12.c **** 					}
 906:../QS/QS_ax12.c **** 				}
 907:../QS/QS_ax12.c **** 			} else if(event == AX12_SME_Timeout) {
 2432              		.loc 2 907 0
 2433 0eb4 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 2434 0eb6 032B     		cmp	r3, #3
 2435 0eb8 40D1     		bne	.L153
 908:../QS/QS_ax12.c **** 				TIMER_SRC_TIMER_stop();
 2436              		.loc 2 908 0
 2437 0eba FFF7FEFF 		bl	TIMER2_stop
 909:../QS/QS_ax12.c **** 				TIMER_SRC_TIMER_resetFlag();
 2438              		.loc 2 909 0
 2439 0ebe 4FF4C050 		mov	r0, #6144
 2440 0ec2 C4F20000 		movt	r0, 16384
 2441 0ec6 4FF00101 		mov	r1, #1
 2442 0eca FFF7FEFF 		bl	TIM_ClearITPendingBit
 910:../QS/QS_ax12.c **** 				debug_printf("AX12[%d]: send timeout !!\n", state_machine.current_instruction.id_servo);
 2443              		.loc 2 910 0
 2444 0ece 40F20003 		movw	r3, #:lower16:state_machine
 2445 0ed2 C0F20003 		movt	r3, #:upper16:state_machine
 2446 0ed6 1B79     		ldrb	r3, [r3, #4]	@ zero_extendqisi2
 2447 0ed8 4FF00500 		mov	r0, #5
 2448 0edc 40F20001 		movw	r1, #:lower16:.LC8
 2449 0ee0 C0F20001 		movt	r1, #:upper16:.LC8
 2450 0ee4 1A46     		mov	r2, r3
 2451 0ee6 FFF7FEFF 		bl	OUTPUTLOG_printf
 911:../QS/QS_ax12.c **** 
 912:../QS/QS_ax12.c **** 				AX12_instruction_queue_next();
 2452              		.loc 2 912 0
 2453 0eea 40F20003 		movw	r3, #:lower16:AX12_special_instruction_buffer
 2454 0eee C0F20003 		movt	r3, #:upper16:AX12_special_instruction_buffer
 2455 0ef2 93F84836 		ldrb	r3, [r3, #1608]
 2456 0ef6 DBB2     		uxtb	r3, r3
 2457 0ef8 03F10103 		add	r3, r3, #1
 2458 0efc C82B     		cmp	r3, #200
 2459 0efe 0ADC     		bgt	.L160
 2460              		.loc 2 912 0 is_stmt 0 discriminator 1
 2461 0f00 40F20003 		movw	r3, #:lower16:AX12_special_instruction_buffer
 2462 0f04 C0F20003 		movt	r3, #:upper16:AX12_special_instruction_buffer
 2463 0f08 93F84836 		ldrb	r3, [r3, #1608]
 2464 0f0c DBB2     		uxtb	r3, r3
 2465 0f0e 03F10103 		add	r3, r3, #1
 2466 0f12 DAB2     		uxtb	r2, r3
 2467 0f14 01E0     		b	.L161
 2468              	.L160:
 2469              		.loc 2 912 0 discriminator 2
 2470 0f16 4FF00002 		mov	r2, #0
 2471              	.L161:
 2472              		.loc 2 912 0 discriminator 3
 2473 0f1a 40F20003 		movw	r3, #:lower16:AX12_special_instruction_buffer
 2474 0f1e C0F20003 		movt	r3, #:upper16:AX12_special_instruction_buffer
 2475 0f22 83F84826 		strb	r2, [r3, #1608]
 913:../QS/QS_ax12.c **** 				state_machine.state = AX12_SMS_ReadyToSend;
 2476              		.loc 2 913 0 is_stmt 1 discriminator 3
 2477 0f26 40F20003 		movw	r3, #:lower16:state_machine
 2478 0f2a C0F20003 		movt	r3, #:upper16:state_machine
 2479 0f2e 4FF00002 		mov	r2, #0
 2480 0f32 1A70     		strb	r2, [r3, #0]
 914:../QS/QS_ax12.c **** 				AX12_state_machine(AX12_SME_NoEvent);
 2481              		.loc 2 914 0 discriminator 3
 2482 0f34 4FF00000 		mov	r0, #0
 2483 0f38 FFF744FE 		bl	AX12_state_machine
 2484              	.L153:
 915:../QS/QS_ax12.c **** 			}
 916:../QS/QS_ax12.c **** 
 917:../QS/QS_ax12.c **** 			if(state_machine.state != AX12_SMS_Sending)
 2485              		.loc 2 917 0
 2486 0f3c 40F20003 		movw	r3, #:lower16:state_machine
 2487 0f40 C0F20003 		movt	r3, #:upper16:state_machine
 2488 0f44 1B78     		ldrb	r3, [r3, #0]
 2489 0f46 DBB2     		uxtb	r3, r3
 2490 0f48 012B     		cmp	r3, #1
 2491 0f4a 00F0A281 		beq	.L183
 918:../QS/QS_ax12.c **** 				USART_ITConfig(AX12_UART_Ptr, USART_IT_TXE, DISABLE);
 2492              		.loc 2 918 0
 2493 0f4e 4FF48840 		mov	r0, #17408
 2494 0f52 C4F20000 		movt	r0, 16384
 2495 0f56 40F22771 		movw	r1, #1831
 2496 0f5a 4FF00002 		mov	r2, #0
 2497 0f5e FFF7FEFF 		bl	USART_ITConfig
 919:../QS/QS_ax12.c **** 		break;
 2498              		.loc 2 919 0
 2499 0f62 96E1     		b	.L183
 2500              	.L147:
 920:../QS/QS_ax12.c **** 
 921:../QS/QS_ax12.c **** 		case AX12_SMS_WaitingAnswer:
 922:../QS/QS_ax12.c **** 			if(event == AX12_SME_RxInterrupt)
 2501              		.loc 2 922 0
 2502 0f64 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 2503 0f66 012B     		cmp	r3, #1
 2504 0f68 40F01081 		bne	.L163
 2505              	.LBB2:
 923:../QS/QS_ax12.c **** 			{
 924:../QS/QS_ax12.c **** 				//AX12_update_status_packet s'occupe de son initialisation et de son remplissage au fur et a me
 925:../QS/QS_ax12.c **** 				static AX12_status_packet_t status_response_packet;
 926:../QS/QS_ax12.c **** 				// Stockage de la rponse dans un buffer, si toute la rponse alors mise  jour des variables d
 927:../QS/QS_ax12.c **** 
 928:../QS/QS_ax12.c **** 				if(USART_GetFlagStatus(AX12_UART_Ptr, USART_FLAG_FE) | USART_GetFlagStatus(AX12_UART_Ptr, USART
 2506              		.loc 2 928 0
 2507 0f6c 4FF48840 		mov	r0, #17408
 2508 0f70 C4F20000 		movt	r0, 16384
 2509 0f74 4FF00201 		mov	r1, #2
 2510 0f78 FFF7FEFF 		bl	USART_GetFlagStatus
 2511 0f7c 0346     		mov	r3, r0
 2512 0f7e 1C46     		mov	r4, r3
 2513 0f80 4FF48840 		mov	r0, #17408
 2514 0f84 C4F20000 		movt	r0, 16384
 2515 0f88 4FF00401 		mov	r1, #4
 2516 0f8c FFF7FEFF 		bl	USART_GetFlagStatus
 2517 0f90 0346     		mov	r3, r0
 2518 0f92 2343     		orrs	r3, r3, r4
 2519 0f94 DBB2     		uxtb	r3, r3
 2520 0f96 002B     		cmp	r3, #0
 2521 0f98 06D0     		beq	.L164
 929:../QS/QS_ax12.c **** 					USART_ReceiveData(AX12_UART_Ptr);
 2522              		.loc 2 929 0
 2523 0f9a 4FF48840 		mov	r0, #17408
 2524 0f9e C4F20000 		movt	r0, 16384
 2525 0fa2 FFF7FEFF 		bl	USART_ReceiveData
 930:../QS/QS_ax12.c **** 					break;
 2526              		.loc 2 930 0
 2527 0fa6 77E1     		b	.L144
 2528              	.L164:
 931:../QS/QS_ax12.c **** 				}
 932:../QS/QS_ax12.c **** 
 933:../QS/QS_ax12.c **** 				#if defined(VERBOSE_MODE) && defined(AX12_DEBUG_PACKETS)
 934:../QS/QS_ax12.c **** 				AX12_UART2_reception_buffer[pos] = USART_ReceiveData(AX12_UART_Ptr);
 935:../QS/QS_ax12.c **** 
 936:../QS/QS_ax12.c **** 				if(!AX12_update_status_packet(AX12_UART2_reception_buffer[pos++], state_machine.receive_index, 
 937:../QS/QS_ax12.c **** 				#else
 938:../QS/QS_ax12.c **** 				Uint8 data_byte = USART_ReceiveData(AX12_UART_Ptr);
 2529              		.loc 2 938 0
 2530 0fa8 4FF48840 		mov	r0, #17408
 2531 0fac C4F20000 		movt	r0, 16384
 2532 0fb0 FFF7FEFF 		bl	USART_ReceiveData
 2533 0fb4 0346     		mov	r3, r0
 2534 0fb6 FB73     		strb	r3, [r7, #15]
 939:../QS/QS_ax12.c **** 				if(!AX12_update_status_packet(data_byte, state_machine.receive_index, &status_response_packet))
 2535              		.loc 2 939 0
 2536 0fb8 40F20003 		movw	r3, #:lower16:state_machine
 2537 0fbc C0F20003 		movt	r3, #:upper16:state_machine
 2538 0fc0 5B7B     		ldrb	r3, [r3, #13]	@ zero_extendqisi2
 2539 0fc2 FA7B     		ldrb	r2, [r7, #15]	@ zero_extendqisi2
 2540 0fc4 1046     		mov	r0, r2
 2541 0fc6 1946     		mov	r1, r3
 2542 0fc8 40F20002 		movw	r2, #:lower16:status_response_packet.6615
 2543 0fcc C0F20002 		movt	r2, #:upper16:status_response_packet.6615
 2544 0fd0 FFF770FD 		bl	AX12_update_status_packet
 2545 0fd4 0346     		mov	r3, r0
 2546 0fd6 002B     		cmp	r3, #0
 2547 0fd8 0AD1     		bne	.L165
 940:../QS/QS_ax12.c **** 				#endif
 941:../QS/QS_ax12.c **** 				{
 942:../QS/QS_ax12.c **** 					//debug_printf("AX12: invalid packet, reinit reception\n");
 943:../QS/QS_ax12.c **** 					state_machine.receive_index = 0;	//si le paquet n'est pas valide, on reinitialise la lecture d
 2548              		.loc 2 943 0
 2549 0fda 40F20003 		movw	r3, #:lower16:state_machine
 2550 0fde C0F20003 		movt	r3, #:upper16:state_machine
 2551 0fe2 4FF00002 		mov	r2, #0
 2552 0fe6 5A73     		strb	r2, [r3, #13]
 944:../QS/QS_ax12.c **** 					//pos = 0;
 945:../QS/QS_ax12.c **** 					//for(i=0; i<MAX_STATUS_PACKET_SIZE*2; i++)
 946:../QS/QS_ax12.c **** 					//	AX12_UART2_reception_buffer[i] = 0;
 947:../QS/QS_ax12.c **** 					break;
 2553              		.loc 2 947 0
 2554 0fe8 56E1     		b	.L144
 2555              	.L186:
 2556 0fea 00BF     		.align	2
 2557              	.L185:
 2558 0fec 4C000000 		.word	state_machine+4
 2559              	.L165:
 948:../QS/QS_ax12.c **** 				} else {
 949:../QS/QS_ax12.c **** 					state_machine.receive_index++;
 2560              		.loc 2 949 0
 2561 0ff0 40F20003 		movw	r3, #:lower16:state_machine
 2562 0ff4 C0F20003 		movt	r3, #:upper16:state_machine
 2563 0ff8 5B7B     		ldrb	r3, [r3, #13]	@ zero_extendqisi2
 2564 0ffa 03F10103 		add	r3, r3, #1
 2565 0ffe DAB2     		uxtb	r2, r3
 2566 1000 40F20003 		movw	r3, #:lower16:state_machine
 2567 1004 C0F20003 		movt	r3, #:upper16:state_machine
 2568 1008 5A73     		strb	r2, [r3, #13]
 950:../QS/QS_ax12.c **** 				}
 951:../QS/QS_ax12.c **** 
 952:../QS/QS_ax12.c **** 
 953:../QS/QS_ax12.c **** 				if(AX12_status_packet_is_full(status_response_packet, state_machine.receive_index))
 2569              		.loc 2 953 0
 2570 100a 40F20003 		movw	r3, #:lower16:state_machine
 2571 100e C0F20003 		movt	r3, #:upper16:state_machine
 2572 1012 5B7B     		ldrb	r3, [r3, #13]	@ zero_extendqisi2
 2573 1014 032B     		cmp	r3, #3
 2574 1016 40F23E81 		bls	.L184
 2575              		.loc 2 953 0 is_stmt 0 discriminator 1
 2576 101a 40F20003 		movw	r3, #:lower16:state_machine
 2577 101e C0F20003 		movt	r3, #:upper16:state_machine
 2578 1022 5A7B     		ldrb	r2, [r3, #13]	@ zero_extendqisi2
 2579 1024 40F20003 		movw	r3, #:lower16:status_response_packet.6615
 2580 1028 C0F20003 		movt	r3, #:upper16:status_response_packet.6615
 2581 102c 1B79     		ldrb	r3, [r3, #4]	@ zero_extendqisi2
 2582 102e 9A42     		cmp	r2, r3
 2583 1030 C0F03181 		bcc	.L184
 954:../QS/QS_ax12.c **** 				{
 955:../QS/QS_ax12.c **** 					TIMER_SRC_TIMER_stop();
 2584              		.loc 2 955 0 is_stmt 1
 2585 1034 FFF7FEFF 		bl	TIMER2_stop
 956:../QS/QS_ax12.c **** 					TIMER_SRC_TIMER_resetFlag();
 2586              		.loc 2 956 0
 2587 1038 4FF4C050 		mov	r0, #6144
 2588 103c C4F20000 		movt	r0, 16384
 2589 1040 4FF00101 		mov	r1, #1
 2590 1044 FFF7FEFF 		bl	TIM_ClearITPendingBit
 957:../QS/QS_ax12.c **** 
 958:../QS/QS_ax12.c **** 					#if defined(VERBOSE_MODE) && defined(AX12_DEBUG_PACKETS)
 959:../QS/QS_ax12.c **** 						debug_printf("AX12 Rx:");
 960:../QS/QS_ax12.c **** 						for(i = 0; i<state_machine.receive_index; i++)
 961:../QS/QS_ax12.c **** 							debug_printf(" %02x", AX12_UART2_reception_buffer[i]);
 962:../QS/QS_ax12.c **** 						debug_printf("\n");
 963:../QS/QS_ax12.c **** 					#endif
 964:../QS/QS_ax12.c **** 
 965:../QS/QS_ax12.c **** 					if(status_response_packet.id_servo != state_machine.current_instruction.id_servo || status_res
 2591              		.loc 2 965 0
 2592 1048 40F20003 		movw	r3, #:lower16:status_response_packet.6615
 2593 104c C0F20003 		movt	r3, #:upper16:status_response_packet.6615
 2594 1050 1A78     		ldrb	r2, [r3, #0]	@ zero_extendqisi2
 2595 1052 40F20003 		movw	r3, #:lower16:state_machine
 2596 1056 C0F20003 		movt	r3, #:upper16:state_machine
 2597 105a 1B79     		ldrb	r3, [r3, #4]	@ zero_extendqisi2
 2598 105c 9A42     		cmp	r2, r3
 2599 105e 06D1     		bne	.L167
 2600              		.loc 2 965 0 is_stmt 0 discriminator 1
 2601 1060 40F20003 		movw	r3, #:lower16:status_response_packet.6615
 2602 1064 C0F20003 		movt	r3, #:upper16:status_response_packet.6615
 2603 1068 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 2604 106a 062B     		cmp	r3, #6
 2605 106c 13D9     		bls	.L168
 2606              	.L167:
 966:../QS/QS_ax12.c **** 						debug_printf("Wrong servo ID: %d instead of %d\n", status_response_packet.id_servo, state_mac
 2607              		.loc 2 966 0 is_stmt 1
 2608 106e 40F20003 		movw	r3, #:lower16:status_response_packet.6615
 2609 1072 C0F20003 		movt	r3, #:upper16:status_response_packet.6615
 2610 1076 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 2611 1078 1A46     		mov	r2, r3
 2612 107a 40F20003 		movw	r3, #:lower16:state_machine
 2613 107e C0F20003 		movt	r3, #:upper16:state_machine
 2614 1082 1B79     		ldrb	r3, [r3, #4]	@ zero_extendqisi2
 2615 1084 4FF00500 		mov	r0, #5
 2616 1088 40F20001 		movw	r1, #:lower16:.LC9
 2617 108c C0F20001 		movt	r1, #:upper16:.LC9
 2618 1090 FFF7FEFF 		bl	OUTPUTLOG_printf
 2619 1094 50E0     		b	.L169
 2620              	.L168:
 967:../QS/QS_ax12.c **** 					} else {
 968:../QS/QS_ax12.c **** 						//pour tre sur de ne pas avoir le bit 7 a 1, si l'AX12 le met a 1, on met tous les bits a 1
 969:../QS/QS_ax12.c **** 						if(status_response_packet.error & 0x80)
 2621              		.loc 2 969 0
 2622 1096 40F20003 		movw	r3, #:lower16:status_response_packet.6615
 2623 109a C0F20003 		movt	r3, #:upper16:status_response_packet.6615
 2624 109e 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 2625 10a0 DBB2     		uxtb	r3, r3
 2626 10a2 5BB2     		sxtb	r3, r3
 2627 10a4 002B     		cmp	r3, #0
 2628 10a6 14DA     		bge	.L170
 970:../QS/QS_ax12.c **** 							AX12_on_the_robot[status_response_packet.id_servo].last_status.error = 0xFF;
 2629              		.loc 2 970 0
 2630 10a8 40F20003 		movw	r3, #:lower16:status_response_packet.6615
 2631 10ac C0F20003 		movt	r3, #:upper16:status_response_packet.6615
 2632 10b0 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 2633 10b2 1946     		mov	r1, r3
 2634 10b4 40F20002 		movw	r2, #:lower16:AX12_on_the_robot
 2635 10b8 C0F20002 		movt	r2, #:upper16:AX12_on_the_robot
 2636 10bc 0B46     		mov	r3, r1
 2637 10be 4FEA8303 		lsl	r3, r3, #2
 2638 10c2 5B18     		adds	r3, r3, r1
 2639 10c4 4FEA4303 		lsl	r3, r3, #1
 2640 10c8 D318     		adds	r3, r2, r3
 2641 10ca 4FF0FF02 		mov	r2, #255
 2642 10ce 1A70     		strb	r2, [r3, #0]
 2643 10d0 1AE0     		b	.L171
 2644              	.L170:
 971:../QS/QS_ax12.c **** 						else AX12_on_the_robot[status_response_packet.id_servo].last_status.error = status_response_p
 2645              		.loc 2 971 0
 2646 10d2 40F20003 		movw	r3, #:lower16:status_response_packet.6615
 2647 10d6 C0F20003 		movt	r3, #:upper16:status_response_packet.6615
 2648 10da 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 2649 10dc 1946     		mov	r1, r3
 2650 10de 40F20003 		movw	r3, #:lower16:status_response_packet.6615
 2651 10e2 C0F20003 		movt	r3, #:upper16:status_response_packet.6615
 2652 10e6 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 2653 10e8 03F07F03 		and	r3, r3, #127
 2654 10ec D8B2     		uxtb	r0, r3
 2655 10ee 40F20002 		movw	r2, #:lower16:AX12_on_the_robot
 2656 10f2 C0F20002 		movt	r2, #:upper16:AX12_on_the_robot
 2657 10f6 0B46     		mov	r3, r1
 2658 10f8 4FEA8303 		lsl	r3, r3, #2
 2659 10fc 5B18     		adds	r3, r3, r1
 2660 10fe 4FEA4303 		lsl	r3, r3, #1
 2661 1102 D318     		adds	r3, r2, r3
 2662 1104 0246     		mov	r2, r0
 2663 1106 1A70     		strb	r2, [r3, #0]
 2664              	.L171:
 972:../QS/QS_ax12.c **** 						AX12_on_the_robot[status_response_packet.id_servo].last_status.param = status_response_packet
 2665              		.loc 2 972 0
 2666 1108 40F20003 		movw	r3, #:lower16:status_response_packet.6615
 2667 110c C0F20003 		movt	r3, #:upper16:status_response_packet.6615
 2668 1110 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 2669 1112 1946     		mov	r1, r3
 2670 1114 40F20003 		movw	r3, #:lower16:status_response_packet.6615
 2671 1118 C0F20003 		movt	r3, #:upper16:status_response_packet.6615
 2672 111c 5888     		ldrh	r0, [r3, #2]
 2673 111e 40F20002 		movw	r2, #:lower16:AX12_on_the_robot
 2674 1122 C0F20002 		movt	r2, #:upper16:AX12_on_the_robot
 2675 1126 0B46     		mov	r3, r1
 2676 1128 4FEA8303 		lsl	r3, r3, #2
 2677 112c 5B18     		adds	r3, r3, r1
 2678 112e 4FEA4303 		lsl	r3, r3, #1
 2679 1132 D318     		adds	r3, r2, r3
 2680 1134 0246     		mov	r2, r0	@ movhi
 2681 1136 5A80     		strh	r2, [r3, #2]	@ movhi
 2682              	.L169:
 973:../QS/QS_ax12.c **** 
 974:../QS/QS_ax12.c **** 						#ifdef VERBOSE_MODE
 975:../QS/QS_ax12.c **** 							if(status_response_packet.error & AX12_ERROR_VOLTAGE)
 976:../QS/QS_ax12.c **** 								debug_printf("AX12[%d] Fatal: Voltage error\n", status_response_packet.id_servo);
 977:../QS/QS_ax12.c **** 							if(status_response_packet.error & AX12_ERROR_ANGLE)
 978:../QS/QS_ax12.c **** 								debug_printf("AX12[%d] Error: Angle error\n", status_response_packet.id_servo);
 979:../QS/QS_ax12.c **** 							if(status_response_packet.error & AX12_ERROR_OVERHEATING)
 980:../QS/QS_ax12.c **** 								debug_printf("AX12[%d] Fatal: Overheating error\n", status_response_packet.id_servo);
 981:../QS/QS_ax12.c **** 							if(status_response_packet.error & AX12_ERROR_RANGE)
 982:../QS/QS_ax12.c **** 								debug_printf("AX12[%d] Error: Range error\n", status_response_packet.id_servo);
 983:../QS/QS_ax12.c **** 							if(status_response_packet.error & AX12_ERROR_CHECKSUM)
 984:../QS/QS_ax12.c **** 								debug_printf("AX12[%d] Error: Checksum error\n", status_response_packet.id_servo);
 985:../QS/QS_ax12.c **** 							if(status_response_packet.error & AX12_ERROR_OVERLOAD)
 986:../QS/QS_ax12.c **** 								debug_printf("AX12[%d] Fatal: Overload error\n", status_response_packet.id_servo);
 987:../QS/QS_ax12.c **** 							if(status_response_packet.error & AX12_ERROR_INSTRUCTION)
 988:../QS/QS_ax12.c **** 								debug_printf("AX12[%d] Error: Instruction error\n", status_response_packet.id_servo);
 989:../QS/QS_ax12.c **** 							if(status_response_packet.error & 0x80)
 990:../QS/QS_ax12.c **** 								debug_printf("AX12[%d] Fatal: Unknown (0x80) error\n", status_response_packet.id_servo);
 991:../QS/QS_ax12.c **** 							if(status_response_packet.error)
 992:../QS/QS_ax12.c **** 								debug_printf("AX12[%d] Cmd: %d, addr: 0x%x, param: 0x%x\n",
 993:../QS/QS_ax12.c **** 										state_machine.current_instruction.id_servo,
 994:../QS/QS_ax12.c **** 										state_machine.current_instruction.type,
 995:../QS/QS_ax12.c **** 										state_machine.current_instruction.address,
 996:../QS/QS_ax12.c **** 										state_machine.current_instruction.param);
 997:../QS/QS_ax12.c **** 						#endif
 998:../QS/QS_ax12.c **** 					}
 999:../QS/QS_ax12.c **** 					AX12_instruction_queue_next();
 2683              		.loc 2 999 0
 2684 1138 40F20003 		movw	r3, #:lower16:AX12_special_instruction_buffer
 2685 113c C0F20003 		movt	r3, #:upper16:AX12_special_instruction_buffer
 2686 1140 93F84836 		ldrb	r3, [r3, #1608]
 2687 1144 DBB2     		uxtb	r3, r3
 2688 1146 03F10103 		add	r3, r3, #1
 2689 114a C82B     		cmp	r3, #200
 2690 114c 0ADC     		bgt	.L172
 2691              		.loc 2 999 0 is_stmt 0 discriminator 1
 2692 114e 40F20003 		movw	r3, #:lower16:AX12_special_instruction_buffer
 2693 1152 C0F20003 		movt	r3, #:upper16:AX12_special_instruction_buffer
 2694 1156 93F84836 		ldrb	r3, [r3, #1608]
 2695 115a DBB2     		uxtb	r3, r3
 2696 115c 03F10103 		add	r3, r3, #1
 2697 1160 DAB2     		uxtb	r2, r3
 2698 1162 01E0     		b	.L173
 2699              	.L172:
 2700              		.loc 2 999 0 discriminator 2
 2701 1164 4FF00002 		mov	r2, #0
 2702              	.L173:
 2703              		.loc 2 999 0 discriminator 3
 2704 1168 40F20003 		movw	r3, #:lower16:AX12_special_instruction_buffer
 2705 116c C0F20003 		movt	r3, #:upper16:AX12_special_instruction_buffer
 2706 1170 83F84826 		strb	r2, [r3, #1608]
1000:../QS/QS_ax12.c **** 					state_machine.state = AX12_SMS_ReadyToSend;
 2707              		.loc 2 1000 0 is_stmt 1 discriminator 3
 2708 1174 40F20003 		movw	r3, #:lower16:state_machine
 2709 1178 C0F20003 		movt	r3, #:upper16:state_machine
 2710 117c 4FF00002 		mov	r2, #0
 2711 1180 1A70     		strb	r2, [r3, #0]
1001:../QS/QS_ax12.c **** 					AX12_state_machine(AX12_SME_NoEvent);
 2712              		.loc 2 1001 0 discriminator 3
 2713 1182 4FF00000 		mov	r0, #0
 2714 1186 FFF71DFD 		bl	AX12_state_machine
 2715              	.LBE2:
1002:../QS/QS_ax12.c **** 				}
1003:../QS/QS_ax12.c **** 			} else if(event == AX12_SME_Timeout) {
1004:../QS/QS_ax12.c **** 				TIMER_SRC_TIMER_stop();
1005:../QS/QS_ax12.c **** 				TIMER_SRC_TIMER_resetFlag();
1006:../QS/QS_ax12.c **** 
1007:../QS/QS_ax12.c **** 				debug_printf("AX12[%d] timeout Rx:", state_machine.current_instruction.id_servo);
1008:../QS/QS_ax12.c **** 				#if defined(VERBOSE_MODE) && defined(AX12_DEBUG_PACKETS)
1009:../QS/QS_ax12.c **** 					debug_printf("AX12[%d] timeout Rx:", state_machine.current_instruction.id_servo);
1010:../QS/QS_ax12.c **** 					for(i = 0; i<pos; i++)
1011:../QS/QS_ax12.c **** 						debug_printf(" %02x", AX12_UART2_reception_buffer[i]);
1012:../QS/QS_ax12.c **** 					debug_printf(", recv idx: %d\n", state_machine.receive_index);
1013:../QS/QS_ax12.c **** 					debug_printf(" Original cmd: Id: %02x Cmd: %02x Addr: %02x param: %04x\n", state_machine.curre
1014:../QS/QS_ax12.c **** 				#endif
1015:../QS/QS_ax12.c **** 
1016:../QS/QS_ax12.c **** 				if(USART_GetFlagStatus(AX12_UART_Ptr, USART_FLAG_RXNE))
1017:../QS/QS_ax12.c **** 					debug_printf("AX12 timeout too small\n");
1018:../QS/QS_ax12.c **** 
1019:../QS/QS_ax12.c **** 				AX12_on_the_robot[state_machine.current_instruction.id_servo].last_status.error = AX12_ERROR_TI
1020:../QS/QS_ax12.c **** 				AX12_on_the_robot[state_machine.current_instruction.id_servo].last_status.param = 0;
1021:../QS/QS_ax12.c **** 
1022:../QS/QS_ax12.c **** 				AX12_instruction_queue_next();
1023:../QS/QS_ax12.c **** 				state_machine.state = AX12_SMS_ReadyToSend;
1024:../QS/QS_ax12.c **** 				AX12_state_machine(AX12_SME_NoEvent);
1025:../QS/QS_ax12.c **** 			} /*else if(event == AX12_SME_TxInterrupt) {
1026:../QS/QS_ax12.c **** 				USART_ITConfig(AX12_UART_Ptr, USART_IT_TXE, DISABLE);
1027:../QS/QS_ax12.c **** 			}*/
1028:../QS/QS_ax12.c **** 		break;
 2716              		.loc 2 1028 0 discriminator 3
 2717 118a 84E0     		b	.L184
 2718              	.L163:
1003:../QS/QS_ax12.c **** 			} else if(event == AX12_SME_Timeout) {
 2719              		.loc 2 1003 0
 2720 118c FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 2721 118e 032B     		cmp	r3, #3
 2722 1190 40F08180 		bne	.L184
1004:../QS/QS_ax12.c **** 				TIMER_SRC_TIMER_stop();
 2723              		.loc 2 1004 0
 2724 1194 FFF7FEFF 		bl	TIMER2_stop
1005:../QS/QS_ax12.c **** 				TIMER_SRC_TIMER_resetFlag();
 2725              		.loc 2 1005 0
 2726 1198 4FF4C050 		mov	r0, #6144
 2727 119c C4F20000 		movt	r0, 16384
 2728 11a0 4FF00101 		mov	r1, #1
 2729 11a4 FFF7FEFF 		bl	TIM_ClearITPendingBit
1007:../QS/QS_ax12.c **** 				debug_printf("AX12[%d] timeout Rx:", state_machine.current_instruction.id_servo);
 2730              		.loc 2 1007 0
 2731 11a8 40F20003 		movw	r3, #:lower16:state_machine
 2732 11ac C0F20003 		movt	r3, #:upper16:state_machine
 2733 11b0 1B79     		ldrb	r3, [r3, #4]	@ zero_extendqisi2
 2734 11b2 4FF00500 		mov	r0, #5
 2735 11b6 40F20001 		movw	r1, #:lower16:.LC10
 2736 11ba C0F20001 		movt	r1, #:upper16:.LC10
 2737 11be 1A46     		mov	r2, r3
 2738 11c0 FFF7FEFF 		bl	OUTPUTLOG_printf
1016:../QS/QS_ax12.c **** 				if(USART_GetFlagStatus(AX12_UART_Ptr, USART_FLAG_RXNE))
 2739              		.loc 2 1016 0
 2740 11c4 4FF48840 		mov	r0, #17408
 2741 11c8 C4F20000 		movt	r0, 16384
 2742 11cc 4FF02001 		mov	r1, #32
 2743 11d0 FFF7FEFF 		bl	USART_GetFlagStatus
 2744 11d4 0346     		mov	r3, r0
 2745 11d6 002B     		cmp	r3, #0
 2746 11d8 07D0     		beq	.L174
1017:../QS/QS_ax12.c **** 					debug_printf("AX12 timeout too small\n");
 2747              		.loc 2 1017 0
 2748 11da 4FF00500 		mov	r0, #5
 2749 11de 40F20001 		movw	r1, #:lower16:.LC11
 2750 11e2 C0F20001 		movt	r1, #:upper16:.LC11
 2751 11e6 FFF7FEFF 		bl	OUTPUTLOG_printf
 2752              	.L174:
1019:../QS/QS_ax12.c **** 				AX12_on_the_robot[state_machine.current_instruction.id_servo].last_status.error = AX12_ERROR_TI
 2753              		.loc 2 1019 0
 2754 11ea 40F20003 		movw	r3, #:lower16:state_machine
 2755 11ee C0F20003 		movt	r3, #:upper16:state_machine
 2756 11f2 1B79     		ldrb	r3, [r3, #4]	@ zero_extendqisi2
 2757 11f4 1946     		mov	r1, r3
 2758 11f6 40F20002 		movw	r2, #:lower16:AX12_on_the_robot
 2759 11fa C0F20002 		movt	r2, #:upper16:AX12_on_the_robot
 2760 11fe 0B46     		mov	r3, r1
 2761 1200 4FEA8303 		lsl	r3, r3, #2
 2762 1204 5B18     		adds	r3, r3, r1
 2763 1206 4FEA4303 		lsl	r3, r3, #1
 2764 120a D318     		adds	r3, r2, r3
 2765 120c 4FF08002 		mov	r2, #128
 2766 1210 1A70     		strb	r2, [r3, #0]
1020:../QS/QS_ax12.c **** 				AX12_on_the_robot[state_machine.current_instruction.id_servo].last_status.param = 0;
 2767              		.loc 2 1020 0
 2768 1212 40F20003 		movw	r3, #:lower16:state_machine
 2769 1216 C0F20003 		movt	r3, #:upper16:state_machine
 2770 121a 1B79     		ldrb	r3, [r3, #4]	@ zero_extendqisi2
 2771 121c 1946     		mov	r1, r3
 2772 121e 40F20002 		movw	r2, #:lower16:AX12_on_the_robot
 2773 1222 C0F20002 		movt	r2, #:upper16:AX12_on_the_robot
 2774 1226 0B46     		mov	r3, r1
 2775 1228 4FEA8303 		lsl	r3, r3, #2
 2776 122c 5B18     		adds	r3, r3, r1
 2777 122e 4FEA4303 		lsl	r3, r3, #1
 2778 1232 D318     		adds	r3, r2, r3
 2779 1234 4FF00002 		mov	r2, #0
 2780 1238 5A80     		strh	r2, [r3, #2]	@ movhi
1022:../QS/QS_ax12.c **** 				AX12_instruction_queue_next();
 2781              		.loc 2 1022 0
 2782 123a 40F20003 		movw	r3, #:lower16:AX12_special_instruction_buffer
 2783 123e C0F20003 		movt	r3, #:upper16:AX12_special_instruction_buffer
 2784 1242 93F84836 		ldrb	r3, [r3, #1608]
 2785 1246 DBB2     		uxtb	r3, r3
 2786 1248 03F10103 		add	r3, r3, #1
 2787 124c C82B     		cmp	r3, #200
 2788 124e 0ADC     		bgt	.L175
1022:../QS/QS_ax12.c **** 				AX12_instruction_queue_next();
 2789              		.loc 2 1022 0 is_stmt 0 discriminator 1
 2790 1250 40F20003 		movw	r3, #:lower16:AX12_special_instruction_buffer
 2791 1254 C0F20003 		movt	r3, #:upper16:AX12_special_instruction_buffer
 2792 1258 93F84836 		ldrb	r3, [r3, #1608]
 2793 125c DBB2     		uxtb	r3, r3
 2794 125e 03F10103 		add	r3, r3, #1
 2795 1262 DAB2     		uxtb	r2, r3
 2796 1264 01E0     		b	.L176
 2797              	.L175:
1022:../QS/QS_ax12.c **** 				AX12_instruction_queue_next();
 2798              		.loc 2 1022 0 discriminator 2
 2799 1266 4FF00002 		mov	r2, #0
 2800              	.L176:
1022:../QS/QS_ax12.c **** 				AX12_instruction_queue_next();
 2801              		.loc 2 1022 0 discriminator 3
 2802 126a 40F20003 		movw	r3, #:lower16:AX12_special_instruction_buffer
 2803 126e C0F20003 		movt	r3, #:upper16:AX12_special_instruction_buffer
 2804 1272 83F84826 		strb	r2, [r3, #1608]
1023:../QS/QS_ax12.c **** 				state_machine.state = AX12_SMS_ReadyToSend;
 2805              		.loc 2 1023 0 is_stmt 1 discriminator 3
 2806 1276 40F20003 		movw	r3, #:lower16:state_machine
 2807 127a C0F20003 		movt	r3, #:upper16:state_machine
 2808 127e 4FF00002 		mov	r2, #0
 2809 1282 1A70     		strb	r2, [r3, #0]
1024:../QS/QS_ax12.c **** 				AX12_state_machine(AX12_SME_NoEvent);
 2810              		.loc 2 1024 0 discriminator 3
 2811 1284 4FF00000 		mov	r0, #0
 2812 1288 FFF79CFC 		bl	AX12_state_machine
 2813              		.loc 2 1028 0 discriminator 3
 2814 128c 03E0     		b	.L184
 2815              	.L181:
 863:../QS/QS_ax12.c **** 		break;
 2816              		.loc 2 863 0
 2817 128e 00BF     		nop
 2818 1290 02E0     		b	.L144
 2819              	.L183:
 919:../QS/QS_ax12.c **** 		break;
 2820              		.loc 2 919 0
 2821 1292 00BF     		nop
 2822 1294 00E0     		b	.L144
 2823              	.L184:
 2824              		.loc 2 1028 0
 2825 1296 00BF     		nop
 2826              	.L144:
1029:../QS/QS_ax12.c **** 	}
1030:../QS/QS_ax12.c **** 
1031:../QS/QS_ax12.c **** 	if(event == AX12_SME_RxInterrupt || event == AX12_SME_TxInterrupt) {
 2827              		.loc 2 1031 0
 2828 1298 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 2829 129a 012B     		cmp	r3, #1
 2830 129c 02D0     		beq	.L177
 2831              		.loc 2 1031 0 is_stmt 0 discriminator 1
 2832 129e FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 2833 12a0 022B     		cmp	r3, #2
 2834 12a2 02D1     		bne	.L178
 2835              	.L177:
1032:../QS/QS_ax12.c **** 		TIMER_SRC_TIMER_EnableIT();
 2836              		.loc 2 1032 0 is_stmt 1
 2837 12a4 FFF7FEFF 		bl	TIMER2_enableInt
 2838 12a8 13E0     		b	.L137
 2839              	.L178:
1033:../QS/QS_ax12.c **** 	} else if(event == AX12_SME_Timeout) {
 2840              		.loc 2 1033 0
 2841 12aa FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 2842 12ac 032B     		cmp	r3, #3
 2843 12ae 04D1     		bne	.L179
1034:../QS/QS_ax12.c **** 		NVIC_EnableIRQ(AX12_UART_Interrupt_IRQn);
 2844              		.loc 2 1034 0
 2845 12b0 4FF02600 		mov	r0, #38
 2846 12b4 FEF7A4FE 		bl	NVIC_EnableIRQ
 2847 12b8 0BE0     		b	.L137
 2848              	.L179:
1035:../QS/QS_ax12.c **** 	} else if(event == AX12_SME_NoEvent) {
 2849              		.loc 2 1035 0
 2850 12ba FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 2851 12bc 002B     		cmp	r3, #0
 2852 12be 08D1     		bne	.L137
1036:../QS/QS_ax12.c **** 		processing_state = 0;
 2853              		.loc 2 1036 0
 2854 12c0 40F20003 		movw	r3, #:lower16:processing_state.6601
 2855 12c4 C0F20003 		movt	r3, #:upper16:processing_state.6601
 2856 12c8 4FF00002 		mov	r2, #0
 2857 12cc 1A60     		str	r2, [r3, #0]
 2858 12ce 00E0     		b	.L137
 2859              	.L180:
 812:../QS/QS_ax12.c **** 			return;
 2860              		.loc 2 812 0
 2861 12d0 00BF     		nop
 2862              	.L137:
1037:../QS/QS_ax12.c **** 	}
1038:../QS/QS_ax12.c **** }
 2863              		.loc 2 1038 0
 2864 12d2 07F11407 		add	r7, r7, #20
 2865 12d6 BD46     		mov	sp, r7
 2866 12d8 90BD     		pop	{r4, r7, pc}
 2867              		.cfi_endproc
 2868              	.LFE131:
 2870              		.section	.rodata
 2871              		.align	2
 2872              	.LC12:
 2873 0264 41583132 		.ascii	"AX12 Fatal: Instruction buffer full !\012\000"
 2873      20466174 
 2873      616C3A20 
 2873      496E7374 
 2873      72756374 
 2874              		.text
 2875 12da 00BF     		.align	2
 2876              		.thumb
 2877              		.thumb_func
 2879              	AX12_instruction_queue_insert:
 2880              	.LFB132:
1039:../QS/QS_ax12.c **** 
1040:../QS/QS_ax12.c **** /*********************************************************************************/
1041:../QS/QS_ax12.c **** /** Implmentation des fonctions grant le buffer d'instruction (insertion ici) **/
1042:../QS/QS_ax12.c **** /*********************************************************************************/
1043:../QS/QS_ax12.c **** 
1044:../QS/QS_ax12.c **** static bool_e AX12_instruction_queue_insert(const AX12_instruction_packet_t* inst) {	//utilisation 
 2881              		.loc 2 1044 0
 2882              		.cfi_startproc
 2883              		@ args = 0, pretend = 0, frame = 16
 2884              		@ frame_needed = 1, uses_anonymous_args = 0
 2885 12dc 80B5     		push	{r7, lr}
 2886              	.LCFI68:
 2887              		.cfi_def_cfa_offset 8
 2888              		.cfi_offset 7, -8
 2889              		.cfi_offset 14, -4
 2890 12de 84B0     		sub	sp, sp, #16
 2891              	.LCFI69:
 2892              		.cfi_def_cfa_offset 24
 2893 12e0 00AF     		add	r7, sp, #0
 2894              	.LCFI70:
 2895              		.cfi_def_cfa_register 7
 2896 12e2 7860     		str	r0, [r7, #4]
1045:../QS/QS_ax12.c **** 	Uint16 i = 0;
 2897              		.loc 2 1045 0
 2898 12e4 4FF00003 		mov	r3, #0
 2899 12e8 FB81     		strh	r3, [r7, #14]	@ movhi
1046:../QS/QS_ax12.c **** 	//Uint16 truc;
1047:../QS/QS_ax12.c **** 
1048:../QS/QS_ax12.c **** 	while(AX12_instruction_queue_is_full() && i < 65000)	//boucle 65000 fois si le buffer reste full, 
 2900              		.loc 2 1048 0
 2901 12ea 03E0     		b	.L188
 2902              	.L192:
1049:../QS/QS_ax12.c **** 		i++;
 2903              		.loc 2 1049 0
 2904 12ec FB89     		ldrh	r3, [r7, #14]	@ movhi
 2905 12ee 03F10103 		add	r3, r3, #1
 2906 12f2 FB81     		strh	r3, [r7, #14]	@ movhi
 2907              	.L188:
1048:../QS/QS_ax12.c **** 	while(AX12_instruction_queue_is_full() && i < 65000)	//boucle 65000 fois si le buffer reste full, 
 2908              		.loc 2 1048 0 discriminator 1
 2909 12f4 40F20003 		movw	r3, #:lower16:AX12_special_instruction_buffer
 2910 12f8 C0F20003 		movt	r3, #:upper16:AX12_special_instruction_buffer
 2911 12fc 93F84936 		ldrb	r3, [r3, #1609]
 2912 1300 DBB2     		uxtb	r3, r3
 2913 1302 03F10103 		add	r3, r3, #1
 2914 1306 C82B     		cmp	r3, #200
 2915 1308 09DC     		bgt	.L189
 2916 130a 40F20003 		movw	r3, #:lower16:AX12_special_instruction_buffer
 2917 130e C0F20003 		movt	r3, #:upper16:AX12_special_instruction_buffer
 2918 1312 93F84936 		ldrb	r3, [r3, #1609]
 2919 1316 DBB2     		uxtb	r3, r3
 2920 1318 03F10102 		add	r2, r3, #1
 2921 131c 01E0     		b	.L190
 2922              	.L189:
1048:../QS/QS_ax12.c **** 	while(AX12_instruction_queue_is_full() && i < 65000)	//boucle 65000 fois si le buffer reste full, 
 2923              		.loc 2 1048 0 is_stmt 0 discriminator 2
 2924 131e 4FF00002 		mov	r2, #0
 2925              	.L190:
1048:../QS/QS_ax12.c **** 	while(AX12_instruction_queue_is_full() && i < 65000)	//boucle 65000 fois si le buffer reste full, 
 2926              		.loc 2 1048 0 discriminator 3
 2927 1322 40F20003 		movw	r3, #:lower16:AX12_special_instruction_buffer
 2928 1326 C0F20003 		movt	r3, #:upper16:AX12_special_instruction_buffer
 2929 132a 93F84836 		ldrb	r3, [r3, #1608]
 2930 132e DBB2     		uxtb	r3, r3
 2931 1330 9A42     		cmp	r2, r3
 2932 1332 04D1     		bne	.L191
1048:../QS/QS_ax12.c **** 	while(AX12_instruction_queue_is_full() && i < 65000)	//boucle 65000 fois si le buffer reste full, 
 2933              		.loc 2 1048 0 discriminator 2
 2934 1334 FA89     		ldrh	r2, [r7, #14]
 2935 1336 4FF6E753 		movw	r3, #64999
 2936 133a 9A42     		cmp	r2, r3
 2937 133c D6D9     		bls	.L192
 2938              	.L191:
1050:../QS/QS_ax12.c **** 
1051:../QS/QS_ax12.c **** 	if(i >= 65000) {
 2939              		.loc 2 1051 0 is_stmt 1
 2940 133e FA89     		ldrh	r2, [r7, #14]
 2941 1340 4FF6E753 		movw	r3, #64999
 2942 1344 9A42     		cmp	r2, r3
 2943 1346 2CD9     		bls	.L193
1052:../QS/QS_ax12.c **** 		AX12_on_the_robot[inst->id_servo].last_status.error = AX12_ERROR_TIMEOUT | AX12_ERROR_RANGE;
 2944              		.loc 2 1052 0
 2945 1348 7B68     		ldr	r3, [r7, #4]
 2946 134a 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 2947 134c 1946     		mov	r1, r3
 2948 134e 40F20002 		movw	r2, #:lower16:AX12_on_the_robot
 2949 1352 C0F20002 		movt	r2, #:upper16:AX12_on_the_robot
 2950 1356 0B46     		mov	r3, r1
 2951 1358 4FEA8303 		lsl	r3, r3, #2
 2952 135c 5B18     		adds	r3, r3, r1
 2953 135e 4FEA4303 		lsl	r3, r3, #1
 2954 1362 D318     		adds	r3, r2, r3
 2955 1364 4FF08802 		mov	r2, #136
 2956 1368 1A70     		strb	r2, [r3, #0]
1053:../QS/QS_ax12.c **** 		AX12_on_the_robot[inst->id_servo].last_status.param = 0;
 2957              		.loc 2 1053 0
 2958 136a 7B68     		ldr	r3, [r7, #4]
 2959 136c 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 2960 136e 1946     		mov	r1, r3
 2961 1370 40F20002 		movw	r2, #:lower16:AX12_on_the_robot
 2962 1374 C0F20002 		movt	r2, #:upper16:AX12_on_the_robot
 2963 1378 0B46     		mov	r3, r1
 2964 137a 4FEA8303 		lsl	r3, r3, #2
 2965 137e 5B18     		adds	r3, r3, r1
 2966 1380 4FEA4303 		lsl	r3, r3, #1
 2967 1384 D318     		adds	r3, r2, r3
 2968 1386 4FF00002 		mov	r2, #0
 2969 138a 5A80     		strh	r2, [r3, #2]	@ movhi
1054:../QS/QS_ax12.c **** 		debug_printf("AX12 Fatal: Instruction buffer full !\n");
 2970              		.loc 2 1054 0
 2971 138c 4FF00500 		mov	r0, #5
 2972 1390 40F20001 		movw	r1, #:lower16:.LC12
 2973 1394 C0F20001 		movt	r1, #:upper16:.LC12
 2974 1398 FFF7FEFF 		bl	OUTPUTLOG_printf
1055:../QS/QS_ax12.c **** 		return FALSE;	//return false, on a pas russi a insrer l'instruction, problme de priorit d'int
 2975              		.loc 2 1055 0
 2976 139c 4FF00003 		mov	r3, #0
 2977 13a0 36E0     		b	.L194
 2978              	.L193:
1056:../QS/QS_ax12.c **** 	}
1057:../QS/QS_ax12.c **** 
1058:../QS/QS_ax12.c **** 	AX12_special_instruction_buffer.buffer[AX12_special_instruction_buffer.end_index] = *inst;
 2979              		.loc 2 1058 0
 2980 13a2 40F20003 		movw	r3, #:lower16:AX12_special_instruction_buffer
 2981 13a6 C0F20003 		movt	r3, #:upper16:AX12_special_instruction_buffer
 2982 13aa 93F84936 		ldrb	r3, [r3, #1609]
 2983 13ae DBB2     		uxtb	r3, r3
 2984 13b0 40F20002 		movw	r2, #:lower16:AX12_special_instruction_buffer
 2985 13b4 C0F20002 		movt	r2, #:upper16:AX12_special_instruction_buffer
 2986 13b8 7968     		ldr	r1, [r7, #4]
 2987 13ba 4FEAC303 		lsl	r3, r3, #3
 2988 13be D318     		adds	r3, r2, r3
 2989 13c0 0A46     		mov	r2, r1
 2990 13c2 1068     		ldr	r0, [r2, #0]	@ unaligned
 2991 13c4 5168     		ldr	r1, [r2, #4]	@ unaligned
 2992 13c6 03C3     		stmia	r3!, {r0, r1}
1059:../QS/QS_ax12.c **** 	AX12_special_instruction_buffer.end_index = INC_WITH_MOD(AX12_special_instruction_buffer.end_index
 2993              		.loc 2 1059 0
 2994 13c8 40F20003 		movw	r3, #:lower16:AX12_special_instruction_buffer
 2995 13cc C0F20003 		movt	r3, #:upper16:AX12_special_instruction_buffer
 2996 13d0 93F84936 		ldrb	r3, [r3, #1609]
 2997 13d4 DBB2     		uxtb	r3, r3
 2998 13d6 03F10103 		add	r3, r3, #1
 2999 13da C82B     		cmp	r3, #200
 3000 13dc 0ADC     		bgt	.L195
 3001              		.loc 2 1059 0 is_stmt 0 discriminator 1
 3002 13de 40F20003 		movw	r3, #:lower16:AX12_special_instruction_buffer
 3003 13e2 C0F20003 		movt	r3, #:upper16:AX12_special_instruction_buffer
 3004 13e6 93F84936 		ldrb	r3, [r3, #1609]
 3005 13ea DBB2     		uxtb	r3, r3
 3006 13ec 03F10103 		add	r3, r3, #1
 3007 13f0 DAB2     		uxtb	r2, r3
 3008 13f2 01E0     		b	.L196
 3009              	.L195:
 3010              		.loc 2 1059 0 discriminator 2
 3011 13f4 4FF00002 		mov	r2, #0
 3012              	.L196:
 3013              		.loc 2 1059 0 discriminator 3
 3014 13f8 40F20003 		movw	r3, #:lower16:AX12_special_instruction_buffer
 3015 13fc C0F20003 		movt	r3, #:upper16:AX12_special_instruction_buffer
 3016 1400 83F84926 		strb	r2, [r3, #1609]
1060:../QS/QS_ax12.c **** 	//truc = state_machine.state;
1061:../QS/QS_ax12.c **** 	//if(truc == AX12_SMS_ReadyToSend)
1062:../QS/QS_ax12.c **** 		AX12_state_machine(AX12_SME_NoEvent);
 3017              		.loc 2 1062 0 is_stmt 1 discriminator 3
 3018 1404 4FF00000 		mov	r0, #0
 3019 1408 FFF7DCFB 		bl	AX12_state_machine
1063:../QS/QS_ax12.c **** 	//else debug_printf("ax12 not ready, in state %d\n", truc);
1064:../QS/QS_ax12.c **** 
1065:../QS/QS_ax12.c **** 	return TRUE;
 3020              		.loc 2 1065 0 discriminator 3
 3021 140c 4FF00103 		mov	r3, #1
 3022              	.L194:
1066:../QS/QS_ax12.c **** }
 3023              		.loc 2 1066 0
 3024 1410 1846     		mov	r0, r3
 3025 1412 07F11007 		add	r7, r7, #16
 3026 1416 BD46     		mov	sp, r7
 3027 1418 80BD     		pop	{r7, pc}
 3028              		.cfi_endproc
 3029              	.LFE132:
 3031 141a 00BF     		.align	2
 3032              		.thumb
 3033              		.thumb_func
 3035              	AX12_UART2_init:
 3036              	.LFB133:
1067:../QS/QS_ax12.c **** 
1068:../QS/QS_ax12.c **** /**************************************************************************/
1069:../QS/QS_ax12.c **** /** Fonction initialisant l'UART2 utilis pour communiquer               **/
1070:../QS/QS_ax12.c **** /**************************************************************************/
1071:../QS/QS_ax12.c **** 
1072:../QS/QS_ax12.c **** /*	vitesse : 57600 bauds (modifiable: uart_speed)
1073:../QS/QS_ax12.c **** 	bits de donnees : 8
1074:../QS/QS_ax12.c **** 	parite : aucune
1075:../QS/QS_ax12.c **** 	bit de stop : 1
1076:../QS/QS_ax12.c **** 	pas de controle de flux
1077:../QS/QS_ax12.c **** */
1078:../QS/QS_ax12.c **** 
1079:../QS/QS_ax12.c **** static void AX12_UART2_init(Uint32 uart_speed)
1080:../QS/QS_ax12.c **** {
 3037              		.loc 2 1080 0
 3038              		.cfi_startproc
 3039              		@ args = 0, pretend = 0, frame = 32
 3040              		@ frame_needed = 1, uses_anonymous_args = 0
 3041 141c 80B5     		push	{r7, lr}
 3042              	.LCFI71:
 3043              		.cfi_def_cfa_offset 8
 3044              		.cfi_offset 7, -8
 3045              		.cfi_offset 14, -4
 3046 141e 88B0     		sub	sp, sp, #32
 3047              	.LCFI72:
 3048              		.cfi_def_cfa_offset 40
 3049 1420 00AF     		add	r7, sp, #0
 3050              	.LCFI73:
 3051              		.cfi_def_cfa_register 7
 3052 1422 7860     		str	r0, [r7, #4]
1081:../QS/QS_ax12.c **** 	NVIC_InitTypeDef NVIC_InitStructure;
1082:../QS/QS_ax12.c **** 	USART_InitTypeDef USART_InitStructure;
1083:../QS/QS_ax12.c **** 
1084:../QS/QS_ax12.c **** 	PORTS_uarts_init();
 3053              		.loc 2 1084 0
 3054 1424 FFF7FEFF 		bl	PORTS_uarts_init
1085:../QS/QS_ax12.c **** 
1086:../QS/QS_ax12.c **** #if AX12_UART_ID == 1
1087:../QS/QS_ax12.c **** 	RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, ENABLE);
1088:../QS/QS_ax12.c **** #elif AX12_UART_ID == 2
1089:../QS/QS_ax12.c **** 	RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART2, ENABLE);
 3055              		.loc 2 1089 0
 3056 1428 4FF40030 		mov	r0, #131072
 3057 142c 4FF00101 		mov	r1, #1
 3058 1430 FFF7FEFF 		bl	RCC_APB1PeriphClockCmd
1090:../QS/QS_ax12.c **** #endif
1091:../QS/QS_ax12.c **** 
1092:../QS/QS_ax12.c **** 	USART_OverSampling8Cmd(AX12_UART_Ptr, ENABLE);
 3059              		.loc 2 1092 0
 3060 1434 4FF48840 		mov	r0, #17408
 3061 1438 C4F20000 		movt	r0, 16384
 3062 143c 4FF00101 		mov	r1, #1
 3063 1440 FFF7FEFF 		bl	USART_OverSampling8Cmd
1093:../QS/QS_ax12.c **** 
1094:../QS/QS_ax12.c **** 	USART_InitStructure.USART_BaudRate = uart_speed;
 3064              		.loc 2 1094 0
 3065 1444 7B68     		ldr	r3, [r7, #4]
 3066 1446 FB60     		str	r3, [r7, #12]
1095:../QS/QS_ax12.c **** 	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
 3067              		.loc 2 1095 0
 3068 1448 4FF00003 		mov	r3, #0
 3069 144c 3B82     		strh	r3, [r7, #16]	@ movhi
1096:../QS/QS_ax12.c **** 	USART_InitStructure.USART_StopBits = USART_StopBits_1;
 3070              		.loc 2 1096 0
 3071 144e 4FF00003 		mov	r3, #0
 3072 1452 7B82     		strh	r3, [r7, #18]	@ movhi
1097:../QS/QS_ax12.c **** 	USART_InitStructure.USART_Parity = USART_Parity_No;
 3073              		.loc 2 1097 0
 3074 1454 4FF00003 		mov	r3, #0
 3075 1458 BB82     		strh	r3, [r7, #20]	@ movhi
1098:../QS/QS_ax12.c **** 	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
 3076              		.loc 2 1098 0
 3077 145a 4FF00003 		mov	r3, #0
 3078 145e 3B83     		strh	r3, [r7, #24]	@ movhi
1099:../QS/QS_ax12.c **** 	USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
 3079              		.loc 2 1099 0
 3080 1460 4FF00C03 		mov	r3, #12
 3081 1464 FB82     		strh	r3, [r7, #22]	@ movhi
1100:../QS/QS_ax12.c **** 	USART_Init(AX12_UART_Ptr, &USART_InitStructure);
 3082              		.loc 2 1100 0
 3083 1466 07F10C03 		add	r3, r7, #12
 3084 146a 4FF48840 		mov	r0, #17408
 3085 146e C4F20000 		movt	r0, 16384
 3086 1472 1946     		mov	r1, r3
 3087 1474 FFF7FEFF 		bl	USART_Init
1101:../QS/QS_ax12.c **** 
1102:../QS/QS_ax12.c **** 
1103:../QS/QS_ax12.c **** 	/* Enable USART */
1104:../QS/QS_ax12.c **** 	USART_Cmd(AX12_UART_Ptr, ENABLE);
 3088              		.loc 2 1104 0
 3089 1478 4FF48840 		mov	r0, #17408
 3090 147c C4F20000 		movt	r0, 16384
 3091 1480 4FF00101 		mov	r1, #1
 3092 1484 FFF7FEFF 		bl	USART_Cmd
1105:../QS/QS_ax12.c **** 
1106:../QS/QS_ax12.c **** 	USART_ITConfig(AX12_UART_Ptr, USART_IT_RXNE, ENABLE);
 3093              		.loc 2 1106 0
 3094 1488 4FF48840 		mov	r0, #17408
 3095 148c C4F20000 		movt	r0, 16384
 3096 1490 40F22551 		movw	r1, #1317
 3097 1494 4FF00102 		mov	r2, #1
 3098 1498 FFF7FEFF 		bl	USART_ITConfig
1107:../QS/QS_ax12.c **** 	USART_ITConfig(AX12_UART_Ptr, USART_IT_TXE, DISABLE);
 3099              		.loc 2 1107 0
 3100 149c 4FF48840 		mov	r0, #17408
 3101 14a0 C4F20000 		movt	r0, 16384
 3102 14a4 40F22771 		movw	r1, #1831
 3103 14a8 4FF00002 		mov	r2, #0
 3104 14ac FFF7FEFF 		bl	USART_ITConfig
1108:../QS/QS_ax12.c **** 
1109:../QS/QS_ax12.c **** 	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
 3105              		.loc 2 1109 0
 3106 14b0 4FF00003 		mov	r3, #0
 3107 14b4 BB77     		strb	r3, [r7, #30]
1110:../QS/QS_ax12.c **** 	NVIC_InitStructure.NVIC_IRQChannel = AX12_UART_Interrupt_IRQn;
 3108              		.loc 2 1110 0
 3109 14b6 4FF02603 		mov	r3, #38
 3110 14ba 3B77     		strb	r3, [r7, #28]
1111:../QS/QS_ax12.c **** 	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
 3111              		.loc 2 1111 0
 3112 14bc 4FF00103 		mov	r3, #1
 3113 14c0 FB77     		strb	r3, [r7, #31]
1112:../QS/QS_ax12.c **** 	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 2;  //infrieur aux uarts mais suprieur au
 3114              		.loc 2 1112 0
 3115 14c2 4FF00203 		mov	r3, #2
 3116 14c6 7B77     		strb	r3, [r7, #29]
1113:../QS/QS_ax12.c **** 
1114:../QS/QS_ax12.c **** 	NVIC_Init(&NVIC_InitStructure);
 3117              		.loc 2 1114 0
 3118 14c8 07F11C03 		add	r3, r7, #28
 3119 14cc 1846     		mov	r0, r3
 3120 14ce FFF7FEFF 		bl	NVIC_Init
1115:../QS/QS_ax12.c **** }
 3121              		.loc 2 1115 0
 3122 14d2 07F12007 		add	r7, r7, #32
 3123 14d6 BD46     		mov	sp, r7
 3124 14d8 80BD     		pop	{r7, pc}
 3125              		.cfi_endproc
 3126              	.LFE133:
 3128 14da 00BF     		.align	2
 3129              		.global	USART2_IRQHandler
 3130              		.thumb
 3131              		.thumb_func
 3133              	USART2_IRQHandler:
 3134              	.LFB134:
1116:../QS/QS_ax12.c **** 
1117:../QS/QS_ax12.c **** /*****************************************************************************/
1118:../QS/QS_ax12.c **** /** Interruptions utilises (Reception/Envoi UART2 et timer pour le timeout **/
1119:../QS/QS_ax12.c **** /*****************************************************************************/
1120:../QS/QS_ax12.c **** 
1121:../QS/QS_ax12.c **** 
1122:../QS/QS_ax12.c **** //Attention ! Si on met a 0 le flag aprs avoir execut la machine a tat,
1123:../QS/QS_ax12.c **** //des interruptions peuvent tre masque
1124:../QS/QS_ax12.c **** //(en gros il se peut qu'une interruption Tx arrive avant d'avoir termine l'execution de la foncti
1125:../QS/QS_ax12.c **** //dans ce cas mettre le flag a 0 fait que l'interruption Tx n'est pas lance)
1126:../QS/QS_ax12.c **** //(car le caractre envoy est envoy plus vite que le retour de la fonction AX12_state_machine)
1127:../QS/QS_ax12.c **** void _ISR AX12_UART_Interrupt(void)
1128:../QS/QS_ax12.c **** {
 3135              		.loc 2 1128 0
 3136              		.cfi_startproc
 3137              		@ args = 0, pretend = 0, frame = 8
 3138              		@ frame_needed = 1, uses_anonymous_args = 0
 3139 14dc 80B5     		push	{r7, lr}
 3140              	.LCFI74:
 3141              		.cfi_def_cfa_offset 8
 3142              		.cfi_offset 7, -8
 3143              		.cfi_offset 14, -4
 3144 14de 82B0     		sub	sp, sp, #8
 3145              	.LCFI75:
 3146              		.cfi_def_cfa_offset 16
 3147 14e0 00AF     		add	r7, sp, #0
 3148              	.LCFI76:
 3149              		.cfi_def_cfa_register 7
1129:../QS/QS_ax12.c **** 	if(USART_GetITStatus(AX12_UART_Ptr, USART_IT_RXNE))
 3150              		.loc 2 1129 0
 3151 14e2 4FF48840 		mov	r0, #17408
 3152 14e6 C4F20000 		movt	r0, 16384
 3153 14ea 40F22551 		movw	r1, #1317
 3154 14ee FFF7FEFF 		bl	USART_GetITStatus
 3155 14f2 0346     		mov	r3, r0
 3156 14f4 002B     		cmp	r3, #0
 3157 14f6 34D0     		beq	.L199
 3158              	.LBB3:
1130:../QS/QS_ax12.c **** 	{
1131:../QS/QS_ax12.c **** 		Uint8 i = 0;
 3159              		.loc 2 1131 0
 3160 14f8 4FF00003 		mov	r3, #0
 3161 14fc FB71     		strb	r3, [r7, #7]
1132:../QS/QS_ax12.c **** 		while(USART_GetFlagStatus(AX12_UART_Ptr, USART_FLAG_RXNE)) {		//On a une IT Rx pour chaque carat
 3162              		.loc 2 1132 0
 3163 14fe 24E0     		b	.L200
 3164              	.L204:
1133:../QS/QS_ax12.c **** 			if(state_machine.state != AX12_SMS_WaitingAnswer) {	//Arrive quand on allume les cartes avant la
 3165              		.loc 2 1133 0
 3166 1500 40F20003 		movw	r3, #:lower16:state_machine
 3167 1504 C0F20003 		movt	r3, #:upper16:state_machine
 3168 1508 1B78     		ldrb	r3, [r3, #0]
 3169 150a DBB2     		uxtb	r3, r3
 3170 150c 022B     		cmp	r3, #2
 3171 150e 06D0     		beq	.L201
1134:../QS/QS_ax12.c **** 				USART_ReceiveData(AX12_UART_Ptr);
 3172              		.loc 2 1134 0
 3173 1510 4FF48840 		mov	r0, #17408
 3174 1514 C4F20000 		movt	r0, 16384
 3175 1518 FFF7FEFF 		bl	USART_ReceiveData
 3176 151c 11E0     		b	.L202
 3177              	.L201:
1135:../QS/QS_ax12.c **** 			} else {
1136:../QS/QS_ax12.c **** 				AX12_state_machine(AX12_SME_RxInterrupt);
 3178              		.loc 2 1136 0
 3179 151e 4FF00100 		mov	r0, #1
 3180 1522 FFF74FFB 		bl	AX12_state_machine
1137:../QS/QS_ax12.c **** 				if(USART_GetFlagStatus(AX12_UART_Ptr, USART_FLAG_RXNE) && i > 5) {
 3181              		.loc 2 1137 0
 3182 1526 4FF48840 		mov	r0, #17408
 3183 152a C4F20000 		movt	r0, 16384
 3184 152e 4FF02001 		mov	r1, #32
 3185 1532 FFF7FEFF 		bl	USART_GetFlagStatus
 3186 1536 0346     		mov	r3, r0
 3187 1538 002B     		cmp	r3, #0
 3188 153a 02D0     		beq	.L202
 3189              		.loc 2 1137 0 is_stmt 0 discriminator 1
 3190 153c FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 3191 153e 052B     		cmp	r3, #5
 3192 1540 1FD8     		bhi	.L206
 3193              	.L202:
1138:../QS/QS_ax12.c **** 					//debug_printf("Overinterrupt RX !\n");
1139:../QS/QS_ax12.c **** 					break; //force 0, on va perdre des caractres, mais c'est mieux que de boucler ici ...
1140:../QS/QS_ax12.c **** 				}
1141:../QS/QS_ax12.c **** 			}
1142:../QS/QS_ax12.c **** 			i++;
 3194              		.loc 2 1142 0 is_stmt 1
 3195 1542 FB79     		ldrb	r3, [r7, #7]
 3196 1544 03F10103 		add	r3, r3, #1
 3197 1548 FB71     		strb	r3, [r7, #7]
 3198              	.L200:
1132:../QS/QS_ax12.c **** 		while(USART_GetFlagStatus(AX12_UART_Ptr, USART_FLAG_RXNE)) {		//On a une IT Rx pour chaque carat
 3199              		.loc 2 1132 0 discriminator 1
 3200 154a 4FF48840 		mov	r0, #17408
 3201 154e C4F20000 		movt	r0, 16384
 3202 1552 4FF02001 		mov	r1, #32
 3203 1556 FFF7FEFF 		bl	USART_GetFlagStatus
 3204 155a 0346     		mov	r3, r0
 3205 155c 002B     		cmp	r3, #0
 3206 155e CFD1     		bne	.L204
1132:../QS/QS_ax12.c **** 		while(USART_GetFlagStatus(AX12_UART_Ptr, USART_FLAG_RXNE)) {		//On a une IT Rx pour chaque carat
 3207              		.loc 2 1132 0 is_stmt 0
 3208 1560 10E0     		b	.L198
 3209              	.L199:
 3210              	.LBE3:
1143:../QS/QS_ax12.c **** 		}
1144:../QS/QS_ax12.c **** 	}
1145:../QS/QS_ax12.c **** 	else if(USART_GetITStatus(AX12_UART_Ptr, USART_IT_TXE))
 3211              		.loc 2 1145 0 is_stmt 1
 3212 1562 4FF48840 		mov	r0, #17408
 3213 1566 C4F20000 		movt	r0, 16384
 3214 156a 40F22771 		movw	r1, #1831
 3215 156e FFF7FEFF 		bl	USART_GetITStatus
 3216 1572 0346     		mov	r3, r0
 3217 1574 002B     		cmp	r3, #0
 3218 1576 05D0     		beq	.L198
1146:../QS/QS_ax12.c **** 	{
1147:../QS/QS_ax12.c **** 		AX12_state_machine(AX12_SME_TxInterrupt);
 3219              		.loc 2 1147 0
 3220 1578 4FF00200 		mov	r0, #2
 3221 157c FFF722FB 		bl	AX12_state_machine
 3222 1580 00E0     		b	.L198
 3223              	.L206:
 3224              	.LBB4:
1139:../QS/QS_ax12.c **** 					break; //force 0, on va perdre des caractres, mais c'est mieux que de boucler ici ...
 3225              		.loc 2 1139 0
 3226 1582 00BF     		nop
 3227              	.L198:
 3228              	.LBE4:
1148:../QS/QS_ax12.c **** 	}
1149:../QS/QS_ax12.c **** }
 3229              		.loc 2 1149 0
 3230 1584 07F10807 		add	r7, r7, #8
 3231 1588 BD46     		mov	sp, r7
 3232 158a 80BD     		pop	{r7, pc}
 3233              		.cfi_endproc
 3234              	.LFE134:
 3236              		.section	.rodata
 3237 028b 00       		.align	2
 3238              	.LC13:
 3239 028c 4F766572 		.ascii	"Overinterrupt RX ! while timeout\012\000"
 3239      696E7465 
 3239      72727570 
 3239      74205258 
 3239      20212077 
 3240              		.text
 3241              		.align	2
 3242              		.global	_T2Interrupt
 3243              		.thumb
 3244              		.thumb_func
 3246              	_T2Interrupt:
 3247              	.LFB135:
1150:../QS/QS_ax12.c **** 
1151:../QS/QS_ax12.c **** void TIMER_SRC_TIMER_interrupt()
1152:../QS/QS_ax12.c **** {
 3248              		.loc 2 1152 0
 3249              		.cfi_startproc
 3250              		@ args = 0, pretend = 0, frame = 8
 3251              		@ frame_needed = 1, uses_anonymous_args = 0
 3252 158c 80B5     		push	{r7, lr}
 3253              	.LCFI77:
 3254              		.cfi_def_cfa_offset 8
 3255              		.cfi_offset 7, -8
 3256              		.cfi_offset 14, -4
 3257 158e 82B0     		sub	sp, sp, #8
 3258              	.LCFI78:
 3259              		.cfi_def_cfa_offset 16
 3260 1590 00AF     		add	r7, sp, #0
 3261              	.LCFI79:
 3262              		.cfi_def_cfa_register 7
1153:../QS/QS_ax12.c **** 	Uint8 i = 0;
 3263              		.loc 2 1153 0
 3264 1592 4FF00003 		mov	r3, #0
 3265 1596 FB71     		strb	r3, [r7, #7]
1154:../QS/QS_ax12.c **** 
1155:../QS/QS_ax12.c **** 	while(USART_GetFlagStatus(AX12_UART_Ptr, USART_FLAG_RXNE)) {		//On a une IT Rx pour chaque caratr
 3266              		.loc 2 1155 0
 3267 1598 2DE0     		b	.L208
 3268              	.L212:
1156:../QS/QS_ax12.c **** 		if(state_machine.state != AX12_SMS_WaitingAnswer) {	//Arrive quand on allume les cartes avant la 
 3269              		.loc 2 1156 0
 3270 159a 40F20003 		movw	r3, #:lower16:state_machine
 3271 159e C0F20003 		movt	r3, #:upper16:state_machine
 3272 15a2 1B78     		ldrb	r3, [r3, #0]
 3273 15a4 DBB2     		uxtb	r3, r3
 3274 15a6 022B     		cmp	r3, #2
 3275 15a8 06D0     		beq	.L209
1157:../QS/QS_ax12.c **** 			USART_ReceiveData(AX12_UART_Ptr);
 3276              		.loc 2 1157 0
 3277 15aa 4FF48840 		mov	r0, #17408
 3278 15ae C4F20000 		movt	r0, 16384
 3279 15b2 FFF7FEFF 		bl	USART_ReceiveData
 3280 15b6 1AE0     		b	.L210
 3281              	.L209:
1158:../QS/QS_ax12.c **** 		} else {
1159:../QS/QS_ax12.c **** 			AX12_state_machine(AX12_SME_RxInterrupt);
 3282              		.loc 2 1159 0
 3283 15b8 4FF00100 		mov	r0, #1
 3284 15bc FFF702FB 		bl	AX12_state_machine
1160:../QS/QS_ax12.c **** 			if(USART_GetFlagStatus(AX12_UART_Ptr, USART_FLAG_RXNE) && i > 5) {
 3285              		.loc 2 1160 0
 3286 15c0 4FF48840 		mov	r0, #17408
 3287 15c4 C4F20000 		movt	r0, 16384
 3288 15c8 4FF02001 		mov	r1, #32
 3289 15cc FFF7FEFF 		bl	USART_GetFlagStatus
 3290 15d0 0346     		mov	r3, r0
 3291 15d2 002B     		cmp	r3, #0
 3292 15d4 0BD0     		beq	.L210
 3293              		.loc 2 1160 0 is_stmt 0 discriminator 1
 3294 15d6 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 3295 15d8 052B     		cmp	r3, #5
 3296 15da 08D9     		bls	.L210
1161:../QS/QS_ax12.c **** 				debug_printf("Overinterrupt RX ! while timeout\n");
 3297              		.loc 2 1161 0 is_stmt 1
 3298 15dc 4FF00500 		mov	r0, #5
 3299 15e0 40F20001 		movw	r1, #:lower16:.LC13
 3300 15e4 C0F20001 		movt	r1, #:upper16:.LC13
 3301 15e8 FFF7FEFF 		bl	OUTPUTLOG_printf
1162:../QS/QS_ax12.c **** 				break; //force 0, on va perdre des caractres, mais c'est mieux que de boucler ici ...
 3302              		.loc 2 1162 0
 3303 15ec 0EE0     		b	.L211
 3304              	.L210:
1163:../QS/QS_ax12.c **** 			}
1164:../QS/QS_ax12.c **** 		}
1165:../QS/QS_ax12.c **** 		i++;
 3305              		.loc 2 1165 0
 3306 15ee FB79     		ldrb	r3, [r7, #7]
 3307 15f0 03F10103 		add	r3, r3, #1
 3308 15f4 FB71     		strb	r3, [r7, #7]
 3309              	.L208:
1155:../QS/QS_ax12.c **** 	while(USART_GetFlagStatus(AX12_UART_Ptr, USART_FLAG_RXNE)) {		//On a une IT Rx pour chaque caratr
 3310              		.loc 2 1155 0 discriminator 1
 3311 15f6 4FF48840 		mov	r0, #17408
 3312 15fa C4F20000 		movt	r0, 16384
 3313 15fe 4FF02001 		mov	r1, #32
 3314 1602 FFF7FEFF 		bl	USART_GetFlagStatus
 3315 1606 0346     		mov	r3, r0
 3316 1608 002B     		cmp	r3, #0
 3317 160a C6D1     		bne	.L212
 3318              	.L211:
1166:../QS/QS_ax12.c **** 	}
1167:../QS/QS_ax12.c **** 	AX12_state_machine(AX12_SME_Timeout);
 3319              		.loc 2 1167 0
 3320 160c 4FF00300 		mov	r0, #3
 3321 1610 FFF7D8FA 		bl	AX12_state_machine
1168:../QS/QS_ax12.c **** 	TIMER_SRC_TIMER_resetFlag();
 3322              		.loc 2 1168 0
 3323 1614 4FF4C050 		mov	r0, #6144
 3324 1618 C4F20000 		movt	r0, 16384
 3325 161c 4FF00101 		mov	r1, #1
 3326 1620 FFF7FEFF 		bl	TIM_ClearITPendingBit
1169:../QS/QS_ax12.c **** }
 3327              		.loc 2 1169 0
 3328 1624 07F10807 		add	r7, r7, #8
 3329 1628 BD46     		mov	sp, r7
 3330 162a 80BD     		pop	{r7, pc}
 3331              		.cfi_endproc
 3332              	.LFE135:
 3334              		.align	2
 3335              		.global	AX12_init
 3336              		.thumb
 3337              		.thumb_func
 3339              	AX12_init:
 3340              	.LFB136:
1170:../QS/QS_ax12.c **** 
1171:../QS/QS_ax12.c **** /**************************************************************************/
1172:../QS/QS_ax12.c **** /** Fonctions d'interface utilis par l'utilisateur du driver            **/
1173:../QS/QS_ax12.c **** /**************************************************************************/
1174:../QS/QS_ax12.c **** 
1175:../QS/QS_ax12.c **** /* Fonction initialisant ce Driver	                                     */
1176:../QS/QS_ax12.c **** 
1177:../QS/QS_ax12.c **** void AX12_init() {
 3341              		.loc 2 1177 0
 3342              		.cfi_startproc
 3343              		@ args = 0, pretend = 0, frame = 8
 3344              		@ frame_needed = 1, uses_anonymous_args = 0
 3345 162c 80B5     		push	{r7, lr}
 3346              	.LCFI80:
 3347              		.cfi_def_cfa_offset 8
 3348              		.cfi_offset 7, -8
 3349              		.cfi_offset 14, -4
 3350 162e 82B0     		sub	sp, sp, #8
 3351              	.LCFI81:
 3352              		.cfi_def_cfa_offset 16
 3353 1630 00AF     		add	r7, sp, #0
 3354              	.LCFI82:
 3355              		.cfi_def_cfa_register 7
1178:../QS/QS_ax12.c **** 	static bool_e initialized = FALSE;
1179:../QS/QS_ax12.c **** 	Uint8 i;
1180:../QS/QS_ax12.c **** 	if(initialized)
 3356              		.loc 2 1180 0
 3357 1632 40F20003 		movw	r3, #:lower16:initialized.6644
 3358 1636 C0F20003 		movt	r3, #:upper16:initialized.6644
 3359 163a 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 3360 163c 002B     		cmp	r3, #0
 3361 163e 5DD1     		bne	.L218
 3362              	.L214:
1181:../QS/QS_ax12.c **** 		return;
1182:../QS/QS_ax12.c **** 
1183:../QS/QS_ax12.c **** 	AX12_UART2_init(AX12_UART_BAUDRATE);
 3363              		.loc 2 1183 0
 3364 1640 4DF67C50 		movw	r0, #56700
 3365 1644 FFF7EAFE 		bl	AX12_UART2_init
1184:../QS/QS_ax12.c **** 	TIMER_SRC_TIMER_init();
 3366              		.loc 2 1184 0
 3367 1648 FFF7FEFF 		bl	TIMER_init
1185:../QS/QS_ax12.c **** 	AX12_DIRECTION_PORT = RX_DIRECTION;
 3368              		.loc 2 1185 0
 3369 164c 4FF48063 		mov	r3, #1024
 3370 1650 C4F20203 		movt	r3, 16386
 3371 1654 5A69     		ldr	r2, [r3, #20]
 3372 1656 6FF3CB22 		bfc	r2, #11, #1
 3373 165a 5A61     		str	r2, [r3, #20]
1186:../QS/QS_ax12.c **** 
1187:../QS/QS_ax12.c **** 	AX12_prepare_commands = FALSE;
 3374              		.loc 2 1187 0
 3375 165c 40F20003 		movw	r3, #:lower16:AX12_prepare_commands
 3376 1660 C0F20003 		movt	r3, #:upper16:AX12_prepare_commands
 3377 1664 4FF00002 		mov	r2, #0
 3378 1668 1A70     		strb	r2, [r3, #0]
1188:../QS/QS_ax12.c **** 	AX12_instruction_write8(AX12_BROADCAST_ID, AX12_RETURN_LEVEL, AX12_STATUS_RETURN_MODE);	//Mettre l
 3379              		.loc 2 1188 0
 3380 166a 4FF0FE00 		mov	r0, #254
 3381 166e 4FF01001 		mov	r1, #16
 3382 1672 4FF00202 		mov	r2, #2
 3383 1676 FEF7F7FE 		bl	AX12_instruction_write8
1189:../QS/QS_ax12.c **** 
1190:../QS/QS_ax12.c **** 	for(i=0; i<AX12_NUMBER; i++) {
 3384              		.loc 2 1190 0
 3385 167a 4FF00003 		mov	r3, #0
 3386 167e FB71     		strb	r3, [r7, #7]
 3387 1680 38E0     		b	.L216
 3388              	.L217:
1191:../QS/QS_ax12.c **** 		AX12_on_the_robot[i].angle_limit[0] = 0;
 3389              		.loc 2 1191 0 discriminator 2
 3390 1682 F979     		ldrb	r1, [r7, #7]	@ zero_extendqisi2
 3391 1684 40F20002 		movw	r2, #:lower16:AX12_on_the_robot
 3392 1688 C0F20002 		movt	r2, #:upper16:AX12_on_the_robot
 3393 168c 0B46     		mov	r3, r1
 3394 168e 4FEA8303 		lsl	r3, r3, #2
 3395 1692 5B18     		adds	r3, r3, r1
 3396 1694 4FEA4303 		lsl	r3, r3, #1
 3397 1698 D318     		adds	r3, r2, r3
 3398 169a 4FF00002 		mov	r2, #0
 3399 169e 9A80     		strh	r2, [r3, #4]	@ movhi
1192:../QS/QS_ax12.c **** 		AX12_on_the_robot[i].angle_limit[1] = 300;
 3400              		.loc 2 1192 0 discriminator 2
 3401 16a0 F979     		ldrb	r1, [r7, #7]	@ zero_extendqisi2
 3402 16a2 40F20002 		movw	r2, #:lower16:AX12_on_the_robot
 3403 16a6 C0F20002 		movt	r2, #:upper16:AX12_on_the_robot
 3404 16aa 0B46     		mov	r3, r1
 3405 16ac 4FEA8303 		lsl	r3, r3, #2
 3406 16b0 5B18     		adds	r3, r3, r1
 3407 16b2 4FEA4303 		lsl	r3, r3, #1
 3408 16b6 D318     		adds	r3, r2, r3
 3409 16b8 03F10203 		add	r3, r3, #2
 3410 16bc 4FF49672 		mov	r2, #300
 3411 16c0 9A80     		strh	r2, [r3, #4]	@ movhi
1193:../QS/QS_ax12.c **** 
1194:../QS/QS_ax12.c **** 		AX12_on_the_robot[i].is_wheel_enabled = FALSE;
 3412              		.loc 2 1194 0 discriminator 2
 3413 16c2 F979     		ldrb	r1, [r7, #7]	@ zero_extendqisi2
 3414 16c4 40F20002 		movw	r2, #:lower16:AX12_on_the_robot
 3415 16c8 C0F20002 		movt	r2, #:upper16:AX12_on_the_robot
 3416 16cc 0B46     		mov	r3, r1
 3417 16ce 4FEA8303 		lsl	r3, r3, #2
 3418 16d2 5B18     		adds	r3, r3, r1
 3419 16d4 4FEA4303 		lsl	r3, r3, #1
 3420 16d8 D318     		adds	r3, r2, r3
 3421 16da 03F10803 		add	r3, r3, #8
 3422 16de 4FF00002 		mov	r2, #0
 3423 16e2 1A70     		strb	r2, [r3, #0]
1195:../QS/QS_ax12.c **** 		AX12_instruction_reset_last_status(i);
 3424              		.loc 2 1195 0 discriminator 2
 3425 16e4 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 3426 16e6 1846     		mov	r0, r3
 3427 16e8 FFF75AF8 		bl	AX12_instruction_reset_last_status
1190:../QS/QS_ax12.c **** 	for(i=0; i<AX12_NUMBER; i++) {
 3428              		.loc 2 1190 0 discriminator 2
 3429 16ec FB79     		ldrb	r3, [r7, #7]
 3430 16ee 03F10103 		add	r3, r3, #1
 3431 16f2 FB71     		strb	r3, [r7, #7]
 3432              	.L216:
1190:../QS/QS_ax12.c **** 	for(i=0; i<AX12_NUMBER; i++) {
 3433              		.loc 2 1190 0 is_stmt 0 discriminator 1
 3434 16f4 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 3435 16f6 062B     		cmp	r3, #6
 3436 16f8 C3D9     		bls	.L217
 3437 16fa 00E0     		b	.L213
 3438              	.L218:
1181:../QS/QS_ax12.c **** 		return;
 3439              		.loc 2 1181 0 is_stmt 1
 3440 16fc 00BF     		nop
 3441              	.L213:
1196:../QS/QS_ax12.c **** 	}
1197:../QS/QS_ax12.c **** }
 3442              		.loc 2 1197 0
 3443 16fe 07F10807 		add	r7, r7, #8
 3444 1702 BD46     		mov	sp, r7
 3445 1704 80BD     		pop	{r7, pc}
 3446              		.cfi_endproc
 3447              	.LFE136:
 3449 1706 00BF     		.align	2
 3450              		.global	AX12_is_ready
 3451              		.thumb
 3452              		.thumb_func
 3454              	AX12_is_ready:
 3455              	.LFB137:
1198:../QS/QS_ax12.c **** 
1199:../QS/QS_ax12.c **** /* Fonction d'utilisation de l'AX12                                        */
1200:../QS/QS_ax12.c **** 
1201:../QS/QS_ax12.c **** //Configuration de l'AX12, perdure aprs mise hors tension sauf pour le verouillage de la config (l
1202:../QS/QS_ax12.c **** //Units:
1203:../QS/QS_ax12.c **** // Angles en degrs
1204:../QS/QS_ax12.c **** // Vitesse en degre par seconde
1205:../QS/QS_ax12.c **** // Voltage en dixime de volt (50 => 5.0V)
1206:../QS/QS_ax12.c **** // Temprature en degre celcius
1207:../QS/QS_ax12.c **** // Pourcentage entre 0 et 100
1208:../QS/QS_ax12.c **** 
1209:../QS/QS_ax12.c **** //Angle max: 360
1210:../QS/QS_ax12.c **** #define AX12_MAX_DEGRE 360
1211:../QS/QS_ax12.c **** #define AX12_ANGLE_TO_DEGRE(angle) ((((Uint16)(angle))*75) >> 8) // >> 8 <=> / 256, 75/256 = 300/10
1212:../QS/QS_ax12.c **** //#define AX12_DEGRE_TO_ANGLE(angle) ((((Uint32)(angle)) << 8) / 75)	//L'utilisation d'entier 32bit
1213:../QS/QS_ax12.c **** //Aproximation pour eviter les entier 32bits (le dspic30F est 16bits), une unit d'angle vaut 0.296
1214:../QS/QS_ax12.c **** #define AX12_DEGRE_TO_ANGLE(angle) ((((Uint16)(angle)) << 7) / 38)
1215:../QS/QS_ax12.c **** 
1216:../QS/QS_ax12.c **** //Vitesse max: 500/seconde (83 tours/minute) (maximum support par la macro)
1217:../QS/QS_ax12.c **** //Le max de l'ax12 indiqu par la datasheet est de environ 360/s (60 tr/min)
1218:../QS/QS_ax12.c **** #define AX12_MAX_DPS 500
1219:../QS/QS_ax12.c **** #define AX12_SPEED_TO_DPS(angle_speed) ((((Uint16)(angle_speed))*85) >> 7) // >> 7 <=> / 128, 85/25
1220:../QS/QS_ax12.c **** #define AX12_DPS_TO_SPEED(angle_speed) ((((Uint16)(angle_speed)) << 7) / 85)
1221:../QS/QS_ax12.c **** 
1222:../QS/QS_ax12.c **** //Poucentage max: 100% (tout le monde le savait a, mais c'est bien de le reprciser :) )
1223:../QS/QS_ax12.c **** #define AX12_MAX_PERCENTAGE 100
1224:../QS/QS_ax12.c **** #define AX12_1024_TO_PERCENTAGE(percentage) ((((Uint16)(percentage))*25) >> 8) // >> 8 <=> / 256, 2
1225:../QS/QS_ax12.c **** #define AX12_PERCENTAGE_TO_1024(percentage) ((((Uint16)(percentage)) << 8) / 25)
1226:../QS/QS_ax12.c **** 
1227:../QS/QS_ax12.c **** //Implementation
1228:../QS/QS_ax12.c **** 
1229:../QS/QS_ax12.c **** bool_e AX12_is_ready(Uint8 id_servo) {
 3456              		.loc 2 1229 0
 3457              		.cfi_startproc
 3458              		@ args = 0, pretend = 0, frame = 8
 3459              		@ frame_needed = 1, uses_anonymous_args = 0
 3460 1708 80B5     		push	{r7, lr}
 3461              	.LCFI83:
 3462              		.cfi_def_cfa_offset 8
 3463              		.cfi_offset 7, -8
 3464              		.cfi_offset 14, -4
 3465 170a 82B0     		sub	sp, sp, #8
 3466              	.LCFI84:
 3467              		.cfi_def_cfa_offset 16
 3468 170c 00AF     		add	r7, sp, #0
 3469              	.LCFI85:
 3470              		.cfi_def_cfa_register 7
 3471 170e 0346     		mov	r3, r0
 3472 1710 FB71     		strb	r3, [r7, #7]
1230:../QS/QS_ax12.c **** 	return AX12_instruction_ping(id_servo);
 3473              		.loc 2 1230 0
 3474 1712 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 3475 1714 1846     		mov	r0, r3
 3476 1716 FEF74BFF 		bl	AX12_instruction_ping
 3477 171a 0346     		mov	r3, r0
1231:../QS/QS_ax12.c **** }
 3478              		.loc 2 1231 0
 3479 171c 1846     		mov	r0, r3
 3480 171e 07F10807 		add	r7, r7, #8
 3481 1722 BD46     		mov	sp, r7
 3482 1724 80BD     		pop	{r7, pc}
 3483              		.cfi_endproc
 3484              	.LFE137:
 3486 1726 00BF     		.align	2
 3487              		.global	AX12_get_last_error
 3488              		.thumb
 3489              		.thumb_func
 3491              	AX12_get_last_error:
 3492              	.LFB138:
1232:../QS/QS_ax12.c **** 
1233:../QS/QS_ax12.c **** AX12_status_t AX12_get_last_error(Uint8 id_servo) {
 3493              		.loc 2 1233 0
 3494              		.cfi_startproc
 3495              		@ args = 0, pretend = 0, frame = 24
 3496              		@ frame_needed = 1, uses_anonymous_args = 0
 3497 1728 80B5     		push	{r7, lr}
 3498              	.LCFI86:
 3499              		.cfi_def_cfa_offset 8
 3500              		.cfi_offset 7, -8
 3501              		.cfi_offset 14, -4
 3502 172a 86B0     		sub	sp, sp, #24
 3503              	.LCFI87:
 3504              		.cfi_def_cfa_offset 32
 3505 172c 00AF     		add	r7, sp, #0
 3506              	.LCFI88:
 3507              		.cfi_def_cfa_register 7
 3508 172e 0346     		mov	r3, r0
 3509 1730 FB73     		strb	r3, [r7, #15]
1234:../QS/QS_ax12.c **** 	return AX12_instruction_get_last_status(id_servo);
 3510              		.loc 2 1234 0
 3511 1732 FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 3512 1734 1846     		mov	r0, r3
 3513 1736 FFF70FF8 		bl	AX12_instruction_get_last_status
 3514 173a 3880     		strh	r0, [r7, #0]	@ movhi
 3515 173c C0F30F43 		ubfx	r3, r0, #16, #16
 3516 1740 7B80     		strh	r3, [r7, #2]	@ movhi
 3517 1742 3B68     		ldr	r3, [r7, #0]
 3518 1744 7B61     		str	r3, [r7, #20]
 3519 1746 4FF00003 		mov	r3, #0
 3520 174a BA8A     		ldrh	r2, [r7, #20]
 3521 174c 62F30F03 		bfi	r3, r2, #0, #16
 3522 1750 FA8A     		ldrh	r2, [r7, #22]
 3523 1752 62F31F43 		bfi	r3, r2, #16, #16
1235:../QS/QS_ax12.c **** }
 3524              		.loc 2 1235 0
 3525 1756 1846     		mov	r0, r3
 3526 1758 07F11807 		add	r7, r7, #24
 3527 175c BD46     		mov	sp, r7
 3528 175e 80BD     		pop	{r7, pc}
 3529              		.cfi_endproc
 3530              	.LFE138:
 3532              		.align	2
 3533              		.global	AX12_reset_last_error
 3534              		.thumb
 3535              		.thumb_func
 3537              	AX12_reset_last_error:
 3538              	.LFB139:
1236:../QS/QS_ax12.c **** 
1237:../QS/QS_ax12.c **** void AX12_reset_last_error(Uint8 id_servo) {
 3539              		.loc 2 1237 0
 3540              		.cfi_startproc
 3541              		@ args = 0, pretend = 0, frame = 8
 3542              		@ frame_needed = 1, uses_anonymous_args = 0
 3543 1760 80B5     		push	{r7, lr}
 3544              	.LCFI89:
 3545              		.cfi_def_cfa_offset 8
 3546              		.cfi_offset 7, -8
 3547              		.cfi_offset 14, -4
 3548 1762 82B0     		sub	sp, sp, #8
 3549              	.LCFI90:
 3550              		.cfi_def_cfa_offset 16
 3551 1764 00AF     		add	r7, sp, #0
 3552              	.LCFI91:
 3553              		.cfi_def_cfa_register 7
 3554 1766 0346     		mov	r3, r0
 3555 1768 FB71     		strb	r3, [r7, #7]
1238:../QS/QS_ax12.c **** 	AX12_instruction_reset_last_status(id_servo);
 3556              		.loc 2 1238 0
 3557 176a FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 3558 176c 1846     		mov	r0, r3
 3559 176e FFF717F8 		bl	AX12_instruction_reset_last_status
1239:../QS/QS_ax12.c **** }
 3560              		.loc 2 1239 0
 3561 1772 07F10807 		add	r7, r7, #8
 3562 1776 BD46     		mov	sp, r7
 3563 1778 80BD     		pop	{r7, pc}
 3564              		.cfi_endproc
 3565              	.LFE139:
 3567 177a 00BF     		.align	2
 3568              		.global	AX12_is_buffer_full
 3569              		.thumb
 3570              		.thumb_func
 3572              	AX12_is_buffer_full:
 3573              	.LFB140:
1240:../QS/QS_ax12.c **** 
1241:../QS/QS_ax12.c **** bool_e AX12_is_buffer_full() {
 3574              		.loc 2 1241 0
 3575              		.cfi_startproc
 3576              		@ args = 0, pretend = 0, frame = 0
 3577              		@ frame_needed = 1, uses_anonymous_args = 0
 3578 177c 80B5     		push	{r7, lr}
 3579              	.LCFI92:
 3580              		.cfi_def_cfa_offset 8
 3581              		.cfi_offset 7, -8
 3582              		.cfi_offset 14, -4
 3583 177e 00AF     		add	r7, sp, #0
 3584              	.LCFI93:
 3585              		.cfi_def_cfa_register 7
1242:../QS/QS_ax12.c **** 	return AX12_instruction_buffer_is_full();
 3586              		.loc 2 1242 0
 3587 1780 FEF756FF 		bl	AX12_instruction_buffer_is_full
 3588 1784 0346     		mov	r3, r0
1243:../QS/QS_ax12.c **** }
 3589              		.loc 2 1243 0
 3590 1786 1846     		mov	r0, r3
 3591 1788 80BD     		pop	{r7, pc}
 3592              		.cfi_endproc
 3593              	.LFE140:
 3595 178a 00BF     		.align	2
 3596              		.global	AX12_start_command_block
 3597              		.thumb
 3598              		.thumb_func
 3600              	AX12_start_command_block:
 3601              	.LFB141:
1244:../QS/QS_ax12.c **** 
1245:../QS/QS_ax12.c **** void AX12_start_command_block() {
 3602              		.loc 2 1245 0
 3603              		.cfi_startproc
 3604              		@ args = 0, pretend = 0, frame = 0
 3605              		@ frame_needed = 1, uses_anonymous_args = 0
 3606              		@ link register save eliminated.
 3607 178c 80B4     		push	{r7}
 3608              	.LCFI94:
 3609              		.cfi_def_cfa_offset 4
 3610              		.cfi_offset 7, -4
 3611 178e 00AF     		add	r7, sp, #0
 3612              	.LCFI95:
 3613              		.cfi_def_cfa_register 7
1246:../QS/QS_ax12.c **** 	AX12_prepare_commands = TRUE;
 3614              		.loc 2 1246 0
 3615 1790 40F20003 		movw	r3, #:lower16:AX12_prepare_commands
 3616 1794 C0F20003 		movt	r3, #:upper16:AX12_prepare_commands
 3617 1798 4FF00102 		mov	r2, #1
 3618 179c 1A70     		strb	r2, [r3, #0]
1247:../QS/QS_ax12.c **** }
 3619              		.loc 2 1247 0
 3620 179e BD46     		mov	sp, r7
 3621 17a0 80BC     		pop	{r7}
 3622 17a2 7047     		bx	lr
 3623              		.cfi_endproc
 3624              	.LFE141:
 3626              		.align	2
 3627              		.global	AX12_end_command_block
 3628              		.thumb
 3629              		.thumb_func
 3631              	AX12_end_command_block:
 3632              	.LFB142:
1248:../QS/QS_ax12.c **** 
1249:../QS/QS_ax12.c **** void AX12_end_command_block() {
 3633              		.loc 2 1249 0
 3634              		.cfi_startproc
 3635              		@ args = 0, pretend = 0, frame = 0
 3636              		@ frame_needed = 1, uses_anonymous_args = 0
 3637 17a4 80B5     		push	{r7, lr}
 3638              	.LCFI96:
 3639              		.cfi_def_cfa_offset 8
 3640              		.cfi_offset 7, -8
 3641              		.cfi_offset 14, -4
 3642 17a6 00AF     		add	r7, sp, #0
 3643              	.LCFI97:
 3644              		.cfi_def_cfa_register 7
1250:../QS/QS_ax12.c **** 	AX12_instruction_async_execute_write();
 3645              		.loc 2 1250 0
 3646 17a8 FEF7B6FD 		bl	AX12_instruction_async_execute_write
1251:../QS/QS_ax12.c **** 	AX12_prepare_commands = FALSE;
 3647              		.loc 2 1251 0
 3648 17ac 40F20003 		movw	r3, #:lower16:AX12_prepare_commands
 3649 17b0 C0F20003 		movt	r3, #:upper16:AX12_prepare_commands
 3650 17b4 4FF00002 		mov	r2, #0
 3651 17b8 1A70     		strb	r2, [r3, #0]
1252:../QS/QS_ax12.c **** }
 3652              		.loc 2 1252 0
 3653 17ba 80BD     		pop	{r7, pc}
 3654              		.cfi_endproc
 3655              	.LFE142:
 3657              		.align	2
 3658              		.global	AX12_config_is_locked
 3659              		.thumb
 3660              		.thumb_func
 3662              	AX12_config_is_locked:
 3663              	.LFB143:
1253:../QS/QS_ax12.c **** 
1254:../QS/QS_ax12.c **** #if AX12_STATUS_RETURN_MODE != AX12_STATUS_RETURN_NEVER
1255:../QS/QS_ax12.c **** bool_e AX12_config_is_locked(Uint8 id_servo) {
 3664              		.loc 2 1255 0
 3665              		.cfi_startproc
 3666              		@ args = 0, pretend = 0, frame = 8
 3667              		@ frame_needed = 1, uses_anonymous_args = 0
 3668 17bc 80B5     		push	{r7, lr}
 3669              	.LCFI98:
 3670              		.cfi_def_cfa_offset 8
 3671              		.cfi_offset 7, -8
 3672              		.cfi_offset 14, -4
 3673 17be 82B0     		sub	sp, sp, #8
 3674              	.LCFI99:
 3675              		.cfi_def_cfa_offset 16
 3676 17c0 00AF     		add	r7, sp, #0
 3677              	.LCFI100:
 3678              		.cfi_def_cfa_register 7
 3679 17c2 0346     		mov	r3, r0
 3680 17c4 FB71     		strb	r3, [r7, #7]
1256:../QS/QS_ax12.c **** 	return AX12_instruction_read8(id_servo, AX12_LOCK, NULL) != 0;
 3681              		.loc 2 1256 0
 3682 17c6 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 3683 17c8 1846     		mov	r0, r3
 3684 17ca 4FF02F01 		mov	r1, #47
 3685 17ce 4FF00002 		mov	r2, #0
 3686 17d2 FEF7BDFD 		bl	AX12_instruction_read8
 3687 17d6 0346     		mov	r3, r0
 3688 17d8 002B     		cmp	r3, #0
 3689 17da 0CBF     		ite	eq
 3690 17dc 0023     		moveq	r3, #0
 3691 17de 0123     		movne	r3, #1
 3692 17e0 DBB2     		uxtb	r3, r3
1257:../QS/QS_ax12.c **** }
 3693              		.loc 2 1257 0
 3694 17e2 1846     		mov	r0, r3
 3695 17e4 07F10807 		add	r7, r7, #8
 3696 17e8 BD46     		mov	sp, r7
 3697 17ea 80BD     		pop	{r7, pc}
 3698              		.cfi_endproc
 3699              	.LFE143:
 3701              		.align	2
 3702              		.global	AX12_config_get_model_number
 3703              		.thumb
 3704              		.thumb_func
 3706              	AX12_config_get_model_number:
 3707              	.LFB144:
1258:../QS/QS_ax12.c **** 
1259:../QS/QS_ax12.c **** Uint16 AX12_config_get_model_number(Uint8 id_servo) {
 3708              		.loc 2 1259 0
 3709              		.cfi_startproc
 3710              		@ args = 0, pretend = 0, frame = 8
 3711              		@ frame_needed = 1, uses_anonymous_args = 0
 3712 17ec 80B5     		push	{r7, lr}
 3713              	.LCFI101:
 3714              		.cfi_def_cfa_offset 8
 3715              		.cfi_offset 7, -8
 3716              		.cfi_offset 14, -4
 3717 17ee 82B0     		sub	sp, sp, #8
 3718              	.LCFI102:
 3719              		.cfi_def_cfa_offset 16
 3720 17f0 00AF     		add	r7, sp, #0
 3721              	.LCFI103:
 3722              		.cfi_def_cfa_register 7
 3723 17f2 0346     		mov	r3, r0
 3724 17f4 FB71     		strb	r3, [r7, #7]
1260:../QS/QS_ax12.c **** 	return AX12_instruction_read16(id_servo, AX12_MODEL_NUMBER_L, NULL);
 3725              		.loc 2 1260 0
 3726 17f6 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 3727 17f8 1846     		mov	r0, r3
 3728 17fa 4FF00001 		mov	r1, #0
 3729 17fe 4FF00002 		mov	r2, #0
 3730 1802 FEF7EBFD 		bl	AX12_instruction_read16
 3731 1806 0346     		mov	r3, r0
1261:../QS/QS_ax12.c **** }
 3732              		.loc 2 1261 0
 3733 1808 1846     		mov	r0, r3
 3734 180a 07F10807 		add	r7, r7, #8
 3735 180e BD46     		mov	sp, r7
 3736 1810 80BD     		pop	{r7, pc}
 3737              		.cfi_endproc
 3738              	.LFE144:
 3740 1812 00BF     		.align	2
 3741              		.global	AX12_config_get_firmware_version
 3742              		.thumb
 3743              		.thumb_func
 3745              	AX12_config_get_firmware_version:
 3746              	.LFB145:
1262:../QS/QS_ax12.c **** 
1263:../QS/QS_ax12.c **** Uint8  AX12_config_get_firmware_version(Uint8 id_servo) {
 3747              		.loc 2 1263 0
 3748              		.cfi_startproc
 3749              		@ args = 0, pretend = 0, frame = 8
 3750              		@ frame_needed = 1, uses_anonymous_args = 0
 3751 1814 80B5     		push	{r7, lr}
 3752              	.LCFI104:
 3753              		.cfi_def_cfa_offset 8
 3754              		.cfi_offset 7, -8
 3755              		.cfi_offset 14, -4
 3756 1816 82B0     		sub	sp, sp, #8
 3757              	.LCFI105:
 3758              		.cfi_def_cfa_offset 16
 3759 1818 00AF     		add	r7, sp, #0
 3760              	.LCFI106:
 3761              		.cfi_def_cfa_register 7
 3762 181a 0346     		mov	r3, r0
 3763 181c FB71     		strb	r3, [r7, #7]
1264:../QS/QS_ax12.c **** 	return AX12_instruction_read8(id_servo, AX12_VERSION, NULL);
 3764              		.loc 2 1264 0
 3765 181e FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 3766 1820 1846     		mov	r0, r3
 3767 1822 4FF00201 		mov	r1, #2
 3768 1826 4FF00002 		mov	r2, #0
 3769 182a FEF791FD 		bl	AX12_instruction_read8
 3770 182e 0346     		mov	r3, r0
1265:../QS/QS_ax12.c **** }
 3771              		.loc 2 1265 0
 3772 1830 1846     		mov	r0, r3
 3773 1832 07F10807 		add	r7, r7, #8
 3774 1836 BD46     		mov	sp, r7
 3775 1838 80BD     		pop	{r7, pc}
 3776              		.cfi_endproc
 3777              	.LFE145:
 3779 183a 00BF     		.align	2
 3780              		.global	AX12_config_get_return_delay_time
 3781              		.thumb
 3782              		.thumb_func
 3784              	AX12_config_get_return_delay_time:
 3785              	.LFB146:
1266:../QS/QS_ax12.c **** 
1267:../QS/QS_ax12.c **** Uint16 AX12_config_get_return_delay_time(Uint8 id_servo) {
 3786              		.loc 2 1267 0
 3787              		.cfi_startproc
 3788              		@ args = 0, pretend = 0, frame = 8
 3789              		@ frame_needed = 1, uses_anonymous_args = 0
 3790 183c 80B5     		push	{r7, lr}
 3791              	.LCFI107:
 3792              		.cfi_def_cfa_offset 8
 3793              		.cfi_offset 7, -8
 3794              		.cfi_offset 14, -4
 3795 183e 82B0     		sub	sp, sp, #8
 3796              	.LCFI108:
 3797              		.cfi_def_cfa_offset 16
 3798 1840 00AF     		add	r7, sp, #0
 3799              	.LCFI109:
 3800              		.cfi_def_cfa_register 7
 3801 1842 0346     		mov	r3, r0
 3802 1844 FB71     		strb	r3, [r7, #7]
1268:../QS/QS_ax12.c **** 	return ((Uint16)AX12_instruction_read8(id_servo, AX12_RETURN_DELAY_TIME, NULL)) * 2;
 3803              		.loc 2 1268 0
 3804 1846 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 3805 1848 1846     		mov	r0, r3
 3806 184a 4FF00501 		mov	r1, #5
 3807 184e 4FF00002 		mov	r2, #0
 3808 1852 FEF77DFD 		bl	AX12_instruction_read8
 3809 1856 0346     		mov	r3, r0
 3810 1858 4FEA4303 		lsl	r3, r3, #1
 3811 185c 9BB2     		uxth	r3, r3
1269:../QS/QS_ax12.c **** }
 3812              		.loc 2 1269 0
 3813 185e 1846     		mov	r0, r3
 3814 1860 07F10807 		add	r7, r7, #8
 3815 1864 BD46     		mov	sp, r7
 3816 1866 80BD     		pop	{r7, pc}
 3817              		.cfi_endproc
 3818              	.LFE146:
 3820              		.align	2
 3821              		.global	AX12_config_get_minimal_angle
 3822              		.thumb
 3823              		.thumb_func
 3825              	AX12_config_get_minimal_angle:
 3826              	.LFB147:
1270:../QS/QS_ax12.c **** 
1271:../QS/QS_ax12.c **** Uint16 AX12_config_get_minimal_angle(Uint8 id_servo) {
 3827              		.loc 2 1271 0
 3828              		.cfi_startproc
 3829              		@ args = 0, pretend = 0, frame = 8
 3830              		@ frame_needed = 1, uses_anonymous_args = 0
 3831 1868 80B5     		push	{r7, lr}
 3832              	.LCFI110:
 3833              		.cfi_def_cfa_offset 8
 3834              		.cfi_offset 7, -8
 3835              		.cfi_offset 14, -4
 3836 186a 82B0     		sub	sp, sp, #8
 3837              	.LCFI111:
 3838              		.cfi_def_cfa_offset 16
 3839 186c 00AF     		add	r7, sp, #0
 3840              	.LCFI112:
 3841              		.cfi_def_cfa_register 7
 3842 186e 0346     		mov	r3, r0
 3843 1870 FB71     		strb	r3, [r7, #7]
1272:../QS/QS_ax12.c **** 	return AX12_ANGLE_TO_DEGRE(AX12_instruction_read16(id_servo, AX12_CW_ANGLE_LIMIT_L, NULL));
 3844              		.loc 2 1272 0
 3845 1872 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 3846 1874 1846     		mov	r0, r3
 3847 1876 4FF00601 		mov	r1, #6
 3848 187a 4FF00002 		mov	r2, #0
 3849 187e FEF7ADFD 		bl	AX12_instruction_read16
 3850 1882 0346     		mov	r3, r0
 3851 1884 1A46     		mov	r2, r3
 3852 1886 1346     		mov	r3, r2
 3853 1888 4FEA8303 		lsl	r3, r3, #2
 3854 188c 9B18     		adds	r3, r3, r2
 3855 188e 4FEA0312 		lsl	r2, r3, #4
 3856 1892 D31A     		subs	r3, r2, r3
 3857 1894 4FEA2323 		asr	r3, r3, #8
 3858 1898 9BB2     		uxth	r3, r3
1273:../QS/QS_ax12.c **** }
 3859              		.loc 2 1273 0
 3860 189a 1846     		mov	r0, r3
 3861 189c 07F10807 		add	r7, r7, #8
 3862 18a0 BD46     		mov	sp, r7
 3863 18a2 80BD     		pop	{r7, pc}
 3864              		.cfi_endproc
 3865              	.LFE147:
 3867              		.align	2
 3868              		.global	AX12_config_get_maximal_angle
 3869              		.thumb
 3870              		.thumb_func
 3872              	AX12_config_get_maximal_angle:
 3873              	.LFB148:
1274:../QS/QS_ax12.c **** 
1275:../QS/QS_ax12.c **** Uint16 AX12_config_get_maximal_angle(Uint8 id_servo) {
 3874              		.loc 2 1275 0
 3875              		.cfi_startproc
 3876              		@ args = 0, pretend = 0, frame = 8
 3877              		@ frame_needed = 1, uses_anonymous_args = 0
 3878 18a4 80B5     		push	{r7, lr}
 3879              	.LCFI113:
 3880              		.cfi_def_cfa_offset 8
 3881              		.cfi_offset 7, -8
 3882              		.cfi_offset 14, -4
 3883 18a6 82B0     		sub	sp, sp, #8
 3884              	.LCFI114:
 3885              		.cfi_def_cfa_offset 16
 3886 18a8 00AF     		add	r7, sp, #0
 3887              	.LCFI115:
 3888              		.cfi_def_cfa_register 7
 3889 18aa 0346     		mov	r3, r0
 3890 18ac FB71     		strb	r3, [r7, #7]
1276:../QS/QS_ax12.c **** 	return AX12_ANGLE_TO_DEGRE(AX12_instruction_read16(id_servo, AX12_CCW_ANGLE_LIMIT_L, NULL));
 3891              		.loc 2 1276 0
 3892 18ae FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 3893 18b0 1846     		mov	r0, r3
 3894 18b2 4FF00801 		mov	r1, #8
 3895 18b6 4FF00002 		mov	r2, #0
 3896 18ba FEF78FFD 		bl	AX12_instruction_read16
 3897 18be 0346     		mov	r3, r0
 3898 18c0 1A46     		mov	r2, r3
 3899 18c2 1346     		mov	r3, r2
 3900 18c4 4FEA8303 		lsl	r3, r3, #2
 3901 18c8 9B18     		adds	r3, r3, r2
 3902 18ca 4FEA0312 		lsl	r2, r3, #4
 3903 18ce D31A     		subs	r3, r2, r3
 3904 18d0 4FEA2323 		asr	r3, r3, #8
 3905 18d4 9BB2     		uxth	r3, r3
1277:../QS/QS_ax12.c **** }
 3906              		.loc 2 1277 0
 3907 18d6 1846     		mov	r0, r3
 3908 18d8 07F10807 		add	r7, r7, #8
 3909 18dc BD46     		mov	sp, r7
 3910 18de 80BD     		pop	{r7, pc}
 3911              		.cfi_endproc
 3912              	.LFE148:
 3914              		.align	2
 3915              		.global	AX12_config_get_temperature_limit
 3916              		.thumb
 3917              		.thumb_func
 3919              	AX12_config_get_temperature_limit:
 3920              	.LFB149:
1278:../QS/QS_ax12.c **** 
1279:../QS/QS_ax12.c **** Uint8  AX12_config_get_temperature_limit(Uint8 id_servo) {
 3921              		.loc 2 1279 0
 3922              		.cfi_startproc
 3923              		@ args = 0, pretend = 0, frame = 8
 3924              		@ frame_needed = 1, uses_anonymous_args = 0
 3925 18e0 80B5     		push	{r7, lr}
 3926              	.LCFI116:
 3927              		.cfi_def_cfa_offset 8
 3928              		.cfi_offset 7, -8
 3929              		.cfi_offset 14, -4
 3930 18e2 82B0     		sub	sp, sp, #8
 3931              	.LCFI117:
 3932              		.cfi_def_cfa_offset 16
 3933 18e4 00AF     		add	r7, sp, #0
 3934              	.LCFI118:
 3935              		.cfi_def_cfa_register 7
 3936 18e6 0346     		mov	r3, r0
 3937 18e8 FB71     		strb	r3, [r7, #7]
1280:../QS/QS_ax12.c **** 	return AX12_instruction_read8(id_servo, AX12_LIMIT_TEMPERATURE, NULL);
 3938              		.loc 2 1280 0
 3939 18ea FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 3940 18ec 1846     		mov	r0, r3
 3941 18ee 4FF00B01 		mov	r1, #11
 3942 18f2 4FF00002 		mov	r2, #0
 3943 18f6 FEF72BFD 		bl	AX12_instruction_read8
 3944 18fa 0346     		mov	r3, r0
1281:../QS/QS_ax12.c **** }
 3945              		.loc 2 1281 0
 3946 18fc 1846     		mov	r0, r3
 3947 18fe 07F10807 		add	r7, r7, #8
 3948 1902 BD46     		mov	sp, r7
 3949 1904 80BD     		pop	{r7, pc}
 3950              		.cfi_endproc
 3951              	.LFE149:
 3953 1906 00BF     		.align	2
 3954              		.global	AX12_config_get_lowest_voltage
 3955              		.thumb
 3956              		.thumb_func
 3958              	AX12_config_get_lowest_voltage:
 3959              	.LFB150:
1282:../QS/QS_ax12.c **** 
1283:../QS/QS_ax12.c **** Uint8  AX12_config_get_lowest_voltage(Uint8 id_servo) {
 3960              		.loc 2 1283 0
 3961              		.cfi_startproc
 3962              		@ args = 0, pretend = 0, frame = 8
 3963              		@ frame_needed = 1, uses_anonymous_args = 0
 3964 1908 80B5     		push	{r7, lr}
 3965              	.LCFI119:
 3966              		.cfi_def_cfa_offset 8
 3967              		.cfi_offset 7, -8
 3968              		.cfi_offset 14, -4
 3969 190a 82B0     		sub	sp, sp, #8
 3970              	.LCFI120:
 3971              		.cfi_def_cfa_offset 16
 3972 190c 00AF     		add	r7, sp, #0
 3973              	.LCFI121:
 3974              		.cfi_def_cfa_register 7
 3975 190e 0346     		mov	r3, r0
 3976 1910 FB71     		strb	r3, [r7, #7]
1284:../QS/QS_ax12.c **** 	return AX12_instruction_read8(id_servo, AX12_DOWN_LIMIT_VOLTAGE, NULL);
 3977              		.loc 2 1284 0
 3978 1912 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 3979 1914 1846     		mov	r0, r3
 3980 1916 4FF00C01 		mov	r1, #12
 3981 191a 4FF00002 		mov	r2, #0
 3982 191e FEF717FD 		bl	AX12_instruction_read8
 3983 1922 0346     		mov	r3, r0
1285:../QS/QS_ax12.c **** }
 3984              		.loc 2 1285 0
 3985 1924 1846     		mov	r0, r3
 3986 1926 07F10807 		add	r7, r7, #8
 3987 192a BD46     		mov	sp, r7
 3988 192c 80BD     		pop	{r7, pc}
 3989              		.cfi_endproc
 3990              	.LFE150:
 3992 192e 00BF     		.align	2
 3993              		.global	AX12_config_get_highest_voltage
 3994              		.thumb
 3995              		.thumb_func
 3997              	AX12_config_get_highest_voltage:
 3998              	.LFB151:
1286:../QS/QS_ax12.c **** 
1287:../QS/QS_ax12.c **** Uint8  AX12_config_get_highest_voltage(Uint8 id_servo) {
 3999              		.loc 2 1287 0
 4000              		.cfi_startproc
 4001              		@ args = 0, pretend = 0, frame = 8
 4002              		@ frame_needed = 1, uses_anonymous_args = 0
 4003 1930 80B5     		push	{r7, lr}
 4004              	.LCFI122:
 4005              		.cfi_def_cfa_offset 8
 4006              		.cfi_offset 7, -8
 4007              		.cfi_offset 14, -4
 4008 1932 82B0     		sub	sp, sp, #8
 4009              	.LCFI123:
 4010              		.cfi_def_cfa_offset 16
 4011 1934 00AF     		add	r7, sp, #0
 4012              	.LCFI124:
 4013              		.cfi_def_cfa_register 7
 4014 1936 0346     		mov	r3, r0
 4015 1938 FB71     		strb	r3, [r7, #7]
1288:../QS/QS_ax12.c **** 	return AX12_instruction_read8(id_servo, AX12_UP_LIMIT_VOLTAGE, NULL);
 4016              		.loc 2 1288 0
 4017 193a FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 4018 193c 1846     		mov	r0, r3
 4019 193e 4FF00D01 		mov	r1, #13
 4020 1942 4FF00002 		mov	r2, #0
 4021 1946 FEF703FD 		bl	AX12_instruction_read8
 4022 194a 0346     		mov	r3, r0
1289:../QS/QS_ax12.c **** }
 4023              		.loc 2 1289 0
 4024 194c 1846     		mov	r0, r3
 4025 194e 07F10807 		add	r7, r7, #8
 4026 1952 BD46     		mov	sp, r7
 4027 1954 80BD     		pop	{r7, pc}
 4028              		.cfi_endproc
 4029              	.LFE151:
 4031 1956 00BF     		.align	2
 4032              		.global	AX12_config_get_maximum_torque
 4033              		.thumb
 4034              		.thumb_func
 4036              	AX12_config_get_maximum_torque:
 4037              	.LFB152:
1290:../QS/QS_ax12.c **** 
1291:../QS/QS_ax12.c **** Uint8 AX12_config_get_maximum_torque(Uint8 id_servo) {
 4038              		.loc 2 1291 0
 4039              		.cfi_startproc
 4040              		@ args = 0, pretend = 0, frame = 16
 4041              		@ frame_needed = 1, uses_anonymous_args = 0
 4042 1958 90B5     		push	{r4, r7, lr}
 4043              	.LCFI125:
 4044              		.cfi_def_cfa_offset 12
 4045              		.cfi_offset 4, -12
 4046              		.cfi_offset 7, -8
 4047              		.cfi_offset 14, -4
 4048 195a 85B0     		sub	sp, sp, #20
 4049              	.LCFI126:
 4050              		.cfi_def_cfa_offset 32
 4051 195c 00AF     		add	r7, sp, #0
 4052              	.LCFI127:
 4053              		.cfi_def_cfa_register 7
 4054 195e 0346     		mov	r3, r0
 4055 1960 FB71     		strb	r3, [r7, #7]
1292:../QS/QS_ax12.c **** 	Uint16 value;    //On ne peut pas utiliser la lecture 16bits a cause d'un bug de l'AX12 (voir http
1293:../QS/QS_ax12.c **** 	value = AX12_instruction_read8(id_servo, AX12_MAX_TORQUE_L, NULL) | (AX12_instruction_read8(id_ser
 4056              		.loc 2 1293 0
 4057 1962 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 4058 1964 1846     		mov	r0, r3
 4059 1966 4FF00E01 		mov	r1, #14
 4060 196a 4FF00002 		mov	r2, #0
 4061 196e FEF7EFFC 		bl	AX12_instruction_read8
 4062 1972 0346     		mov	r3, r0
 4063 1974 1C46     		mov	r4, r3
 4064 1976 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 4065 1978 1846     		mov	r0, r3
 4066 197a 4FF00F01 		mov	r1, #15
 4067 197e 4FF00002 		mov	r2, #0
 4068 1982 FEF7E5FC 		bl	AX12_instruction_read8
 4069 1986 0346     		mov	r3, r0
 4070 1988 4FEA0323 		lsl	r3, r3, #8
 4071 198c 9BB2     		uxth	r3, r3
 4072 198e 2246     		mov	r2, r4	@ movhi
 4073 1990 1343     		orrs	r3, r3, r2
 4074 1992 9BB2     		uxth	r3, r3
 4075 1994 FB81     		strh	r3, [r7, #14]	@ movhi
1294:../QS/QS_ax12.c **** 	return (Uint8)AX12_1024_TO_PERCENTAGE(value);
 4076              		.loc 2 1294 0
 4077 1996 FA89     		ldrh	r2, [r7, #14]
 4078 1998 1346     		mov	r3, r2
 4079 199a 4FEA8303 		lsl	r3, r3, #2
 4080 199e 9B18     		adds	r3, r3, r2
 4081 19a0 4FEA8302 		lsl	r2, r3, #2
 4082 19a4 9B18     		adds	r3, r3, r2
 4083 19a6 4FEA2323 		asr	r3, r3, #8
 4084 19aa DBB2     		uxtb	r3, r3
1295:../QS/QS_ax12.c **** }
 4085              		.loc 2 1295 0
 4086 19ac 1846     		mov	r0, r3
 4087 19ae 07F11407 		add	r7, r7, #20
 4088 19b2 BD46     		mov	sp, r7
 4089 19b4 90BD     		pop	{r4, r7, pc}
 4090              		.cfi_endproc
 4091              	.LFE152:
 4093 19b6 00BF     		.align	2
 4094              		.global	AX12_config_get_status_return_mode
 4095              		.thumb
 4096              		.thumb_func
 4098              	AX12_config_get_status_return_mode:
 4099              	.LFB153:
1296:../QS/QS_ax12.c **** 
1297:../QS/QS_ax12.c **** Uint8  AX12_config_get_status_return_mode(Uint8 id_servo) {
 4100              		.loc 2 1297 0
 4101              		.cfi_startproc
 4102              		@ args = 0, pretend = 0, frame = 8
 4103              		@ frame_needed = 1, uses_anonymous_args = 0
 4104 19b8 80B5     		push	{r7, lr}
 4105              	.LCFI128:
 4106              		.cfi_def_cfa_offset 8
 4107              		.cfi_offset 7, -8
 4108              		.cfi_offset 14, -4
 4109 19ba 82B0     		sub	sp, sp, #8
 4110              	.LCFI129:
 4111              		.cfi_def_cfa_offset 16
 4112 19bc 00AF     		add	r7, sp, #0
 4113              	.LCFI130:
 4114              		.cfi_def_cfa_register 7
 4115 19be 0346     		mov	r3, r0
 4116 19c0 FB71     		strb	r3, [r7, #7]
1298:../QS/QS_ax12.c **** 	return AX12_instruction_read8(id_servo, AX12_RETURN_LEVEL, NULL);
 4117              		.loc 2 1298 0
 4118 19c2 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 4119 19c4 1846     		mov	r0, r3
 4120 19c6 4FF01001 		mov	r1, #16
 4121 19ca 4FF00002 		mov	r2, #0
 4122 19ce FEF7BFFC 		bl	AX12_instruction_read8
 4123 19d2 0346     		mov	r3, r0
1299:../QS/QS_ax12.c **** }
 4124              		.loc 2 1299 0
 4125 19d4 1846     		mov	r0, r3
 4126 19d6 07F10807 		add	r7, r7, #8
 4127 19da BD46     		mov	sp, r7
 4128 19dc 80BD     		pop	{r7, pc}
 4129              		.cfi_endproc
 4130              	.LFE153:
 4132 19de 00BF     		.align	2
 4133              		.global	AX12_config_get_error_before_led
 4134              		.thumb
 4135              		.thumb_func
 4137              	AX12_config_get_error_before_led:
 4138              	.LFB154:
1300:../QS/QS_ax12.c **** 
1301:../QS/QS_ax12.c **** Uint8  AX12_config_get_error_before_led(Uint8 id_servo) {
 4139              		.loc 2 1301 0
 4140              		.cfi_startproc
 4141              		@ args = 0, pretend = 0, frame = 8
 4142              		@ frame_needed = 1, uses_anonymous_args = 0
 4143 19e0 80B5     		push	{r7, lr}
 4144              	.LCFI131:
 4145              		.cfi_def_cfa_offset 8
 4146              		.cfi_offset 7, -8
 4147              		.cfi_offset 14, -4
 4148 19e2 82B0     		sub	sp, sp, #8
 4149              	.LCFI132:
 4150              		.cfi_def_cfa_offset 16
 4151 19e4 00AF     		add	r7, sp, #0
 4152              	.LCFI133:
 4153              		.cfi_def_cfa_register 7
 4154 19e6 0346     		mov	r3, r0
 4155 19e8 FB71     		strb	r3, [r7, #7]
1302:../QS/QS_ax12.c **** 	return AX12_instruction_read8(id_servo, AX12_ALARM_LED, NULL);
 4156              		.loc 2 1302 0
 4157 19ea FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 4158 19ec 1846     		mov	r0, r3
 4159 19ee 4FF01101 		mov	r1, #17
 4160 19f2 4FF00002 		mov	r2, #0
 4161 19f6 FEF7ABFC 		bl	AX12_instruction_read8
 4162 19fa 0346     		mov	r3, r0
1303:../QS/QS_ax12.c **** }
 4163              		.loc 2 1303 0
 4164 19fc 1846     		mov	r0, r3
 4165 19fe 07F10807 		add	r7, r7, #8
 4166 1a02 BD46     		mov	sp, r7
 4167 1a04 80BD     		pop	{r7, pc}
 4168              		.cfi_endproc
 4169              	.LFE154:
 4171 1a06 00BF     		.align	2
 4172              		.global	AX12_config_get_error_before_shutdown
 4173              		.thumb
 4174              		.thumb_func
 4176              	AX12_config_get_error_before_shutdown:
 4177              	.LFB155:
1304:../QS/QS_ax12.c **** 
1305:../QS/QS_ax12.c **** Uint8  AX12_config_get_error_before_shutdown(Uint8 id_servo) {
 4178              		.loc 2 1305 0
 4179              		.cfi_startproc
 4180              		@ args = 0, pretend = 0, frame = 8
 4181              		@ frame_needed = 1, uses_anonymous_args = 0
 4182 1a08 80B5     		push	{r7, lr}
 4183              	.LCFI134:
 4184              		.cfi_def_cfa_offset 8
 4185              		.cfi_offset 7, -8
 4186              		.cfi_offset 14, -4
 4187 1a0a 82B0     		sub	sp, sp, #8
 4188              	.LCFI135:
 4189              		.cfi_def_cfa_offset 16
 4190 1a0c 00AF     		add	r7, sp, #0
 4191              	.LCFI136:
 4192              		.cfi_def_cfa_register 7
 4193 1a0e 0346     		mov	r3, r0
 4194 1a10 FB71     		strb	r3, [r7, #7]
1306:../QS/QS_ax12.c **** 	return AX12_instruction_read8(id_servo, AX12_ALARM_SHUTDOWN, NULL);
 4195              		.loc 2 1306 0
 4196 1a12 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 4197 1a14 1846     		mov	r0, r3
 4198 1a16 4FF01201 		mov	r1, #18
 4199 1a1a 4FF00002 		mov	r2, #0
 4200 1a1e FEF797FC 		bl	AX12_instruction_read8
 4201 1a22 0346     		mov	r3, r0
1307:../QS/QS_ax12.c **** }
 4202              		.loc 2 1307 0
 4203 1a24 1846     		mov	r0, r3
 4204 1a26 07F10807 		add	r7, r7, #8
 4205 1a2a BD46     		mov	sp, r7
 4206 1a2c 80BD     		pop	{r7, pc}
 4207              		.cfi_endproc
 4208              	.LFE155:
 4210 1a2e 00BF     		.align	2
 4211              		.global	AX12_config_lock
 4212              		.thumb
 4213              		.thumb_func
 4215              	AX12_config_lock:
 4216              	.LFB156:
1308:../QS/QS_ax12.c **** #endif //AX12_STATUS_RETURN_MODE != AX12_STATUS_RETURN_NEVER
1309:../QS/QS_ax12.c **** 
1310:../QS/QS_ax12.c **** bool_e AX12_config_lock(Uint8 id_servo) {
 4217              		.loc 2 1310 0
 4218              		.cfi_startproc
 4219              		@ args = 0, pretend = 0, frame = 8
 4220              		@ frame_needed = 1, uses_anonymous_args = 0
 4221 1a30 80B5     		push	{r7, lr}
 4222              	.LCFI137:
 4223              		.cfi_def_cfa_offset 8
 4224              		.cfi_offset 7, -8
 4225              		.cfi_offset 14, -4
 4226 1a32 82B0     		sub	sp, sp, #8
 4227              	.LCFI138:
 4228              		.cfi_def_cfa_offset 16
 4229 1a34 00AF     		add	r7, sp, #0
 4230              	.LCFI139:
 4231              		.cfi_def_cfa_register 7
 4232 1a36 0346     		mov	r3, r0
 4233 1a38 FB71     		strb	r3, [r7, #7]
1311:../QS/QS_ax12.c **** 	return AX12_instruction_write8(id_servo, AX12_LOCK, 1);
 4234              		.loc 2 1311 0
 4235 1a3a FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 4236 1a3c 1846     		mov	r0, r3
 4237 1a3e 4FF02F01 		mov	r1, #47
 4238 1a42 4FF00102 		mov	r2, #1
 4239 1a46 FEF70FFD 		bl	AX12_instruction_write8
 4240 1a4a 0346     		mov	r3, r0
1312:../QS/QS_ax12.c **** }
 4241              		.loc 2 1312 0
 4242 1a4c 1846     		mov	r0, r3
 4243 1a4e 07F10807 		add	r7, r7, #8
 4244 1a52 BD46     		mov	sp, r7
 4245 1a54 80BD     		pop	{r7, pc}
 4246              		.cfi_endproc
 4247              	.LFE156:
 4249 1a56 00BF     		.align	2
 4250              		.global	AX12_config_set_return_delay_time
 4251              		.thumb
 4252              		.thumb_func
 4254              	AX12_config_set_return_delay_time:
 4255              	.LFB157:
1313:../QS/QS_ax12.c **** 
1314:../QS/QS_ax12.c **** bool_e AX12_config_set_return_delay_time(Uint8 id_servo, Uint16 delay_us) {
 4256              		.loc 2 1314 0
 4257              		.cfi_startproc
 4258              		@ args = 0, pretend = 0, frame = 8
 4259              		@ frame_needed = 1, uses_anonymous_args = 0
 4260 1a58 80B5     		push	{r7, lr}
 4261              	.LCFI140:
 4262              		.cfi_def_cfa_offset 8
 4263              		.cfi_offset 7, -8
 4264              		.cfi_offset 14, -4
 4265 1a5a 82B0     		sub	sp, sp, #8
 4266              	.LCFI141:
 4267              		.cfi_def_cfa_offset 16
 4268 1a5c 00AF     		add	r7, sp, #0
 4269              	.LCFI142:
 4270              		.cfi_def_cfa_register 7
 4271 1a5e 0246     		mov	r2, r0
 4272 1a60 0B46     		mov	r3, r1
 4273 1a62 FA71     		strb	r2, [r7, #7]
 4274 1a64 BB80     		strh	r3, [r7, #4]	@ movhi
1315:../QS/QS_ax12.c **** 	return AX12_instruction_write8(id_servo, AX12_RETURN_DELAY_TIME, (Uint8)(delay_us >> 1)); // >> 1 
 4275              		.loc 2 1315 0
 4276 1a66 BB88     		ldrh	r3, [r7, #4]
 4277 1a68 4FEA5303 		lsr	r3, r3, #1
 4278 1a6c 9BB2     		uxth	r3, r3
 4279 1a6e DBB2     		uxtb	r3, r3
 4280 1a70 FA79     		ldrb	r2, [r7, #7]	@ zero_extendqisi2
 4281 1a72 1046     		mov	r0, r2
 4282 1a74 4FF00501 		mov	r1, #5
 4283 1a78 1A46     		mov	r2, r3
 4284 1a7a FEF7F5FC 		bl	AX12_instruction_write8
 4285 1a7e 0346     		mov	r3, r0
1316:../QS/QS_ax12.c **** }
 4286              		.loc 2 1316 0
 4287 1a80 1846     		mov	r0, r3
 4288 1a82 07F10807 		add	r7, r7, #8
 4289 1a86 BD46     		mov	sp, r7
 4290 1a88 80BD     		pop	{r7, pc}
 4291              		.cfi_endproc
 4292              	.LFE157:
 4294 1a8a 00BF     		.align	2
 4295              		.global	AX12_config_set_minimal_angle
 4296              		.thumb
 4297              		.thumb_func
 4299              	AX12_config_set_minimal_angle:
 4300              	.LFB158:
1317:../QS/QS_ax12.c **** 
1318:../QS/QS_ax12.c **** bool_e AX12_config_set_minimal_angle(Uint8 id_servo, Uint16 degre) {
 4301              		.loc 2 1318 0
 4302              		.cfi_startproc
 4303              		@ args = 0, pretend = 0, frame = 8
 4304              		@ frame_needed = 1, uses_anonymous_args = 0
 4305 1a8c 80B5     		push	{r7, lr}
 4306              	.LCFI143:
 4307              		.cfi_def_cfa_offset 8
 4308              		.cfi_offset 7, -8
 4309              		.cfi_offset 14, -4
 4310 1a8e 82B0     		sub	sp, sp, #8
 4311              	.LCFI144:
 4312              		.cfi_def_cfa_offset 16
 4313 1a90 00AF     		add	r7, sp, #0
 4314              	.LCFI145:
 4315              		.cfi_def_cfa_register 7
 4316 1a92 0246     		mov	r2, r0
 4317 1a94 0B46     		mov	r3, r1
 4318 1a96 FA71     		strb	r2, [r7, #7]
 4319 1a98 BB80     		strh	r3, [r7, #4]	@ movhi
1319:../QS/QS_ax12.c **** 	if(degre > AX12_MAX_DEGRE) degre = AX12_MAX_DEGRE;
 4320              		.loc 2 1319 0
 4321 1a9a BB88     		ldrh	r3, [r7, #4]
 4322 1a9c B3F5B47F 		cmp	r3, #360
 4323 1aa0 02D9     		bls	.L259
 4324              		.loc 2 1319 0 is_stmt 0 discriminator 1
 4325 1aa2 4FF4B473 		mov	r3, #360
 4326 1aa6 BB80     		strh	r3, [r7, #4]	@ movhi
 4327              	.L259:
1320:../QS/QS_ax12.c **** 	return AX12_instruction_write16(id_servo, AX12_CW_ANGLE_LIMIT_L, AX12_DEGRE_TO_ANGLE(degre));
 4328              		.loc 2 1320 0 is_stmt 1
 4329 1aa8 BB88     		ldrh	r3, [r7, #4]
 4330 1aaa 4FEAC312 		lsl	r2, r3, #7
 4331 1aae 41F6F323 		movw	r3, #6899
 4332 1ab2 C6F6CA33 		movt	r3, 27594
 4333 1ab6 83FB0213 		smull	r1, r3, r3, r2
 4334 1aba 4FEA2311 		asr	r1, r3, #4
 4335 1abe 4FEAE273 		asr	r3, r2, #31
 4336 1ac2 CB1A     		subs	r3, r1, r3
 4337 1ac4 9BB2     		uxth	r3, r3
 4338 1ac6 FA79     		ldrb	r2, [r7, #7]	@ zero_extendqisi2
 4339 1ac8 1046     		mov	r0, r2
 4340 1aca 4FF00601 		mov	r1, #6
 4341 1ace 1A46     		mov	r2, r3
 4342 1ad0 FEF71CFD 		bl	AX12_instruction_write16
 4343 1ad4 0346     		mov	r3, r0
1321:../QS/QS_ax12.c **** }
 4344              		.loc 2 1321 0
 4345 1ad6 1846     		mov	r0, r3
 4346 1ad8 07F10807 		add	r7, r7, #8
 4347 1adc BD46     		mov	sp, r7
 4348 1ade 80BD     		pop	{r7, pc}
 4349              		.cfi_endproc
 4350              	.LFE158:
 4352              		.align	2
 4353              		.global	AX12_config_set_maximal_angle
 4354              		.thumb
 4355              		.thumb_func
 4357              	AX12_config_set_maximal_angle:
 4358              	.LFB159:
1322:../QS/QS_ax12.c **** 
1323:../QS/QS_ax12.c **** bool_e AX12_config_set_maximal_angle(Uint8 id_servo, Uint16 degre) {
 4359              		.loc 2 1323 0
 4360              		.cfi_startproc
 4361              		@ args = 0, pretend = 0, frame = 8
 4362              		@ frame_needed = 1, uses_anonymous_args = 0
 4363 1ae0 80B5     		push	{r7, lr}
 4364              	.LCFI146:
 4365              		.cfi_def_cfa_offset 8
 4366              		.cfi_offset 7, -8
 4367              		.cfi_offset 14, -4
 4368 1ae2 82B0     		sub	sp, sp, #8
 4369              	.LCFI147:
 4370              		.cfi_def_cfa_offset 16
 4371 1ae4 00AF     		add	r7, sp, #0
 4372              	.LCFI148:
 4373              		.cfi_def_cfa_register 7
 4374 1ae6 0246     		mov	r2, r0
 4375 1ae8 0B46     		mov	r3, r1
 4376 1aea FA71     		strb	r2, [r7, #7]
 4377 1aec BB80     		strh	r3, [r7, #4]	@ movhi
1324:../QS/QS_ax12.c **** 	if(degre > AX12_MAX_DEGRE) degre = AX12_MAX_DEGRE;
 4378              		.loc 2 1324 0
 4379 1aee BB88     		ldrh	r3, [r7, #4]
 4380 1af0 B3F5B47F 		cmp	r3, #360
 4381 1af4 02D9     		bls	.L262
 4382              		.loc 2 1324 0 is_stmt 0 discriminator 1
 4383 1af6 4FF4B473 		mov	r3, #360
 4384 1afa BB80     		strh	r3, [r7, #4]	@ movhi
 4385              	.L262:
1325:../QS/QS_ax12.c **** 	if(degre == 0) degre = 1;	//Si l'utilisateur met un angle mini et maxi  0, l'AX12 passera en mode
 4386              		.loc 2 1325 0 is_stmt 1
 4387 1afc BB88     		ldrh	r3, [r7, #4]
 4388 1afe 002B     		cmp	r3, #0
 4389 1b00 02D1     		bne	.L263
 4390              		.loc 2 1325 0 is_stmt 0 discriminator 1
 4391 1b02 4FF00103 		mov	r3, #1
 4392 1b06 BB80     		strh	r3, [r7, #4]	@ movhi
 4393              	.L263:
1326:../QS/QS_ax12.c **** 	return AX12_instruction_write16(id_servo, AX12_CCW_ANGLE_LIMIT_L, AX12_DEGRE_TO_ANGLE(degre));
 4394              		.loc 2 1326 0 is_stmt 1
 4395 1b08 BB88     		ldrh	r3, [r7, #4]
 4396 1b0a 4FEAC312 		lsl	r2, r3, #7
 4397 1b0e 41F6F323 		movw	r3, #6899
 4398 1b12 C6F6CA33 		movt	r3, 27594
 4399 1b16 83FB0213 		smull	r1, r3, r3, r2
 4400 1b1a 4FEA2311 		asr	r1, r3, #4
 4401 1b1e 4FEAE273 		asr	r3, r2, #31
 4402 1b22 CB1A     		subs	r3, r1, r3
 4403 1b24 9BB2     		uxth	r3, r3
 4404 1b26 FA79     		ldrb	r2, [r7, #7]	@ zero_extendqisi2
 4405 1b28 1046     		mov	r0, r2
 4406 1b2a 4FF00801 		mov	r1, #8
 4407 1b2e 1A46     		mov	r2, r3
 4408 1b30 FEF7ECFC 		bl	AX12_instruction_write16
 4409 1b34 0346     		mov	r3, r0
1327:../QS/QS_ax12.c **** }
 4410              		.loc 2 1327 0
 4411 1b36 1846     		mov	r0, r3
 4412 1b38 07F10807 		add	r7, r7, #8
 4413 1b3c BD46     		mov	sp, r7
 4414 1b3e 80BD     		pop	{r7, pc}
 4415              		.cfi_endproc
 4416              	.LFE159:
 4418              		.align	2
 4419              		.global	AX12_config_set_temperature_limit
 4420              		.thumb
 4421              		.thumb_func
 4423              	AX12_config_set_temperature_limit:
 4424              	.LFB160:
1328:../QS/QS_ax12.c **** 
1329:../QS/QS_ax12.c **** bool_e AX12_config_set_temperature_limit(Uint8 id_servo, Uint8 temperature) {
 4425              		.loc 2 1329 0
 4426              		.cfi_startproc
 4427              		@ args = 0, pretend = 0, frame = 8
 4428              		@ frame_needed = 1, uses_anonymous_args = 0
 4429 1b40 80B5     		push	{r7, lr}
 4430              	.LCFI149:
 4431              		.cfi_def_cfa_offset 8
 4432              		.cfi_offset 7, -8
 4433              		.cfi_offset 14, -4
 4434 1b42 82B0     		sub	sp, sp, #8
 4435              	.LCFI150:
 4436              		.cfi_def_cfa_offset 16
 4437 1b44 00AF     		add	r7, sp, #0
 4438              	.LCFI151:
 4439              		.cfi_def_cfa_register 7
 4440 1b46 0246     		mov	r2, r0
 4441 1b48 0B46     		mov	r3, r1
 4442 1b4a FA71     		strb	r2, [r7, #7]
 4443 1b4c BB71     		strb	r3, [r7, #6]
1330:../QS/QS_ax12.c **** 	return AX12_instruction_write8(id_servo, AX12_LIMIT_TEMPERATURE, temperature);
 4444              		.loc 2 1330 0
 4445 1b4e FA79     		ldrb	r2, [r7, #7]	@ zero_extendqisi2
 4446 1b50 BB79     		ldrb	r3, [r7, #6]	@ zero_extendqisi2
 4447 1b52 1046     		mov	r0, r2
 4448 1b54 4FF00B01 		mov	r1, #11
 4449 1b58 1A46     		mov	r2, r3
 4450 1b5a FEF785FC 		bl	AX12_instruction_write8
 4451 1b5e 0346     		mov	r3, r0
1331:../QS/QS_ax12.c **** }
 4452              		.loc 2 1331 0
 4453 1b60 1846     		mov	r0, r3
 4454 1b62 07F10807 		add	r7, r7, #8
 4455 1b66 BD46     		mov	sp, r7
 4456 1b68 80BD     		pop	{r7, pc}
 4457              		.cfi_endproc
 4458              	.LFE160:
 4460 1b6a 00BF     		.align	2
 4461              		.global	AX12_config_set_lowest_voltage
 4462              		.thumb
 4463              		.thumb_func
 4465              	AX12_config_set_lowest_voltage:
 4466              	.LFB161:
1332:../QS/QS_ax12.c **** 
1333:../QS/QS_ax12.c **** bool_e AX12_config_set_lowest_voltage(Uint8 id_servo, Uint8 voltage) {
 4467              		.loc 2 1333 0
 4468              		.cfi_startproc
 4469              		@ args = 0, pretend = 0, frame = 8
 4470              		@ frame_needed = 1, uses_anonymous_args = 0
 4471 1b6c 80B5     		push	{r7, lr}
 4472              	.LCFI152:
 4473              		.cfi_def_cfa_offset 8
 4474              		.cfi_offset 7, -8
 4475              		.cfi_offset 14, -4
 4476 1b6e 82B0     		sub	sp, sp, #8
 4477              	.LCFI153:
 4478              		.cfi_def_cfa_offset 16
 4479 1b70 00AF     		add	r7, sp, #0
 4480              	.LCFI154:
 4481              		.cfi_def_cfa_register 7
 4482 1b72 0246     		mov	r2, r0
 4483 1b74 0B46     		mov	r3, r1
 4484 1b76 FA71     		strb	r2, [r7, #7]
 4485 1b78 BB71     		strb	r3, [r7, #6]
1334:../QS/QS_ax12.c **** 	return AX12_instruction_write8(id_servo, AX12_DOWN_LIMIT_VOLTAGE, voltage);
 4486              		.loc 2 1334 0
 4487 1b7a FA79     		ldrb	r2, [r7, #7]	@ zero_extendqisi2
 4488 1b7c BB79     		ldrb	r3, [r7, #6]	@ zero_extendqisi2
 4489 1b7e 1046     		mov	r0, r2
 4490 1b80 4FF00C01 		mov	r1, #12
 4491 1b84 1A46     		mov	r2, r3
 4492 1b86 FEF76FFC 		bl	AX12_instruction_write8
 4493 1b8a 0346     		mov	r3, r0
1335:../QS/QS_ax12.c **** }
 4494              		.loc 2 1335 0
 4495 1b8c 1846     		mov	r0, r3
 4496 1b8e 07F10807 		add	r7, r7, #8
 4497 1b92 BD46     		mov	sp, r7
 4498 1b94 80BD     		pop	{r7, pc}
 4499              		.cfi_endproc
 4500              	.LFE161:
 4502 1b96 00BF     		.align	2
 4503              		.global	AX12_config_set_highest_voltage
 4504              		.thumb
 4505              		.thumb_func
 4507              	AX12_config_set_highest_voltage:
 4508              	.LFB162:
1336:../QS/QS_ax12.c **** 
1337:../QS/QS_ax12.c **** bool_e AX12_config_set_highest_voltage(Uint8 id_servo, Uint8 voltage) {
 4509              		.loc 2 1337 0
 4510              		.cfi_startproc
 4511              		@ args = 0, pretend = 0, frame = 8
 4512              		@ frame_needed = 1, uses_anonymous_args = 0
 4513 1b98 80B5     		push	{r7, lr}
 4514              	.LCFI155:
 4515              		.cfi_def_cfa_offset 8
 4516              		.cfi_offset 7, -8
 4517              		.cfi_offset 14, -4
 4518 1b9a 82B0     		sub	sp, sp, #8
 4519              	.LCFI156:
 4520              		.cfi_def_cfa_offset 16
 4521 1b9c 00AF     		add	r7, sp, #0
 4522              	.LCFI157:
 4523              		.cfi_def_cfa_register 7
 4524 1b9e 0246     		mov	r2, r0
 4525 1ba0 0B46     		mov	r3, r1
 4526 1ba2 FA71     		strb	r2, [r7, #7]
 4527 1ba4 BB71     		strb	r3, [r7, #6]
1338:../QS/QS_ax12.c **** 	return AX12_instruction_write8(id_servo, AX12_UP_LIMIT_VOLTAGE, voltage);
 4528              		.loc 2 1338 0
 4529 1ba6 FA79     		ldrb	r2, [r7, #7]	@ zero_extendqisi2
 4530 1ba8 BB79     		ldrb	r3, [r7, #6]	@ zero_extendqisi2
 4531 1baa 1046     		mov	r0, r2
 4532 1bac 4FF00D01 		mov	r1, #13
 4533 1bb0 1A46     		mov	r2, r3
 4534 1bb2 FEF759FC 		bl	AX12_instruction_write8
 4535 1bb6 0346     		mov	r3, r0
1339:../QS/QS_ax12.c **** }
 4536              		.loc 2 1339 0
 4537 1bb8 1846     		mov	r0, r3
 4538 1bba 07F10807 		add	r7, r7, #8
 4539 1bbe BD46     		mov	sp, r7
 4540 1bc0 80BD     		pop	{r7, pc}
 4541              		.cfi_endproc
 4542              	.LFE162:
 4544 1bc2 00BF     		.align	2
 4545              		.global	AX12_config_set_maximum_torque_percentage
 4546              		.thumb
 4547              		.thumb_func
 4549              	AX12_config_set_maximum_torque_percentage:
 4550              	.LFB163:
1340:../QS/QS_ax12.c **** 
1341:../QS/QS_ax12.c **** bool_e AX12_config_set_maximum_torque_percentage(Uint8 id_servo, Uint8 percentage) {
 4551              		.loc 2 1341 0
 4552              		.cfi_startproc
 4553              		@ args = 0, pretend = 0, frame = 16
 4554              		@ frame_needed = 1, uses_anonymous_args = 0
 4555 1bc4 80B5     		push	{r7, lr}
 4556              	.LCFI158:
 4557              		.cfi_def_cfa_offset 8
 4558              		.cfi_offset 7, -8
 4559              		.cfi_offset 14, -4
 4560 1bc6 84B0     		sub	sp, sp, #16
 4561              	.LCFI159:
 4562              		.cfi_def_cfa_offset 24
 4563 1bc8 00AF     		add	r7, sp, #0
 4564              	.LCFI160:
 4565              		.cfi_def_cfa_register 7
 4566 1bca 0246     		mov	r2, r0
 4567 1bcc 0B46     		mov	r3, r1
 4568 1bce FA71     		strb	r2, [r7, #7]
 4569 1bd0 BB71     		strb	r3, [r7, #6]
1342:../QS/QS_ax12.c **** 	Uint16 value = AX12_PERCENTAGE_TO_1024(percentage);
 4570              		.loc 2 1342 0
 4571 1bd2 BB79     		ldrb	r3, [r7, #6]	@ zero_extendqisi2
 4572 1bd4 4FEA0322 		lsl	r2, r3, #8
 4573 1bd8 48F21F53 		movw	r3, #34079
 4574 1bdc C5F2EB13 		movt	r3, 20971
 4575 1be0 83FB0213 		smull	r1, r3, r3, r2
 4576 1be4 4FEAE301 		asr	r1, r3, #3
 4577 1be8 4FEAE273 		asr	r3, r2, #31
 4578 1bec CB1A     		subs	r3, r1, r3
 4579 1bee FB81     		strh	r3, [r7, #14]	@ movhi
1343:../QS/QS_ax12.c **** 	return AX12_instruction_write16(id_servo, AX12_MAX_TORQUE_L, value);
 4580              		.loc 2 1343 0
 4581 1bf0 FA79     		ldrb	r2, [r7, #7]	@ zero_extendqisi2
 4582 1bf2 FB89     		ldrh	r3, [r7, #14]
 4583 1bf4 1046     		mov	r0, r2
 4584 1bf6 4FF00E01 		mov	r1, #14
 4585 1bfa 1A46     		mov	r2, r3
 4586 1bfc FEF786FC 		bl	AX12_instruction_write16
 4587 1c00 0346     		mov	r3, r0
1344:../QS/QS_ax12.c **** }
 4588              		.loc 2 1344 0
 4589 1c02 1846     		mov	r0, r3
 4590 1c04 07F11007 		add	r7, r7, #16
 4591 1c08 BD46     		mov	sp, r7
 4592 1c0a 80BD     		pop	{r7, pc}
 4593              		.cfi_endproc
 4594              	.LFE163:
 4596              		.align	2
 4597              		.global	AX12_config_set_status_return_mode
 4598              		.thumb
 4599              		.thumb_func
 4601              	AX12_config_set_status_return_mode:
 4602              	.LFB164:
1345:../QS/QS_ax12.c **** 
1346:../QS/QS_ax12.c **** bool_e AX12_config_set_status_return_mode(Uint8 id_servo, Uint8 mode) {
 4603              		.loc 2 1346 0
 4604              		.cfi_startproc
 4605              		@ args = 0, pretend = 0, frame = 8
 4606              		@ frame_needed = 1, uses_anonymous_args = 0
 4607 1c0c 80B5     		push	{r7, lr}
 4608              	.LCFI161:
 4609              		.cfi_def_cfa_offset 8
 4610              		.cfi_offset 7, -8
 4611              		.cfi_offset 14, -4
 4612 1c0e 82B0     		sub	sp, sp, #8
 4613              	.LCFI162:
 4614              		.cfi_def_cfa_offset 16
 4615 1c10 00AF     		add	r7, sp, #0
 4616              	.LCFI163:
 4617              		.cfi_def_cfa_register 7
 4618 1c12 0246     		mov	r2, r0
 4619 1c14 0B46     		mov	r3, r1
 4620 1c16 FA71     		strb	r2, [r7, #7]
 4621 1c18 BB71     		strb	r3, [r7, #6]
1347:../QS/QS_ax12.c **** 	return AX12_instruction_write8(id_servo, AX12_RETURN_LEVEL, mode);
 4622              		.loc 2 1347 0
 4623 1c1a FA79     		ldrb	r2, [r7, #7]	@ zero_extendqisi2
 4624 1c1c BB79     		ldrb	r3, [r7, #6]	@ zero_extendqisi2
 4625 1c1e 1046     		mov	r0, r2
 4626 1c20 4FF01001 		mov	r1, #16
 4627 1c24 1A46     		mov	r2, r3
 4628 1c26 FEF71FFC 		bl	AX12_instruction_write8
 4629 1c2a 0346     		mov	r3, r0
1348:../QS/QS_ax12.c **** }
 4630              		.loc 2 1348 0
 4631 1c2c 1846     		mov	r0, r3
 4632 1c2e 07F10807 		add	r7, r7, #8
 4633 1c32 BD46     		mov	sp, r7
 4634 1c34 80BD     		pop	{r7, pc}
 4635              		.cfi_endproc
 4636              	.LFE164:
 4638 1c36 00BF     		.align	2
 4639              		.global	AX12_config_set_error_before_led
 4640              		.thumb
 4641              		.thumb_func
 4643              	AX12_config_set_error_before_led:
 4644              	.LFB165:
1349:../QS/QS_ax12.c **** 
1350:../QS/QS_ax12.c **** bool_e AX12_config_set_error_before_led(Uint8 id_servo, Uint8 error_type) {
 4645              		.loc 2 1350 0
 4646              		.cfi_startproc
 4647              		@ args = 0, pretend = 0, frame = 8
 4648              		@ frame_needed = 1, uses_anonymous_args = 0
 4649 1c38 80B5     		push	{r7, lr}
 4650              	.LCFI164:
 4651              		.cfi_def_cfa_offset 8
 4652              		.cfi_offset 7, -8
 4653              		.cfi_offset 14, -4
 4654 1c3a 82B0     		sub	sp, sp, #8
 4655              	.LCFI165:
 4656              		.cfi_def_cfa_offset 16
 4657 1c3c 00AF     		add	r7, sp, #0
 4658              	.LCFI166:
 4659              		.cfi_def_cfa_register 7
 4660 1c3e 0246     		mov	r2, r0
 4661 1c40 0B46     		mov	r3, r1
 4662 1c42 FA71     		strb	r2, [r7, #7]
 4663 1c44 BB71     		strb	r3, [r7, #6]
1351:../QS/QS_ax12.c **** 	return AX12_instruction_write8(id_servo, AX12_ALARM_LED, error_type);
 4664              		.loc 2 1351 0
 4665 1c46 FA79     		ldrb	r2, [r7, #7]	@ zero_extendqisi2
 4666 1c48 BB79     		ldrb	r3, [r7, #6]	@ zero_extendqisi2
 4667 1c4a 1046     		mov	r0, r2
 4668 1c4c 4FF01101 		mov	r1, #17
 4669 1c50 1A46     		mov	r2, r3
 4670 1c52 FEF709FC 		bl	AX12_instruction_write8
 4671 1c56 0346     		mov	r3, r0
1352:../QS/QS_ax12.c **** }
 4672              		.loc 2 1352 0
 4673 1c58 1846     		mov	r0, r3
 4674 1c5a 07F10807 		add	r7, r7, #8
 4675 1c5e BD46     		mov	sp, r7
 4676 1c60 80BD     		pop	{r7, pc}
 4677              		.cfi_endproc
 4678              	.LFE165:
 4680 1c62 00BF     		.align	2
 4681              		.global	AX12_config_set_error_before_shutdown
 4682              		.thumb
 4683              		.thumb_func
 4685              	AX12_config_set_error_before_shutdown:
 4686              	.LFB166:
1353:../QS/QS_ax12.c **** 
1354:../QS/QS_ax12.c **** bool_e AX12_config_set_error_before_shutdown(Uint8 id_servo, Uint8 error_type) {
 4687              		.loc 2 1354 0
 4688              		.cfi_startproc
 4689              		@ args = 0, pretend = 0, frame = 8
 4690              		@ frame_needed = 1, uses_anonymous_args = 0
 4691 1c64 80B5     		push	{r7, lr}
 4692              	.LCFI167:
 4693              		.cfi_def_cfa_offset 8
 4694              		.cfi_offset 7, -8
 4695              		.cfi_offset 14, -4
 4696 1c66 82B0     		sub	sp, sp, #8
 4697              	.LCFI168:
 4698              		.cfi_def_cfa_offset 16
 4699 1c68 00AF     		add	r7, sp, #0
 4700              	.LCFI169:
 4701              		.cfi_def_cfa_register 7
 4702 1c6a 0246     		mov	r2, r0
 4703 1c6c 0B46     		mov	r3, r1
 4704 1c6e FA71     		strb	r2, [r7, #7]
 4705 1c70 BB71     		strb	r3, [r7, #6]
1355:../QS/QS_ax12.c **** 	return AX12_instruction_write8(id_servo, AX12_ALARM_SHUTDOWN, error_type);
 4706              		.loc 2 1355 0
 4707 1c72 FA79     		ldrb	r2, [r7, #7]	@ zero_extendqisi2
 4708 1c74 BB79     		ldrb	r3, [r7, #6]	@ zero_extendqisi2
 4709 1c76 1046     		mov	r0, r2
 4710 1c78 4FF01201 		mov	r1, #18
 4711 1c7c 1A46     		mov	r2, r3
 4712 1c7e FEF7F3FB 		bl	AX12_instruction_write8
 4713 1c82 0346     		mov	r3, r0
1356:../QS/QS_ax12.c **** }
 4714              		.loc 2 1356 0
 4715 1c84 1846     		mov	r0, r3
 4716 1c86 07F10807 		add	r7, r7, #8
 4717 1c8a BD46     		mov	sp, r7
 4718 1c8c 80BD     		pop	{r7, pc}
 4719              		.cfi_endproc
 4720              	.LFE166:
 4722 1c8e 00BF     		.align	2
 4723              		.global	AX12_is_wheel_mode_enabled
 4724              		.thumb
 4725              		.thumb_func
 4727              	AX12_is_wheel_mode_enabled:
 4728              	.LFB167:
1357:../QS/QS_ax12.c **** 
1358:../QS/QS_ax12.c **** 
1359:../QS/QS_ax12.c **** //RAM
1360:../QS/QS_ax12.c **** 
1361:../QS/QS_ax12.c **** bool_e AX12_is_wheel_mode_enabled(Uint8 id_servo) {
 4729              		.loc 2 1361 0
 4730              		.cfi_startproc
 4731              		@ args = 0, pretend = 0, frame = 8
 4732              		@ frame_needed = 1, uses_anonymous_args = 0
 4733              		@ link register save eliminated.
 4734 1c90 80B4     		push	{r7}
 4735              	.LCFI170:
 4736              		.cfi_def_cfa_offset 4
 4737              		.cfi_offset 7, -4
 4738 1c92 83B0     		sub	sp, sp, #12
 4739              	.LCFI171:
 4740              		.cfi_def_cfa_offset 16
 4741 1c94 00AF     		add	r7, sp, #0
 4742              	.LCFI172:
 4743              		.cfi_def_cfa_register 7
 4744 1c96 0346     		mov	r3, r0
 4745 1c98 FB71     		strb	r3, [r7, #7]
1362:../QS/QS_ax12.c **** 	return AX12_on_the_robot[id_servo].is_wheel_enabled;
 4746              		.loc 2 1362 0
 4747 1c9a F979     		ldrb	r1, [r7, #7]	@ zero_extendqisi2
 4748 1c9c 40F20002 		movw	r2, #:lower16:AX12_on_the_robot
 4749 1ca0 C0F20002 		movt	r2, #:upper16:AX12_on_the_robot
 4750 1ca4 0B46     		mov	r3, r1
 4751 1ca6 4FEA8303 		lsl	r3, r3, #2
 4752 1caa 5B18     		adds	r3, r3, r1
 4753 1cac 4FEA4303 		lsl	r3, r3, #1
 4754 1cb0 D318     		adds	r3, r2, r3
 4755 1cb2 03F10803 		add	r3, r3, #8
 4756 1cb6 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
1363:../QS/QS_ax12.c **** }
 4757              		.loc 2 1363 0
 4758 1cb8 1846     		mov	r0, r3
 4759 1cba 07F10C07 		add	r7, r7, #12
 4760 1cbe BD46     		mov	sp, r7
 4761 1cc0 80BC     		pop	{r7}
 4762 1cc2 7047     		bx	lr
 4763              		.cfi_endproc
 4764              	.LFE167:
 4766              		.align	2
 4767              		.global	AX12_is_torque_enabled
 4768              		.thumb
 4769              		.thumb_func
 4771              	AX12_is_torque_enabled:
 4772              	.LFB168:
1364:../QS/QS_ax12.c **** 
1365:../QS/QS_ax12.c **** #if AX12_STATUS_RETURN_MODE != AX12_STATUS_RETURN_NEVER
1366:../QS/QS_ax12.c **** bool_e AX12_is_torque_enabled(Uint8 id_servo) {
 4773              		.loc 2 1366 0
 4774              		.cfi_startproc
 4775              		@ args = 0, pretend = 0, frame = 8
 4776              		@ frame_needed = 1, uses_anonymous_args = 0
 4777 1cc4 80B5     		push	{r7, lr}
 4778              	.LCFI173:
 4779              		.cfi_def_cfa_offset 8
 4780              		.cfi_offset 7, -8
 4781              		.cfi_offset 14, -4
 4782 1cc6 82B0     		sub	sp, sp, #8
 4783              	.LCFI174:
 4784              		.cfi_def_cfa_offset 16
 4785 1cc8 00AF     		add	r7, sp, #0
 4786              	.LCFI175:
 4787              		.cfi_def_cfa_register 7
 4788 1cca 0346     		mov	r3, r0
 4789 1ccc FB71     		strb	r3, [r7, #7]
1367:../QS/QS_ax12.c **** 	return AX12_instruction_read8(id_servo, AX12_TORQUE_ENABLE, NULL) != 0;
 4790              		.loc 2 1367 0
 4791 1cce FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 4792 1cd0 1846     		mov	r0, r3
 4793 1cd2 4FF01801 		mov	r1, #24
 4794 1cd6 4FF00002 		mov	r2, #0
 4795 1cda FEF739FB 		bl	AX12_instruction_read8
 4796 1cde 0346     		mov	r3, r0
 4797 1ce0 002B     		cmp	r3, #0
 4798 1ce2 0CBF     		ite	eq
 4799 1ce4 0023     		moveq	r3, #0
 4800 1ce6 0123     		movne	r3, #1
 4801 1ce8 DBB2     		uxtb	r3, r3
1368:../QS/QS_ax12.c **** }
 4802              		.loc 2 1368 0
 4803 1cea 1846     		mov	r0, r3
 4804 1cec 07F10807 		add	r7, r7, #8
 4805 1cf0 BD46     		mov	sp, r7
 4806 1cf2 80BD     		pop	{r7, pc}
 4807              		.cfi_endproc
 4808              	.LFE168:
 4810              		.align	2
 4811              		.global	AX12_is_led_enabled
 4812              		.thumb
 4813              		.thumb_func
 4815              	AX12_is_led_enabled:
 4816              	.LFB169:
1369:../QS/QS_ax12.c **** 
1370:../QS/QS_ax12.c **** bool_e AX12_is_led_enabled(Uint8 id_servo) {
 4817              		.loc 2 1370 0
 4818              		.cfi_startproc
 4819              		@ args = 0, pretend = 0, frame = 8
 4820              		@ frame_needed = 1, uses_anonymous_args = 0
 4821 1cf4 80B5     		push	{r7, lr}
 4822              	.LCFI176:
 4823              		.cfi_def_cfa_offset 8
 4824              		.cfi_offset 7, -8
 4825              		.cfi_offset 14, -4
 4826 1cf6 82B0     		sub	sp, sp, #8
 4827              	.LCFI177:
 4828              		.cfi_def_cfa_offset 16
 4829 1cf8 00AF     		add	r7, sp, #0
 4830              	.LCFI178:
 4831              		.cfi_def_cfa_register 7
 4832 1cfa 0346     		mov	r3, r0
 4833 1cfc FB71     		strb	r3, [r7, #7]
1371:../QS/QS_ax12.c **** 	return AX12_instruction_read8(id_servo, AX12_LED, NULL) != 0;
 4834              		.loc 2 1371 0
 4835 1cfe FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 4836 1d00 1846     		mov	r0, r3
 4837 1d02 4FF01901 		mov	r1, #25
 4838 1d06 4FF00002 		mov	r2, #0
 4839 1d0a FEF721FB 		bl	AX12_instruction_read8
 4840 1d0e 0346     		mov	r3, r0
 4841 1d10 002B     		cmp	r3, #0
 4842 1d12 0CBF     		ite	eq
 4843 1d14 0023     		moveq	r3, #0
 4844 1d16 0123     		movne	r3, #1
 4845 1d18 DBB2     		uxtb	r3, r3
1372:../QS/QS_ax12.c **** }
 4846              		.loc 2 1372 0
 4847 1d1a 1846     		mov	r0, r3
 4848 1d1c 07F10807 		add	r7, r7, #8
 4849 1d20 BD46     		mov	sp, r7
 4850 1d22 80BD     		pop	{r7, pc}
 4851              		.cfi_endproc
 4852              	.LFE169:
 4854              		.align	2
 4855              		.global	AX12_get_torque_response
 4856              		.thumb
 4857              		.thumb_func
 4859              	AX12_get_torque_response:
 4860              	.LFB170:
1373:../QS/QS_ax12.c **** 
1374:../QS/QS_ax12.c **** bool_e AX12_get_torque_response(Uint8 id_servo, Uint16* A, Uint16* B, Uint16* C, Uint16* D) {
 4861              		.loc 2 1374 0
 4862              		.cfi_startproc
 4863              		@ args = 4, pretend = 0, frame = 24
 4864              		@ frame_needed = 1, uses_anonymous_args = 0
 4865 1d24 80B5     		push	{r7, lr}
 4866              	.LCFI179:
 4867              		.cfi_def_cfa_offset 8
 4868              		.cfi_offset 7, -8
 4869              		.cfi_offset 14, -4
 4870 1d26 86B0     		sub	sp, sp, #24
 4871              	.LCFI180:
 4872              		.cfi_def_cfa_offset 32
 4873 1d28 00AF     		add	r7, sp, #0
 4874              	.LCFI181:
 4875              		.cfi_def_cfa_register 7
 4876 1d2a B960     		str	r1, [r7, #8]
 4877 1d2c 7A60     		str	r2, [r7, #4]
 4878 1d2e 3B60     		str	r3, [r7, #0]
 4879 1d30 0346     		mov	r3, r0
 4880 1d32 FB73     		strb	r3, [r7, #15]
1375:../QS/QS_ax12.c **** 	bool_e isOk;
1376:../QS/QS_ax12.c **** 	Uint8 CcwComplianceSlope;
1377:../QS/QS_ax12.c **** 	Uint8 CcwComplianceMargin;
1378:../QS/QS_ax12.c **** 	Uint8 CwComplianceMargin;
1379:../QS/QS_ax12.c **** 	Uint8 CwComplianceSlope;
1380:../QS/QS_ax12.c **** 
1381:../QS/QS_ax12.c **** 	CcwComplianceSlope = AX12_instruction_read8(id_servo, AX12_CCW_COMPLIANCE_SLOPE, &isOk);
 4881              		.loc 2 1381 0
 4882 1d34 FA7B     		ldrb	r2, [r7, #15]	@ zero_extendqisi2
 4883 1d36 07F11303 		add	r3, r7, #19
 4884 1d3a 1046     		mov	r0, r2
 4885 1d3c 4FF01D01 		mov	r1, #29
 4886 1d40 1A46     		mov	r2, r3
 4887 1d42 FEF705FB 		bl	AX12_instruction_read8
 4888 1d46 0346     		mov	r3, r0
 4889 1d48 FB75     		strb	r3, [r7, #23]
1382:../QS/QS_ax12.c **** 	if(!isOk) return FALSE;
 4890              		.loc 2 1382 0
 4891 1d4a FB7C     		ldrb	r3, [r7, #19]	@ zero_extendqisi2
 4892 1d4c 002B     		cmp	r3, #0
 4893 1d4e 02D1     		bne	.L286
 4894              		.loc 2 1382 0 is_stmt 0 discriminator 1
 4895 1d50 4FF00003 		mov	r3, #0
 4896 1d54 74E0     		b	.L295
 4897              	.L286:
1383:../QS/QS_ax12.c **** 	CcwComplianceMargin = AX12_instruction_read8(id_servo, AX12_CCW_COMPLIANCE_MARGIN, &isOk);
 4898              		.loc 2 1383 0 is_stmt 1
 4899 1d56 FA7B     		ldrb	r2, [r7, #15]	@ zero_extendqisi2
 4900 1d58 07F11303 		add	r3, r7, #19
 4901 1d5c 1046     		mov	r0, r2
 4902 1d5e 4FF01B01 		mov	r1, #27
 4903 1d62 1A46     		mov	r2, r3
 4904 1d64 FEF7F4FA 		bl	AX12_instruction_read8
 4905 1d68 0346     		mov	r3, r0
 4906 1d6a BB75     		strb	r3, [r7, #22]
1384:../QS/QS_ax12.c **** 	if(!isOk) return FALSE;
 4907              		.loc 2 1384 0
 4908 1d6c FB7C     		ldrb	r3, [r7, #19]	@ zero_extendqisi2
 4909 1d6e 002B     		cmp	r3, #0
 4910 1d70 02D1     		bne	.L288
 4911              		.loc 2 1384 0 is_stmt 0 discriminator 1
 4912 1d72 4FF00003 		mov	r3, #0
 4913 1d76 63E0     		b	.L295
 4914              	.L288:
1385:../QS/QS_ax12.c **** 	CwComplianceMargin = AX12_instruction_read8(id_servo, AX12_CW_COMPLIANCE_MARGIN, &isOk);
 4915              		.loc 2 1385 0 is_stmt 1
 4916 1d78 FA7B     		ldrb	r2, [r7, #15]	@ zero_extendqisi2
 4917 1d7a 07F11303 		add	r3, r7, #19
 4918 1d7e 1046     		mov	r0, r2
 4919 1d80 4FF01A01 		mov	r1, #26
 4920 1d84 1A46     		mov	r2, r3
 4921 1d86 FEF7E3FA 		bl	AX12_instruction_read8
 4922 1d8a 0346     		mov	r3, r0
 4923 1d8c 7B75     		strb	r3, [r7, #21]
1386:../QS/QS_ax12.c **** 	if(!isOk) return FALSE;
 4924              		.loc 2 1386 0
 4925 1d8e FB7C     		ldrb	r3, [r7, #19]	@ zero_extendqisi2
 4926 1d90 002B     		cmp	r3, #0
 4927 1d92 02D1     		bne	.L289
 4928              		.loc 2 1386 0 is_stmt 0 discriminator 1
 4929 1d94 4FF00003 		mov	r3, #0
 4930 1d98 52E0     		b	.L295
 4931              	.L289:
1387:../QS/QS_ax12.c **** 	CwComplianceSlope = AX12_instruction_read8(id_servo, AX12_CW_COMPLIANCE_SLOPE, &isOk);
 4932              		.loc 2 1387 0 is_stmt 1
 4933 1d9a FA7B     		ldrb	r2, [r7, #15]	@ zero_extendqisi2
 4934 1d9c 07F11303 		add	r3, r7, #19
 4935 1da0 1046     		mov	r0, r2
 4936 1da2 4FF01C01 		mov	r1, #28
 4937 1da6 1A46     		mov	r2, r3
 4938 1da8 FEF7D2FA 		bl	AX12_instruction_read8
 4939 1dac 0346     		mov	r3, r0
 4940 1dae 3B75     		strb	r3, [r7, #20]
1388:../QS/QS_ax12.c **** 	if(!isOk) return FALSE;
 4941              		.loc 2 1388 0
 4942 1db0 FB7C     		ldrb	r3, [r7, #19]	@ zero_extendqisi2
 4943 1db2 002B     		cmp	r3, #0
 4944 1db4 02D1     		bne	.L290
 4945              		.loc 2 1388 0 is_stmt 0 discriminator 1
 4946 1db6 4FF00003 		mov	r3, #0
 4947 1dba 41E0     		b	.L295
 4948              	.L290:
1389:../QS/QS_ax12.c **** 
1390:../QS/QS_ax12.c **** 	if(A) *A = AX12_ANGLE_TO_DEGRE(CcwComplianceSlope);
 4949              		.loc 2 1390 0 is_stmt 1
 4950 1dbc BB68     		ldr	r3, [r7, #8]
 4951 1dbe 002B     		cmp	r3, #0
 4952 1dc0 0CD0     		beq	.L291
 4953              		.loc 2 1390 0 is_stmt 0 discriminator 1
 4954 1dc2 FA7D     		ldrb	r2, [r7, #23]	@ zero_extendqisi2
 4955 1dc4 1346     		mov	r3, r2
 4956 1dc6 4FEA8303 		lsl	r3, r3, #2
 4957 1dca 9B18     		adds	r3, r3, r2
 4958 1dcc 4FEA0312 		lsl	r2, r3, #4
 4959 1dd0 D31A     		subs	r3, r2, r3
 4960 1dd2 4FEA2323 		asr	r3, r3, #8
 4961 1dd6 9AB2     		uxth	r2, r3
 4962 1dd8 BB68     		ldr	r3, [r7, #8]
 4963 1dda 1A80     		strh	r2, [r3, #0]	@ movhi
 4964              	.L291:
1391:../QS/QS_ax12.c **** 	if(B) *B = AX12_ANGLE_TO_DEGRE(CcwComplianceMargin);
 4965              		.loc 2 1391 0 is_stmt 1
 4966 1ddc 7B68     		ldr	r3, [r7, #4]
 4967 1dde 002B     		cmp	r3, #0
 4968 1de0 0CD0     		beq	.L292
 4969              		.loc 2 1391 0 is_stmt 0 discriminator 1
 4970 1de2 BA7D     		ldrb	r2, [r7, #22]	@ zero_extendqisi2
 4971 1de4 1346     		mov	r3, r2
 4972 1de6 4FEA8303 		lsl	r3, r3, #2
 4973 1dea 9B18     		adds	r3, r3, r2
 4974 1dec 4FEA0312 		lsl	r2, r3, #4
 4975 1df0 D31A     		subs	r3, r2, r3
 4976 1df2 4FEA2323 		asr	r3, r3, #8
 4977 1df6 9AB2     		uxth	r2, r3
 4978 1df8 7B68     		ldr	r3, [r7, #4]
 4979 1dfa 1A80     		strh	r2, [r3, #0]	@ movhi
 4980              	.L292:
1392:../QS/QS_ax12.c **** 	if(C) *C = AX12_ANGLE_TO_DEGRE(CwComplianceMargin);
 4981              		.loc 2 1392 0 is_stmt 1
 4982 1dfc 3B68     		ldr	r3, [r7, #0]
 4983 1dfe 002B     		cmp	r3, #0
 4984 1e00 0CD0     		beq	.L293
 4985              		.loc 2 1392 0 is_stmt 0 discriminator 1
 4986 1e02 7A7D     		ldrb	r2, [r7, #21]	@ zero_extendqisi2
 4987 1e04 1346     		mov	r3, r2
 4988 1e06 4FEA8303 		lsl	r3, r3, #2
 4989 1e0a 9B18     		adds	r3, r3, r2
 4990 1e0c 4FEA0312 		lsl	r2, r3, #4
 4991 1e10 D31A     		subs	r3, r2, r3
 4992 1e12 4FEA2323 		asr	r3, r3, #8
 4993 1e16 9AB2     		uxth	r2, r3
 4994 1e18 3B68     		ldr	r3, [r7, #0]
 4995 1e1a 1A80     		strh	r2, [r3, #0]	@ movhi
 4996              	.L293:
1393:../QS/QS_ax12.c **** 	if(D) *D = AX12_ANGLE_TO_DEGRE(CwComplianceSlope);
 4997              		.loc 2 1393 0 is_stmt 1
 4998 1e1c 3B6A     		ldr	r3, [r7, #32]
 4999 1e1e 002B     		cmp	r3, #0
 5000 1e20 0CD0     		beq	.L294
 5001              		.loc 2 1393 0 is_stmt 0 discriminator 1
 5002 1e22 3A7D     		ldrb	r2, [r7, #20]	@ zero_extendqisi2
 5003 1e24 1346     		mov	r3, r2
 5004 1e26 4FEA8303 		lsl	r3, r3, #2
 5005 1e2a 9B18     		adds	r3, r3, r2
 5006 1e2c 4FEA0312 		lsl	r2, r3, #4
 5007 1e30 D31A     		subs	r3, r2, r3
 5008 1e32 4FEA2323 		asr	r3, r3, #8
 5009 1e36 9AB2     		uxth	r2, r3
 5010 1e38 3B6A     		ldr	r3, [r7, #32]
 5011 1e3a 1A80     		strh	r2, [r3, #0]	@ movhi
 5012              	.L294:
1394:../QS/QS_ax12.c **** 
1395:../QS/QS_ax12.c **** 	return TRUE;
 5013              		.loc 2 1395 0 is_stmt 1
 5014 1e3c 4FF00103 		mov	r3, #1
 5015              	.L295:
1396:../QS/QS_ax12.c **** }
 5016              		.loc 2 1396 0
 5017 1e40 1846     		mov	r0, r3
 5018 1e42 07F11807 		add	r7, r7, #24
 5019 1e46 BD46     		mov	sp, r7
 5020 1e48 80BD     		pop	{r7, pc}
 5021              		.cfi_endproc
 5022              	.LFE170:
 5024 1e4a 00BF     		.align	2
 5025              		.global	AX12_get_position
 5026              		.thumb
 5027              		.thumb_func
 5029              	AX12_get_position:
 5030              	.LFB171:
1397:../QS/QS_ax12.c **** 
1398:../QS/QS_ax12.c **** Uint16 AX12_get_position(Uint8 id_servo) {
 5031              		.loc 2 1398 0
 5032              		.cfi_startproc
 5033              		@ args = 0, pretend = 0, frame = 8
 5034              		@ frame_needed = 1, uses_anonymous_args = 0
 5035 1e4c 80B5     		push	{r7, lr}
 5036              	.LCFI182:
 5037              		.cfi_def_cfa_offset 8
 5038              		.cfi_offset 7, -8
 5039              		.cfi_offset 14, -4
 5040 1e4e 82B0     		sub	sp, sp, #8
 5041              	.LCFI183:
 5042              		.cfi_def_cfa_offset 16
 5043 1e50 00AF     		add	r7, sp, #0
 5044              	.LCFI184:
 5045              		.cfi_def_cfa_register 7
 5046 1e52 0346     		mov	r3, r0
 5047 1e54 FB71     		strb	r3, [r7, #7]
1399:../QS/QS_ax12.c **** 	return AX12_ANGLE_TO_DEGRE(AX12_instruction_read16(id_servo, AX12_PRESENT_POSITION_L, NULL));
 5048              		.loc 2 1399 0
 5049 1e56 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 5050 1e58 1846     		mov	r0, r3
 5051 1e5a 4FF02401 		mov	r1, #36
 5052 1e5e 4FF00002 		mov	r2, #0
 5053 1e62 FEF7BBFA 		bl	AX12_instruction_read16
 5054 1e66 0346     		mov	r3, r0
 5055 1e68 1A46     		mov	r2, r3
 5056 1e6a 1346     		mov	r3, r2
 5057 1e6c 4FEA8303 		lsl	r3, r3, #2
 5058 1e70 9B18     		adds	r3, r3, r2
 5059 1e72 4FEA0312 		lsl	r2, r3, #4
 5060 1e76 D31A     		subs	r3, r2, r3
 5061 1e78 4FEA2323 		asr	r3, r3, #8
 5062 1e7c 9BB2     		uxth	r3, r3
1400:../QS/QS_ax12.c **** }
 5063              		.loc 2 1400 0
 5064 1e7e 1846     		mov	r0, r3
 5065 1e80 07F10807 		add	r7, r7, #8
 5066 1e84 BD46     		mov	sp, r7
 5067 1e86 80BD     		pop	{r7, pc}
 5068              		.cfi_endproc
 5069              	.LFE171:
 5071              		.section	.rodata
 5072 02ae 0000     		.align	2
 5073              	.LC14:
 5074 02b0 41583132 		.ascii	"AX12: AX12_get_move_to_position_speed while in whee"
 5074      3A204158 
 5074      31325F67 
 5074      65745F6D 
 5074      6F76655F 
 5075 02e3 6C206D6F 		.ascii	"l mode, use AX12_get_speed_percentage instead.\012\000"
 5075      64652C20 
 5075      75736520 
 5075      41583132 
 5075      5F676574 
 5076              		.text
 5077              		.align	2
 5078              		.global	AX12_get_move_to_position_speed
 5079              		.thumb
 5080              		.thumb_func
 5082              	AX12_get_move_to_position_speed:
 5083              	.LFB172:
1401:../QS/QS_ax12.c **** 
1402:../QS/QS_ax12.c **** Sint16 AX12_get_move_to_position_speed(Uint8 id_servo) {
 5084              		.loc 2 1402 0
 5085              		.cfi_startproc
 5086              		@ args = 0, pretend = 0, frame = 16
 5087              		@ frame_needed = 1, uses_anonymous_args = 0
 5088 1e88 80B5     		push	{r7, lr}
 5089              	.LCFI185:
 5090              		.cfi_def_cfa_offset 8
 5091              		.cfi_offset 7, -8
 5092              		.cfi_offset 14, -4
 5093 1e8a 84B0     		sub	sp, sp, #16
 5094              	.LCFI186:
 5095              		.cfi_def_cfa_offset 24
 5096 1e8c 00AF     		add	r7, sp, #0
 5097              	.LCFI187:
 5098              		.cfi_def_cfa_register 7
 5099 1e8e 0346     		mov	r3, r0
 5100 1e90 FB71     		strb	r3, [r7, #7]
1403:../QS/QS_ax12.c **** 	bool_e isBackward;
1404:../QS/QS_ax12.c **** 	Uint16 speed;
1405:../QS/QS_ax12.c **** 
1406:../QS/QS_ax12.c **** 	if(AX12_on_the_robot[id_servo].is_wheel_enabled) {
 5101              		.loc 2 1406 0
 5102 1e92 F979     		ldrb	r1, [r7, #7]	@ zero_extendqisi2
 5103 1e94 40F20002 		movw	r2, #:lower16:AX12_on_the_robot
 5104 1e98 C0F20002 		movt	r2, #:upper16:AX12_on_the_robot
 5105 1e9c 0B46     		mov	r3, r1
 5106 1e9e 4FEA8303 		lsl	r3, r3, #2
 5107 1ea2 5B18     		adds	r3, r3, r1
 5108 1ea4 4FEA4303 		lsl	r3, r3, #1
 5109 1ea8 D318     		adds	r3, r2, r3
 5110 1eaa 03F10803 		add	r3, r3, #8
 5111 1eae 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 5112 1eb0 002B     		cmp	r3, #0
 5113 1eb2 0AD0     		beq	.L299
1407:../QS/QS_ax12.c **** 		debug_printf("AX12: AX12_get_move_to_position_speed while in wheel mode, use AX12_get_speed_perce
 5114              		.loc 2 1407 0
 5115 1eb4 4FF00500 		mov	r0, #5
 5116 1eb8 40F20001 		movw	r1, #:lower16:.LC14
 5117 1ebc C0F20001 		movt	r1, #:upper16:.LC14
 5118 1ec0 FFF7FEFF 		bl	OUTPUTLOG_printf
1408:../QS/QS_ax12.c **** 		return 0;
 5119              		.loc 2 1408 0
 5120 1ec4 4FF00003 		mov	r3, #0
 5121 1ec8 2BE0     		b	.L300
 5122              	.L299:
1409:../QS/QS_ax12.c **** 	}
1410:../QS/QS_ax12.c **** 
1411:../QS/QS_ax12.c **** 	speed = AX12_instruction_read16(id_servo, AX12_PRESENT_SPEED_L, NULL);
 5123              		.loc 2 1411 0
 5124 1eca FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 5125 1ecc 1846     		mov	r0, r3
 5126 1ece 4FF02601 		mov	r1, #38
 5127 1ed2 4FF00002 		mov	r2, #0
 5128 1ed6 FEF781FA 		bl	AX12_instruction_read16
 5129 1eda 0346     		mov	r3, r0
 5130 1edc FB81     		strh	r3, [r7, #14]	@ movhi
1412:../QS/QS_ax12.c **** 
1413:../QS/QS_ax12.c **** 	isBackward = (speed & 0x400) != 0;
 5131              		.loc 2 1413 0
 5132 1ede FB89     		ldrh	r3, [r7, #14]
 5133 1ee0 03F48063 		and	r3, r3, #1024
 5134 1ee4 002B     		cmp	r3, #0
 5135 1ee6 0CBF     		ite	eq
 5136 1ee8 0023     		moveq	r3, #0
 5137 1eea 0123     		movne	r3, #1
 5138 1eec DBB2     		uxtb	r3, r3
 5139 1eee 7B73     		strb	r3, [r7, #13]
1414:../QS/QS_ax12.c **** 	speed = AX12_SPEED_TO_DPS(speed & 0x3FF);
 5140              		.loc 2 1414 0
 5141 1ef0 FB89     		ldrh	r3, [r7, #14]
 5142 1ef2 4FEA8352 		lsl	r2, r3, #22
 5143 1ef6 4FEA9252 		lsr	r2, r2, #22
 5144 1efa 1346     		mov	r3, r2
 5145 1efc 4FEA8303 		lsl	r3, r3, #2
 5146 1f00 9B18     		adds	r3, r3, r2
 5147 1f02 4FEA0312 		lsl	r2, r3, #4
 5148 1f06 9B18     		adds	r3, r3, r2
 5149 1f08 4FEAE313 		asr	r3, r3, #7
 5150 1f0c FB81     		strh	r3, [r7, #14]	@ movhi
1415:../QS/QS_ax12.c **** 	if(isBackward)
 5151              		.loc 2 1415 0
 5152 1f0e 7B7B     		ldrb	r3, [r7, #13]	@ zero_extendqisi2
 5153 1f10 002B     		cmp	r3, #0
 5154 1f12 05D0     		beq	.L301
1416:../QS/QS_ax12.c **** 		return -(Sint16)speed;
 5155              		.loc 2 1416 0
 5156 1f14 FB89     		ldrh	r3, [r7, #14]	@ movhi
 5157 1f16 C3F10003 		rsb	r3, r3, #0
 5158 1f1a 9BB2     		uxth	r3, r3
 5159 1f1c 9BB2     		uxth	r3, r3
 5160 1f1e 00E0     		b	.L300
 5161              	.L301:
1417:../QS/QS_ax12.c **** 	return (Sint16)speed;
 5162              		.loc 2 1417 0
 5163 1f20 FB89     		ldrh	r3, [r7, #14]
 5164              	.L300:
 5165 1f22 1BB2     		sxth	r3, r3
1418:../QS/QS_ax12.c **** }
 5166              		.loc 2 1418 0
 5167 1f24 1846     		mov	r0, r3
 5168 1f26 07F11007 		add	r7, r7, #16
 5169 1f2a BD46     		mov	sp, r7
 5170 1f2c 80BD     		pop	{r7, pc}
 5171              		.cfi_endproc
 5172              	.LFE172:
 5174              		.section	.rodata
 5175 0313 00       		.align	2
 5176              	.LC15:
 5177 0314 41583132 		.ascii	"AX12: AX12_get_speed_percentage while not in wheel "
 5177      3A204158 
 5177      31325F67 
 5177      65745F73 
 5177      70656564 
 5178 0347 6D6F6465 		.ascii	"mode, use AX12_get_move_to_position_speed instead.\012"
 5178      2C207573 
 5178      65204158 
 5178      31325F67 
 5178      65745F6D 
 5179 037a 00       		.ascii	"\000"
 5180              		.text
 5181 1f2e 00BF     		.align	2
 5182              		.global	AX12_get_speed_percentage
 5183              		.thumb
 5184              		.thumb_func
 5186              	AX12_get_speed_percentage:
 5187              	.LFB173:
1419:../QS/QS_ax12.c **** 
1420:../QS/QS_ax12.c **** Sint8 AX12_get_speed_percentage(Uint8 id_servo) {
 5188              		.loc 2 1420 0
 5189              		.cfi_startproc
 5190              		@ args = 0, pretend = 0, frame = 16
 5191              		@ frame_needed = 1, uses_anonymous_args = 0
 5192 1f30 80B5     		push	{r7, lr}
 5193              	.LCFI188:
 5194              		.cfi_def_cfa_offset 8
 5195              		.cfi_offset 7, -8
 5196              		.cfi_offset 14, -4
 5197 1f32 84B0     		sub	sp, sp, #16
 5198              	.LCFI189:
 5199              		.cfi_def_cfa_offset 24
 5200 1f34 00AF     		add	r7, sp, #0
 5201              	.LCFI190:
 5202              		.cfi_def_cfa_register 7
 5203 1f36 0346     		mov	r3, r0
 5204 1f38 FB71     		strb	r3, [r7, #7]
1421:../QS/QS_ax12.c **** 	bool_e isBackward;
1422:../QS/QS_ax12.c **** 	Uint16 speedPercentage;
1423:../QS/QS_ax12.c **** 
1424:../QS/QS_ax12.c **** 	if(!AX12_on_the_robot[id_servo].is_wheel_enabled) {
 5205              		.loc 2 1424 0
 5206 1f3a F979     		ldrb	r1, [r7, #7]	@ zero_extendqisi2
 5207 1f3c 40F20002 		movw	r2, #:lower16:AX12_on_the_robot
 5208 1f40 C0F20002 		movt	r2, #:upper16:AX12_on_the_robot
 5209 1f44 0B46     		mov	r3, r1
 5210 1f46 4FEA8303 		lsl	r3, r3, #2
 5211 1f4a 5B18     		adds	r3, r3, r1
 5212 1f4c 4FEA4303 		lsl	r3, r3, #1
 5213 1f50 D318     		adds	r3, r2, r3
 5214 1f52 03F10803 		add	r3, r3, #8
 5215 1f56 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 5216 1f58 002B     		cmp	r3, #0
 5217 1f5a 0AD1     		bne	.L303
1425:../QS/QS_ax12.c **** 		debug_printf("AX12: AX12_get_speed_percentage while not in wheel mode, use AX12_get_move_to_posit
 5218              		.loc 2 1425 0
 5219 1f5c 4FF00500 		mov	r0, #5
 5220 1f60 40F20001 		movw	r1, #:lower16:.LC15
 5221 1f64 C0F20001 		movt	r1, #:upper16:.LC15
 5222 1f68 FFF7FEFF 		bl	OUTPUTLOG_printf
1426:../QS/QS_ax12.c **** 		return 0;
 5223              		.loc 2 1426 0
 5224 1f6c 4FF00003 		mov	r3, #0
 5225 1f70 2DE0     		b	.L304
 5226              	.L303:
1427:../QS/QS_ax12.c **** 	}
1428:../QS/QS_ax12.c **** 
1429:../QS/QS_ax12.c **** 	speedPercentage = AX12_instruction_read16(id_servo, AX12_PRESENT_SPEED_L, NULL);
 5227              		.loc 2 1429 0
 5228 1f72 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 5229 1f74 1846     		mov	r0, r3
 5230 1f76 4FF02601 		mov	r1, #38
 5231 1f7a 4FF00002 		mov	r2, #0
 5232 1f7e FEF72DFA 		bl	AX12_instruction_read16
 5233 1f82 0346     		mov	r3, r0
 5234 1f84 FB81     		strh	r3, [r7, #14]	@ movhi
1430:../QS/QS_ax12.c **** 
1431:../QS/QS_ax12.c **** 	isBackward = (speedPercentage & 0x400) != 0;
 5235              		.loc 2 1431 0
 5236 1f86 FB89     		ldrh	r3, [r7, #14]
 5237 1f88 03F48063 		and	r3, r3, #1024
 5238 1f8c 002B     		cmp	r3, #0
 5239 1f8e 0CBF     		ite	eq
 5240 1f90 0023     		moveq	r3, #0
 5241 1f92 0123     		movne	r3, #1
 5242 1f94 DBB2     		uxtb	r3, r3
 5243 1f96 7B73     		strb	r3, [r7, #13]
1432:../QS/QS_ax12.c **** 	speedPercentage = AX12_1024_TO_PERCENTAGE(speedPercentage & 0x3FF);
 5244              		.loc 2 1432 0
 5245 1f98 FB89     		ldrh	r3, [r7, #14]
 5246 1f9a 4FEA8352 		lsl	r2, r3, #22
 5247 1f9e 4FEA9252 		lsr	r2, r2, #22
 5248 1fa2 1346     		mov	r3, r2
 5249 1fa4 4FEA8303 		lsl	r3, r3, #2
 5250 1fa8 9B18     		adds	r3, r3, r2
 5251 1faa 4FEA8302 		lsl	r2, r3, #2
 5252 1fae 9B18     		adds	r3, r3, r2
 5253 1fb0 4FEA2323 		asr	r3, r3, #8
 5254 1fb4 FB81     		strh	r3, [r7, #14]	@ movhi
1433:../QS/QS_ax12.c **** 	if(isBackward)
 5255              		.loc 2 1433 0
 5256 1fb6 7B7B     		ldrb	r3, [r7, #13]	@ zero_extendqisi2
 5257 1fb8 002B     		cmp	r3, #0
 5258 1fba 06D0     		beq	.L305
1434:../QS/QS_ax12.c **** 		return -(Sint8)speedPercentage;
 5259              		.loc 2 1434 0
 5260 1fbc FB89     		ldrh	r3, [r7, #14]	@ movhi
 5261 1fbe DBB2     		uxtb	r3, r3
 5262 1fc0 C3F10003 		rsb	r3, r3, #0
 5263 1fc4 DBB2     		uxtb	r3, r3
 5264 1fc6 DBB2     		uxtb	r3, r3
 5265 1fc8 01E0     		b	.L304
 5266              	.L305:
1435:../QS/QS_ax12.c **** 	return (Sint8)speedPercentage;
 5267              		.loc 2 1435 0
 5268 1fca FB89     		ldrh	r3, [r7, #14]	@ movhi
 5269 1fcc DBB2     		uxtb	r3, r3
 5270              	.L304:
 5271 1fce 5BB2     		sxtb	r3, r3
1436:../QS/QS_ax12.c **** }
 5272              		.loc 2 1436 0
 5273 1fd0 1846     		mov	r0, r3
 5274 1fd2 07F11007 		add	r7, r7, #16
 5275 1fd6 BD46     		mov	sp, r7
 5276 1fd8 80BD     		pop	{r7, pc}
 5277              		.cfi_endproc
 5278              	.LFE173:
 5280 1fda 00BF     		.align	2
 5281              		.global	AX12_get_torque_limit
 5282              		.thumb
 5283              		.thumb_func
 5285              	AX12_get_torque_limit:
 5286              	.LFB174:
1437:../QS/QS_ax12.c **** 
1438:../QS/QS_ax12.c **** Uint8 AX12_get_torque_limit(Uint8 id_servo) {
 5287              		.loc 2 1438 0
 5288              		.cfi_startproc
 5289              		@ args = 0, pretend = 0, frame = 8
 5290              		@ frame_needed = 1, uses_anonymous_args = 0
 5291 1fdc 80B5     		push	{r7, lr}
 5292              	.LCFI191:
 5293              		.cfi_def_cfa_offset 8
 5294              		.cfi_offset 7, -8
 5295              		.cfi_offset 14, -4
 5296 1fde 82B0     		sub	sp, sp, #8
 5297              	.LCFI192:
 5298              		.cfi_def_cfa_offset 16
 5299 1fe0 00AF     		add	r7, sp, #0
 5300              	.LCFI193:
 5301              		.cfi_def_cfa_register 7
 5302 1fe2 0346     		mov	r3, r0
 5303 1fe4 FB71     		strb	r3, [r7, #7]
1439:../QS/QS_ax12.c **** 	return (Uint8)AX12_1024_TO_PERCENTAGE(AX12_instruction_read16(id_servo, AX12_TORQUE_LIMIT_L, NULL)
 5304              		.loc 2 1439 0
 5305 1fe6 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 5306 1fe8 1846     		mov	r0, r3
 5307 1fea 4FF02201 		mov	r1, #34
 5308 1fee 4FF00002 		mov	r2, #0
 5309 1ff2 FEF7F3F9 		bl	AX12_instruction_read16
 5310 1ff6 0346     		mov	r3, r0
 5311 1ff8 1A46     		mov	r2, r3
 5312 1ffa 1346     		mov	r3, r2
 5313 1ffc 4FEA8303 		lsl	r3, r3, #2
 5314 2000 9B18     		adds	r3, r3, r2
 5315 2002 4FEA8302 		lsl	r2, r3, #2
 5316 2006 9B18     		adds	r3, r3, r2
 5317 2008 4FEA2323 		asr	r3, r3, #8
 5318 200c DBB2     		uxtb	r3, r3
1440:../QS/QS_ax12.c **** }
 5319              		.loc 2 1440 0
 5320 200e 1846     		mov	r0, r3
 5321 2010 07F10807 		add	r7, r7, #8
 5322 2014 BD46     		mov	sp, r7
 5323 2016 80BD     		pop	{r7, pc}
 5324              		.cfi_endproc
 5325              	.LFE174:
 5327              		.align	2
 5328              		.global	AX12_get_punch_torque_percentage
 5329              		.thumb
 5330              		.thumb_func
 5332              	AX12_get_punch_torque_percentage:
 5333              	.LFB175:
1441:../QS/QS_ax12.c **** 
1442:../QS/QS_ax12.c **** Uint8 AX12_get_punch_torque_percentage(Uint8 id_servo) {
 5334              		.loc 2 1442 0
 5335              		.cfi_startproc
 5336              		@ args = 0, pretend = 0, frame = 8
 5337              		@ frame_needed = 1, uses_anonymous_args = 0
 5338 2018 80B5     		push	{r7, lr}
 5339              	.LCFI194:
 5340              		.cfi_def_cfa_offset 8
 5341              		.cfi_offset 7, -8
 5342              		.cfi_offset 14, -4
 5343 201a 82B0     		sub	sp, sp, #8
 5344              	.LCFI195:
 5345              		.cfi_def_cfa_offset 16
 5346 201c 00AF     		add	r7, sp, #0
 5347              	.LCFI196:
 5348              		.cfi_def_cfa_register 7
 5349 201e 0346     		mov	r3, r0
 5350 2020 FB71     		strb	r3, [r7, #7]
1443:../QS/QS_ax12.c **** 	return (Uint8)AX12_1024_TO_PERCENTAGE(AX12_instruction_read16(id_servo, AX12_PUNCH_L, NULL));
 5351              		.loc 2 1443 0
 5352 2022 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 5353 2024 1846     		mov	r0, r3
 5354 2026 4FF03001 		mov	r1, #48
 5355 202a 4FF00002 		mov	r2, #0
 5356 202e FEF7D5F9 		bl	AX12_instruction_read16
 5357 2032 0346     		mov	r3, r0
 5358 2034 1A46     		mov	r2, r3
 5359 2036 1346     		mov	r3, r2
 5360 2038 4FEA8303 		lsl	r3, r3, #2
 5361 203c 9B18     		adds	r3, r3, r2
 5362 203e 4FEA8302 		lsl	r2, r3, #2
 5363 2042 9B18     		adds	r3, r3, r2
 5364 2044 4FEA2323 		asr	r3, r3, #8
 5365 2048 DBB2     		uxtb	r3, r3
1444:../QS/QS_ax12.c **** }
 5366              		.loc 2 1444 0
 5367 204a 1846     		mov	r0, r3
 5368 204c 07F10807 		add	r7, r7, #8
 5369 2050 BD46     		mov	sp, r7
 5370 2052 80BD     		pop	{r7, pc}
 5371              		.cfi_endproc
 5372              	.LFE175:
 5374              		.align	2
 5375              		.global	AX12_get_load_percentage
 5376              		.thumb
 5377              		.thumb_func
 5379              	AX12_get_load_percentage:
 5380              	.LFB176:
1445:../QS/QS_ax12.c **** 
1446:../QS/QS_ax12.c **** Sint8 AX12_get_load_percentage(Uint8 id_servo) {
 5381              		.loc 2 1446 0
 5382              		.cfi_startproc
 5383              		@ args = 0, pretend = 0, frame = 16
 5384              		@ frame_needed = 1, uses_anonymous_args = 0
 5385 2054 80B5     		push	{r7, lr}
 5386              	.LCFI197:
 5387              		.cfi_def_cfa_offset 8
 5388              		.cfi_offset 7, -8
 5389              		.cfi_offset 14, -4
 5390 2056 84B0     		sub	sp, sp, #16
 5391              	.LCFI198:
 5392              		.cfi_def_cfa_offset 24
 5393 2058 00AF     		add	r7, sp, #0
 5394              	.LCFI199:
 5395              		.cfi_def_cfa_register 7
 5396 205a 0346     		mov	r3, r0
 5397 205c FB71     		strb	r3, [r7, #7]
1447:../QS/QS_ax12.c **** 	bool_e isBackward;
1448:../QS/QS_ax12.c **** 	Uint16 loadPercentage;
1449:../QS/QS_ax12.c **** 
1450:../QS/QS_ax12.c **** 	loadPercentage = AX12_instruction_read16(id_servo, AX12_PRESENT_LOAD_L, NULL);
 5398              		.loc 2 1450 0
 5399 205e FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 5400 2060 1846     		mov	r0, r3
 5401 2062 4FF02801 		mov	r1, #40
 5402 2066 4FF00002 		mov	r2, #0
 5403 206a FEF7B7F9 		bl	AX12_instruction_read16
 5404 206e 0346     		mov	r3, r0
 5405 2070 FB81     		strh	r3, [r7, #14]	@ movhi
1451:../QS/QS_ax12.c **** 
1452:../QS/QS_ax12.c **** 	isBackward = (loadPercentage & 0x400) != 0;
 5406              		.loc 2 1452 0
 5407 2072 FB89     		ldrh	r3, [r7, #14]
 5408 2074 03F48063 		and	r3, r3, #1024
 5409 2078 002B     		cmp	r3, #0
 5410 207a 0CBF     		ite	eq
 5411 207c 0023     		moveq	r3, #0
 5412 207e 0123     		movne	r3, #1
 5413 2080 DBB2     		uxtb	r3, r3
 5414 2082 7B73     		strb	r3, [r7, #13]
1453:../QS/QS_ax12.c **** 	loadPercentage = AX12_1024_TO_PERCENTAGE(loadPercentage & 0x3FF);
 5415              		.loc 2 1453 0
 5416 2084 FB89     		ldrh	r3, [r7, #14]
 5417 2086 4FEA8352 		lsl	r2, r3, #22
 5418 208a 4FEA9252 		lsr	r2, r2, #22
 5419 208e 1346     		mov	r3, r2
 5420 2090 4FEA8303 		lsl	r3, r3, #2
 5421 2094 9B18     		adds	r3, r3, r2
 5422 2096 4FEA8302 		lsl	r2, r3, #2
 5423 209a 9B18     		adds	r3, r3, r2
 5424 209c 4FEA2323 		asr	r3, r3, #8
 5425 20a0 FB81     		strh	r3, [r7, #14]	@ movhi
1454:../QS/QS_ax12.c **** 	if(isBackward)
 5426              		.loc 2 1454 0
 5427 20a2 7B7B     		ldrb	r3, [r7, #13]	@ zero_extendqisi2
 5428 20a4 002B     		cmp	r3, #0
 5429 20a6 06D0     		beq	.L311
1455:../QS/QS_ax12.c **** 		return -(Sint8)loadPercentage;
 5430              		.loc 2 1455 0
 5431 20a8 FB89     		ldrh	r3, [r7, #14]	@ movhi
 5432 20aa DBB2     		uxtb	r3, r3
 5433 20ac C3F10003 		rsb	r3, r3, #0
 5434 20b0 DBB2     		uxtb	r3, r3
 5435 20b2 DBB2     		uxtb	r3, r3
 5436 20b4 01E0     		b	.L312
 5437              	.L311:
1456:../QS/QS_ax12.c **** 	return (Sint8)loadPercentage;
 5438              		.loc 2 1456 0
 5439 20b6 FB89     		ldrh	r3, [r7, #14]	@ movhi
 5440 20b8 DBB2     		uxtb	r3, r3
 5441              	.L312:
 5442 20ba 5BB2     		sxtb	r3, r3
1457:../QS/QS_ax12.c **** }
 5443              		.loc 2 1457 0
 5444 20bc 1846     		mov	r0, r3
 5445 20be 07F11007 		add	r7, r7, #16
 5446 20c2 BD46     		mov	sp, r7
 5447 20c4 80BD     		pop	{r7, pc}
 5448              		.cfi_endproc
 5449              	.LFE176:
 5451 20c6 00BF     		.align	2
 5452              		.global	AX12_get_voltage
 5453              		.thumb
 5454              		.thumb_func
 5456              	AX12_get_voltage:
 5457              	.LFB177:
1458:../QS/QS_ax12.c **** 
1459:../QS/QS_ax12.c **** Uint8 AX12_get_voltage(Uint8 id_servo) {
 5458              		.loc 2 1459 0
 5459              		.cfi_startproc
 5460              		@ args = 0, pretend = 0, frame = 8
 5461              		@ frame_needed = 1, uses_anonymous_args = 0
 5462 20c8 80B5     		push	{r7, lr}
 5463              	.LCFI200:
 5464              		.cfi_def_cfa_offset 8
 5465              		.cfi_offset 7, -8
 5466              		.cfi_offset 14, -4
 5467 20ca 82B0     		sub	sp, sp, #8
 5468              	.LCFI201:
 5469              		.cfi_def_cfa_offset 16
 5470 20cc 00AF     		add	r7, sp, #0
 5471              	.LCFI202:
 5472              		.cfi_def_cfa_register 7
 5473 20ce 0346     		mov	r3, r0
 5474 20d0 FB71     		strb	r3, [r7, #7]
1460:../QS/QS_ax12.c **** 	return AX12_instruction_read8(id_servo, AX12_PRESENT_VOLTAGE, NULL);
 5475              		.loc 2 1460 0
 5476 20d2 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 5477 20d4 1846     		mov	r0, r3
 5478 20d6 4FF02A01 		mov	r1, #42
 5479 20da 4FF00002 		mov	r2, #0
 5480 20de FEF737F9 		bl	AX12_instruction_read8
 5481 20e2 0346     		mov	r3, r0
1461:../QS/QS_ax12.c **** }
 5482              		.loc 2 1461 0
 5483 20e4 1846     		mov	r0, r3
 5484 20e6 07F10807 		add	r7, r7, #8
 5485 20ea BD46     		mov	sp, r7
 5486 20ec 80BD     		pop	{r7, pc}
 5487              		.cfi_endproc
 5488              	.LFE177:
 5490 20ee 00BF     		.align	2
 5491              		.global	AX12_get_temperature
 5492              		.thumb
 5493              		.thumb_func
 5495              	AX12_get_temperature:
 5496              	.LFB178:
1462:../QS/QS_ax12.c **** 
1463:../QS/QS_ax12.c **** Uint8 AX12_get_temperature(Uint8 id_servo) {
 5497              		.loc 2 1463 0
 5498              		.cfi_startproc
 5499              		@ args = 0, pretend = 0, frame = 8
 5500              		@ frame_needed = 1, uses_anonymous_args = 0
 5501 20f0 80B5     		push	{r7, lr}
 5502              	.LCFI203:
 5503              		.cfi_def_cfa_offset 8
 5504              		.cfi_offset 7, -8
 5505              		.cfi_offset 14, -4
 5506 20f2 82B0     		sub	sp, sp, #8
 5507              	.LCFI204:
 5508              		.cfi_def_cfa_offset 16
 5509 20f4 00AF     		add	r7, sp, #0
 5510              	.LCFI205:
 5511              		.cfi_def_cfa_register 7
 5512 20f6 0346     		mov	r3, r0
 5513 20f8 FB71     		strb	r3, [r7, #7]
1464:../QS/QS_ax12.c **** 	return AX12_instruction_read8(id_servo, AX12_PRESENT_TEMPERATURE, NULL);
 5514              		.loc 2 1464 0
 5515 20fa FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 5516 20fc 1846     		mov	r0, r3
 5517 20fe 4FF02B01 		mov	r1, #43
 5518 2102 4FF00002 		mov	r2, #0
 5519 2106 FEF723F9 		bl	AX12_instruction_read8
 5520 210a 0346     		mov	r3, r0
1465:../QS/QS_ax12.c **** }
 5521              		.loc 2 1465 0
 5522 210c 1846     		mov	r0, r3
 5523 210e 07F10807 		add	r7, r7, #8
 5524 2112 BD46     		mov	sp, r7
 5525 2114 80BD     		pop	{r7, pc}
 5526              		.cfi_endproc
 5527              	.LFE178:
 5529 2116 00BF     		.align	2
 5530              		.global	AX12_is_instruction_prepared
 5531              		.thumb
 5532              		.thumb_func
 5534              	AX12_is_instruction_prepared:
 5535              	.LFB179:
1466:../QS/QS_ax12.c **** 
1467:../QS/QS_ax12.c **** bool_e AX12_is_instruction_prepared(Uint8 id_servo) {
 5536              		.loc 2 1467 0
 5537              		.cfi_startproc
 5538              		@ args = 0, pretend = 0, frame = 8
 5539              		@ frame_needed = 1, uses_anonymous_args = 0
 5540 2118 80B5     		push	{r7, lr}
 5541              	.LCFI206:
 5542              		.cfi_def_cfa_offset 8
 5543              		.cfi_offset 7, -8
 5544              		.cfi_offset 14, -4
 5545 211a 82B0     		sub	sp, sp, #8
 5546              	.LCFI207:
 5547              		.cfi_def_cfa_offset 16
 5548 211c 00AF     		add	r7, sp, #0
 5549              	.LCFI208:
 5550              		.cfi_def_cfa_register 7
 5551 211e 0346     		mov	r3, r0
 5552 2120 FB71     		strb	r3, [r7, #7]
1468:../QS/QS_ax12.c **** 	return AX12_instruction_read8(id_servo, AX12_REGISTERED_INSTRUCTION, NULL) != 0;
 5553              		.loc 2 1468 0
 5554 2122 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 5555 2124 1846     		mov	r0, r3
 5556 2126 4FF02C01 		mov	r1, #44
 5557 212a 4FF00002 		mov	r2, #0
 5558 212e FEF70FF9 		bl	AX12_instruction_read8
 5559 2132 0346     		mov	r3, r0
 5560 2134 002B     		cmp	r3, #0
 5561 2136 0CBF     		ite	eq
 5562 2138 0023     		moveq	r3, #0
 5563 213a 0123     		movne	r3, #1
 5564 213c DBB2     		uxtb	r3, r3
1469:../QS/QS_ax12.c **** }
 5565              		.loc 2 1469 0
 5566 213e 1846     		mov	r0, r3
 5567 2140 07F10807 		add	r7, r7, #8
 5568 2144 BD46     		mov	sp, r7
 5569 2146 80BD     		pop	{r7, pc}
 5570              		.cfi_endproc
 5571              	.LFE179:
 5573              		.align	2
 5574              		.global	AX12_is_moving
 5575              		.thumb
 5576              		.thumb_func
 5578              	AX12_is_moving:
 5579              	.LFB180:
1470:../QS/QS_ax12.c **** 
1471:../QS/QS_ax12.c **** bool_e AX12_is_moving(Uint8 id_servo) {
 5580              		.loc 2 1471 0
 5581              		.cfi_startproc
 5582              		@ args = 0, pretend = 0, frame = 8
 5583              		@ frame_needed = 1, uses_anonymous_args = 0
 5584 2148 80B5     		push	{r7, lr}
 5585              	.LCFI209:
 5586              		.cfi_def_cfa_offset 8
 5587              		.cfi_offset 7, -8
 5588              		.cfi_offset 14, -4
 5589 214a 82B0     		sub	sp, sp, #8
 5590              	.LCFI210:
 5591              		.cfi_def_cfa_offset 16
 5592 214c 00AF     		add	r7, sp, #0
 5593              	.LCFI211:
 5594              		.cfi_def_cfa_register 7
 5595 214e 0346     		mov	r3, r0
 5596 2150 FB71     		strb	r3, [r7, #7]
1472:../QS/QS_ax12.c **** 	return AX12_instruction_read8(id_servo, AX12_MOVING, NULL) != 0;
 5597              		.loc 2 1472 0
 5598 2152 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 5599 2154 1846     		mov	r0, r3
 5600 2156 4FF02E01 		mov	r1, #46
 5601 215a 4FF00002 		mov	r2, #0
 5602 215e FEF7F7F8 		bl	AX12_instruction_read8
 5603 2162 0346     		mov	r3, r0
 5604 2164 002B     		cmp	r3, #0
 5605 2166 0CBF     		ite	eq
 5606 2168 0023     		moveq	r3, #0
 5607 216a 0123     		movne	r3, #1
 5608 216c DBB2     		uxtb	r3, r3
1473:../QS/QS_ax12.c **** }
 5609              		.loc 2 1473 0
 5610 216e 1846     		mov	r0, r3
 5611 2170 07F10807 		add	r7, r7, #8
 5612 2174 BD46     		mov	sp, r7
 5613 2176 80BD     		pop	{r7, pc}
 5614              		.cfi_endproc
 5615              	.LFE180:
 5617              		.align	2
 5618              		.global	AX12_set_wheel_mode_enabled
 5619              		.thumb
 5620              		.thumb_func
 5622              	AX12_set_wheel_mode_enabled:
 5623              	.LFB181:
1474:../QS/QS_ax12.c **** 
1475:../QS/QS_ax12.c **** 
1476:../QS/QS_ax12.c **** bool_e AX12_set_wheel_mode_enabled(Uint8 id_servo, bool_e enabled) {
 5624              		.loc 2 1476 0
 5625              		.cfi_startproc
 5626              		@ args = 0, pretend = 0, frame = 32
 5627              		@ frame_needed = 1, uses_anonymous_args = 0
 5628 2178 80B5     		push	{r7, lr}
 5629              	.LCFI212:
 5630              		.cfi_def_cfa_offset 8
 5631              		.cfi_offset 7, -8
 5632              		.cfi_offset 14, -4
 5633 217a 88B0     		sub	sp, sp, #32
 5634              	.LCFI213:
 5635              		.cfi_def_cfa_offset 40
 5636 217c 00AF     		add	r7, sp, #0
 5637              	.LCFI214:
 5638              		.cfi_def_cfa_register 7
 5639 217e 0246     		mov	r2, r0
 5640 2180 0B46     		mov	r3, r1
 5641 2182 FA73     		strb	r2, [r7, #15]
 5642 2184 BB73     		strb	r3, [r7, #14]
1477:../QS/QS_ax12.c **** 	if(enabled == AX12_on_the_robot[id_servo].is_wheel_enabled)	//mode dja dfini
 5643              		.loc 2 1477 0
 5644 2186 F97B     		ldrb	r1, [r7, #15]	@ zero_extendqisi2
 5645 2188 40F20002 		movw	r2, #:lower16:AX12_on_the_robot
 5646 218c C0F20002 		movt	r2, #:upper16:AX12_on_the_robot
 5647 2190 0B46     		mov	r3, r1
 5648 2192 4FEA8303 		lsl	r3, r3, #2
 5649 2196 5B18     		adds	r3, r3, r1
 5650 2198 4FEA4303 		lsl	r3, r3, #1
 5651 219c D318     		adds	r3, r2, r3
 5652 219e 03F10803 		add	r3, r3, #8
 5653 21a2 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 5654 21a4 BA7B     		ldrb	r2, [r7, #14]	@ zero_extendqisi2
 5655 21a6 9A42     		cmp	r2, r3
 5656 21a8 02D1     		bne	.L322
1478:../QS/QS_ax12.c **** 		return TRUE;
 5657              		.loc 2 1478 0
 5658 21aa 4FF00103 		mov	r3, #1
 5659 21ae C3E0     		b	.L323
 5660              	.L322:
1479:../QS/QS_ax12.c **** 
1480:../QS/QS_ax12.c **** 	if(enabled) {	//sauvegarde les angles limite dfini et passe en mode wheel
 5661              		.loc 2 1480 0
 5662 21b0 BB7B     		ldrb	r3, [r7, #14]	@ zero_extendqisi2
 5663 21b2 002B     		cmp	r3, #0
 5664 21b4 7BD0     		beq	.L324
 5665              	.LBB5:
1481:../QS/QS_ax12.c **** 		Uint16 min_angle, max_angle;
1482:../QS/QS_ax12.c **** 
1483:../QS/QS_ax12.c **** 		AX12_on_the_robot[id_servo].is_wheel_enabled = TRUE;
 5666              		.loc 2 1483 0
 5667 21b6 F97B     		ldrb	r1, [r7, #15]	@ zero_extendqisi2
 5668 21b8 40F20002 		movw	r2, #:lower16:AX12_on_the_robot
 5669 21bc C0F20002 		movt	r2, #:upper16:AX12_on_the_robot
 5670 21c0 0B46     		mov	r3, r1
 5671 21c2 4FEA8303 		lsl	r3, r3, #2
 5672 21c6 5B18     		adds	r3, r3, r1
 5673 21c8 4FEA4303 		lsl	r3, r3, #1
 5674 21cc D318     		adds	r3, r2, r3
 5675 21ce 03F10803 		add	r3, r3, #8
 5676 21d2 4FF00102 		mov	r2, #1
 5677 21d6 1A70     		strb	r2, [r3, #0]
1484:../QS/QS_ax12.c **** 
1485:../QS/QS_ax12.c **** 		min_angle = AX12_config_get_minimal_angle(id_servo);
 5678              		.loc 2 1485 0
 5679 21d8 FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 5680 21da 1846     		mov	r0, r3
 5681 21dc FFF7FEFF 		bl	AX12_config_get_minimal_angle
 5682 21e0 0346     		mov	r3, r0
 5683 21e2 BB83     		strh	r3, [r7, #28]	@ movhi
1486:../QS/QS_ax12.c **** 		if(AX12_get_last_error(id_servo).error)
 5684              		.loc 2 1486 0
 5685 21e4 FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 5686 21e6 1846     		mov	r0, r3
 5687 21e8 FFF7FEFF 		bl	AX12_get_last_error
 5688 21ec 3880     		strh	r0, [r7, #0]	@ movhi
 5689 21ee C0F30F43 		ubfx	r3, r0, #16, #16
 5690 21f2 7B80     		strh	r3, [r7, #2]	@ movhi
 5691 21f4 3B68     		ldr	r3, [r7, #0]
 5692 21f6 7B61     		str	r3, [r7, #20]
 5693 21f8 3B7D     		ldrb	r3, [r7, #20]	@ zero_extendqisi2
 5694 21fa 002B     		cmp	r3, #0
 5695 21fc 02D0     		beq	.L325
1487:../QS/QS_ax12.c **** 			return FALSE;
 5696              		.loc 2 1487 0
 5697 21fe 4FF00003 		mov	r3, #0
 5698 2202 99E0     		b	.L323
 5699              	.L325:
1488:../QS/QS_ax12.c **** 
1489:../QS/QS_ax12.c **** 		max_angle = AX12_config_get_maximal_angle(id_servo);
 5700              		.loc 2 1489 0
 5701 2204 FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 5702 2206 1846     		mov	r0, r3
 5703 2208 FFF7FEFF 		bl	AX12_config_get_maximal_angle
 5704 220c 0346     		mov	r3, r0
 5705 220e FB83     		strh	r3, [r7, #30]	@ movhi
1490:../QS/QS_ax12.c **** 		if(AX12_get_last_error(id_servo).error)
 5706              		.loc 2 1490 0
 5707 2210 FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 5708 2212 1846     		mov	r0, r3
 5709 2214 FFF7FEFF 		bl	AX12_get_last_error
 5710 2218 3880     		strh	r0, [r7, #0]	@ movhi
 5711 221a C0F30F43 		ubfx	r3, r0, #16, #16
 5712 221e 7B80     		strh	r3, [r7, #2]	@ movhi
 5713 2220 3B68     		ldr	r3, [r7, #0]
 5714 2222 BB61     		str	r3, [r7, #24]
 5715 2224 3B7E     		ldrb	r3, [r7, #24]	@ zero_extendqisi2
 5716 2226 002B     		cmp	r3, #0
 5717 2228 02D0     		beq	.L326
1491:../QS/QS_ax12.c **** 			return FALSE;
 5718              		.loc 2 1491 0
 5719 222a 4FF00003 		mov	r3, #0
 5720 222e 83E0     		b	.L323
 5721              	.L326:
1492:../QS/QS_ax12.c **** 		if(max_angle == 0) max_angle = 1;	//vite les bugs si les 2 angles limites sont  0 (et donc qu'o
 5722              		.loc 2 1492 0
 5723 2230 FB8B     		ldrh	r3, [r7, #30]
 5724 2232 002B     		cmp	r3, #0
 5725 2234 02D1     		bne	.L327
 5726              		.loc 2 1492 0 is_stmt 0 discriminator 1
 5727 2236 4FF00103 		mov	r3, #1
 5728 223a FB83     		strh	r3, [r7, #30]	@ movhi
 5729              	.L327:
1493:../QS/QS_ax12.c **** 
1494:../QS/QS_ax12.c **** 		if(!AX12_config_set_minimal_angle(id_servo, 0))
 5730              		.loc 2 1494 0 is_stmt 1
 5731 223c FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 5732 223e 1846     		mov	r0, r3
 5733 2240 4FF00001 		mov	r1, #0
 5734 2244 FFF7FEFF 		bl	AX12_config_set_minimal_angle
 5735 2248 0346     		mov	r3, r0
 5736 224a 002B     		cmp	r3, #0
 5737 224c 02D1     		bne	.L328
1495:../QS/QS_ax12.c **** 			return FALSE;
 5738              		.loc 2 1495 0
 5739 224e 4FF00003 		mov	r3, #0
 5740 2252 71E0     		b	.L323
 5741              	.L328:
1496:../QS/QS_ax12.c **** 		if(!AX12_config_set_maximal_angle(id_servo, 0))
 5742              		.loc 2 1496 0
 5743 2254 FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 5744 2256 1846     		mov	r0, r3
 5745 2258 4FF00001 		mov	r1, #0
 5746 225c FFF7FEFF 		bl	AX12_config_set_maximal_angle
 5747 2260 0346     		mov	r3, r0
 5748 2262 002B     		cmp	r3, #0
 5749 2264 02D1     		bne	.L329
1497:../QS/QS_ax12.c **** 			return FALSE;
 5750              		.loc 2 1497 0
 5751 2266 4FF00003 		mov	r3, #0
 5752 226a 65E0     		b	.L323
 5753              	.L329:
1498:../QS/QS_ax12.c **** 
1499:../QS/QS_ax12.c **** 		AX12_on_the_robot[id_servo].angle_limit[0] = min_angle;
 5754              		.loc 2 1499 0
 5755 226c F97B     		ldrb	r1, [r7, #15]	@ zero_extendqisi2
 5756 226e 40F20002 		movw	r2, #:lower16:AX12_on_the_robot
 5757 2272 C0F20002 		movt	r2, #:upper16:AX12_on_the_robot
 5758 2276 0B46     		mov	r3, r1
 5759 2278 4FEA8303 		lsl	r3, r3, #2
 5760 227c 5B18     		adds	r3, r3, r1
 5761 227e 4FEA4303 		lsl	r3, r3, #1
 5762 2282 D318     		adds	r3, r2, r3
 5763 2284 BA8B     		ldrh	r2, [r7, #28]	@ movhi
 5764 2286 9A80     		strh	r2, [r3, #4]	@ movhi
1500:../QS/QS_ax12.c **** 		AX12_on_the_robot[id_servo].angle_limit[1] = max_angle;
 5765              		.loc 2 1500 0
 5766 2288 F97B     		ldrb	r1, [r7, #15]	@ zero_extendqisi2
 5767 228a 40F20002 		movw	r2, #:lower16:AX12_on_the_robot
 5768 228e C0F20002 		movt	r2, #:upper16:AX12_on_the_robot
 5769 2292 0B46     		mov	r3, r1
 5770 2294 4FEA8303 		lsl	r3, r3, #2
 5771 2298 5B18     		adds	r3, r3, r1
 5772 229a 4FEA4303 		lsl	r3, r3, #1
 5773 229e D318     		adds	r3, r2, r3
 5774 22a0 03F10203 		add	r3, r3, #2
 5775 22a4 FA8B     		ldrh	r2, [r7, #30]	@ movhi
 5776 22a6 9A80     		strh	r2, [r3, #4]	@ movhi
1501:../QS/QS_ax12.c **** 
1502:../QS/QS_ax12.c **** 		return TRUE;
 5777              		.loc 2 1502 0
 5778 22a8 4FF00103 		mov	r3, #1
 5779 22ac 44E0     		b	.L323
 5780              	.L324:
 5781              	.LBE5:
1503:../QS/QS_ax12.c **** 	} else {
1504:../QS/QS_ax12.c **** 		AX12_on_the_robot[id_servo].is_wheel_enabled = FALSE;
 5782              		.loc 2 1504 0
 5783 22ae F97B     		ldrb	r1, [r7, #15]	@ zero_extendqisi2
 5784 22b0 40F20002 		movw	r2, #:lower16:AX12_on_the_robot
 5785 22b4 C0F20002 		movt	r2, #:upper16:AX12_on_the_robot
 5786 22b8 0B46     		mov	r3, r1
 5787 22ba 4FEA8303 		lsl	r3, r3, #2
 5788 22be 5B18     		adds	r3, r3, r1
 5789 22c0 4FEA4303 		lsl	r3, r3, #1
 5790 22c4 D318     		adds	r3, r2, r3
 5791 22c6 03F10803 		add	r3, r3, #8
 5792 22ca 4FF00002 		mov	r2, #0
 5793 22ce 1A70     		strb	r2, [r3, #0]
1505:../QS/QS_ax12.c **** 		if(!AX12_config_set_minimal_angle(id_servo, AX12_on_the_robot[id_servo].angle_limit[0]))
 5794              		.loc 2 1505 0
 5795 22d0 F97B     		ldrb	r1, [r7, #15]	@ zero_extendqisi2
 5796 22d2 40F20002 		movw	r2, #:lower16:AX12_on_the_robot
 5797 22d6 C0F20002 		movt	r2, #:upper16:AX12_on_the_robot
 5798 22da 0B46     		mov	r3, r1
 5799 22dc 4FEA8303 		lsl	r3, r3, #2
 5800 22e0 5B18     		adds	r3, r3, r1
 5801 22e2 4FEA4303 		lsl	r3, r3, #1
 5802 22e6 D318     		adds	r3, r2, r3
 5803 22e8 9B88     		ldrh	r3, [r3, #4]
 5804 22ea FA7B     		ldrb	r2, [r7, #15]	@ zero_extendqisi2
 5805 22ec 1046     		mov	r0, r2
 5806 22ee 1946     		mov	r1, r3
 5807 22f0 FFF7FEFF 		bl	AX12_config_set_minimal_angle
 5808 22f4 0346     		mov	r3, r0
 5809 22f6 002B     		cmp	r3, #0
 5810 22f8 02D1     		bne	.L330
1506:../QS/QS_ax12.c **** 			return FALSE;
 5811              		.loc 2 1506 0
 5812 22fa 4FF00003 		mov	r3, #0
 5813 22fe 1BE0     		b	.L323
 5814              	.L330:
1507:../QS/QS_ax12.c **** 		if(!AX12_config_set_maximal_angle(id_servo, AX12_on_the_robot[id_servo].angle_limit[1]))
 5815              		.loc 2 1507 0
 5816 2300 F97B     		ldrb	r1, [r7, #15]	@ zero_extendqisi2
 5817 2302 40F20002 		movw	r2, #:lower16:AX12_on_the_robot
 5818 2306 C0F20002 		movt	r2, #:upper16:AX12_on_the_robot
 5819 230a 0B46     		mov	r3, r1
 5820 230c 4FEA8303 		lsl	r3, r3, #2
 5821 2310 5B18     		adds	r3, r3, r1
 5822 2312 4FEA4303 		lsl	r3, r3, #1
 5823 2316 D318     		adds	r3, r2, r3
 5824 2318 03F10203 		add	r3, r3, #2
 5825 231c 9B88     		ldrh	r3, [r3, #4]
 5826 231e FA7B     		ldrb	r2, [r7, #15]	@ zero_extendqisi2
 5827 2320 1046     		mov	r0, r2
 5828 2322 1946     		mov	r1, r3
 5829 2324 FFF7FEFF 		bl	AX12_config_set_maximal_angle
 5830 2328 0346     		mov	r3, r0
 5831 232a 002B     		cmp	r3, #0
 5832 232c 02D1     		bne	.L331
1508:../QS/QS_ax12.c **** 			return FALSE;
 5833              		.loc 2 1508 0
 5834 232e 4FF00003 		mov	r3, #0
 5835 2332 01E0     		b	.L323
 5836              	.L331:
1509:../QS/QS_ax12.c **** 		return TRUE;
 5837              		.loc 2 1509 0
 5838 2334 4FF00103 		mov	r3, #1
 5839              	.L323:
1510:../QS/QS_ax12.c **** 	}
1511:../QS/QS_ax12.c **** }
 5840              		.loc 2 1511 0
 5841 2338 1846     		mov	r0, r3
 5842 233a 07F12007 		add	r7, r7, #32
 5843 233e BD46     		mov	sp, r7
 5844 2340 80BD     		pop	{r7, pc}
 5845              		.cfi_endproc
 5846              	.LFE181:
 5848 2342 00BF     		.align	2
 5849              		.global	AX12_set_torque_enabled
 5850              		.thumb
 5851              		.thumb_func
 5853              	AX12_set_torque_enabled:
 5854              	.LFB182:
1512:../QS/QS_ax12.c **** #endif //AX12_STATUS_RETURN_MODE != AX12_STATUS_RETURN_NEVER
1513:../QS/QS_ax12.c **** 
1514:../QS/QS_ax12.c **** bool_e AX12_set_torque_enabled(Uint8 id_servo, bool_e enabled) {
 5855              		.loc 2 1514 0
 5856              		.cfi_startproc
 5857              		@ args = 0, pretend = 0, frame = 8
 5858              		@ frame_needed = 1, uses_anonymous_args = 0
 5859 2344 80B5     		push	{r7, lr}
 5860              	.LCFI215:
 5861              		.cfi_def_cfa_offset 8
 5862              		.cfi_offset 7, -8
 5863              		.cfi_offset 14, -4
 5864 2346 82B0     		sub	sp, sp, #8
 5865              	.LCFI216:
 5866              		.cfi_def_cfa_offset 16
 5867 2348 00AF     		add	r7, sp, #0
 5868              	.LCFI217:
 5869              		.cfi_def_cfa_register 7
 5870 234a 0246     		mov	r2, r0
 5871 234c 0B46     		mov	r3, r1
 5872 234e FA71     		strb	r2, [r7, #7]
 5873 2350 BB71     		strb	r3, [r7, #6]
1515:../QS/QS_ax12.c **** 	return AX12_instruction_write8(id_servo, AX12_TORQUE_ENABLE, enabled != 0);
 5874              		.loc 2 1515 0
 5875 2352 BB79     		ldrb	r3, [r7, #6]	@ zero_extendqisi2
 5876 2354 002B     		cmp	r3, #0
 5877 2356 0CBF     		ite	eq
 5878 2358 0023     		moveq	r3, #0
 5879 235a 0123     		movne	r3, #1
 5880 235c DBB2     		uxtb	r3, r3
 5881 235e FA79     		ldrb	r2, [r7, #7]	@ zero_extendqisi2
 5882 2360 1046     		mov	r0, r2
 5883 2362 4FF01801 		mov	r1, #24
 5884 2366 1A46     		mov	r2, r3
 5885 2368 FEF77EF8 		bl	AX12_instruction_write8
 5886 236c 0346     		mov	r3, r0
1516:../QS/QS_ax12.c **** }
 5887              		.loc 2 1516 0
 5888 236e 1846     		mov	r0, r3
 5889 2370 07F10807 		add	r7, r7, #8
 5890 2374 BD46     		mov	sp, r7
 5891 2376 80BD     		pop	{r7, pc}
 5892              		.cfi_endproc
 5893              	.LFE182:
 5895              		.align	2
 5896              		.global	AX12_set_led_enabled
 5897              		.thumb
 5898              		.thumb_func
 5900              	AX12_set_led_enabled:
 5901              	.LFB183:
1517:../QS/QS_ax12.c **** 
1518:../QS/QS_ax12.c **** bool_e AX12_set_led_enabled(Uint8 id_servo, bool_e enabled) {
 5902              		.loc 2 1518 0
 5903              		.cfi_startproc
 5904              		@ args = 0, pretend = 0, frame = 8
 5905              		@ frame_needed = 1, uses_anonymous_args = 0
 5906 2378 80B5     		push	{r7, lr}
 5907              	.LCFI218:
 5908              		.cfi_def_cfa_offset 8
 5909              		.cfi_offset 7, -8
 5910              		.cfi_offset 14, -4
 5911 237a 82B0     		sub	sp, sp, #8
 5912              	.LCFI219:
 5913              		.cfi_def_cfa_offset 16
 5914 237c 00AF     		add	r7, sp, #0
 5915              	.LCFI220:
 5916              		.cfi_def_cfa_register 7
 5917 237e 0246     		mov	r2, r0
 5918 2380 0B46     		mov	r3, r1
 5919 2382 FA71     		strb	r2, [r7, #7]
 5920 2384 BB71     		strb	r3, [r7, #6]
1519:../QS/QS_ax12.c **** 	return AX12_instruction_write8(id_servo, AX12_LED, enabled != 0);
 5921              		.loc 2 1519 0
 5922 2386 BB79     		ldrb	r3, [r7, #6]	@ zero_extendqisi2
 5923 2388 002B     		cmp	r3, #0
 5924 238a 0CBF     		ite	eq
 5925 238c 0023     		moveq	r3, #0
 5926 238e 0123     		movne	r3, #1
 5927 2390 DBB2     		uxtb	r3, r3
 5928 2392 FA79     		ldrb	r2, [r7, #7]	@ zero_extendqisi2
 5929 2394 1046     		mov	r0, r2
 5930 2396 4FF01901 		mov	r1, #25
 5931 239a 1A46     		mov	r2, r3
 5932 239c FEF764F8 		bl	AX12_instruction_write8
 5933 23a0 0346     		mov	r3, r0
1520:../QS/QS_ax12.c **** }
 5934              		.loc 2 1520 0
 5935 23a2 1846     		mov	r0, r3
 5936 23a4 07F10807 		add	r7, r7, #8
 5937 23a8 BD46     		mov	sp, r7
 5938 23aa 80BD     		pop	{r7, pc}
 5939              		.cfi_endproc
 5940              	.LFE183:
 5942              		.align	2
 5943              		.global	AX12_set_torque_response
 5944              		.thumb
 5945              		.thumb_func
 5947              	AX12_set_torque_response:
 5948              	.LFB184:
1521:../QS/QS_ax12.c **** 
1522:../QS/QS_ax12.c **** 	/*
1523:../QS/QS_ax12.c **** 	Paramtrage de l'asservissement avec AX12_set_torque_response(A, B, C, D)
1524:../QS/QS_ax12.c **** 				Couple          Consigne de position
1525:../QS/QS_ax12.c **** 					^                   |
1526:../QS/QS_ax12.c **** 					|=============\     |
1527:../QS/QS_ax12.c **** 					|             ^\    |
1528:../QS/QS_ax12.c **** 	Sens anti-      |             | |   v
1529:../QS/QS_ax12.c **** 	  horaire     <-+-------------|-+=======+------------------->  Sens horaire
1530:../QS/QS_ax12.c **** 					|             | ^   ^   |             X: Erreur en position
1531:../QS/QS_ax12.c **** 					|             | |   |    \
1532:../QS/QS_ax12.c **** 					|             | |   |   ^ \===============
1533:../QS/QS_ax12.c **** 					v             | |   |   | ^
1534:../QS/QS_ax12.c **** 								  A B   0   C D
1535:../QS/QS_ax12.c **** 
1536:../QS/QS_ax12.c **** 	=== : Courbe du couple en fonction de l'erreur en position
1537:../QS/QS_ax12.c **** 	Les points A, B, C, D sont la valeur absolue de la diffrence de position entre le point et la pos
1538:../QS/QS_ax12.c **** 	Si la valeur absolue de l'erreur est plus grande que A (sens anti-horaire) ou D (sens horaire), le
1539:../QS/QS_ax12.c **** 	Si la valeur absolue de l'erreur est entre A et B ou C et D, le couple est proportionnel  la vale
1540:../QS/QS_ax12.c **** 	Si la valeur absolue de l'erreur est plus petite que B ou C, l'AX12 n'exerce aucun couple
1541:../QS/QS_ax12.c **** 
1542:../QS/QS_ax12.c **** 	*/
1543:../QS/QS_ax12.c **** bool_e AX12_set_torque_response(Uint8 id_servo, Uint16 A, Uint16 B, Uint16 C, Uint16 D) {
 5949              		.loc 2 1543 0
 5950              		.cfi_startproc
 5951              		@ args = 4, pretend = 0, frame = 32
 5952              		@ frame_needed = 1, uses_anonymous_args = 0
 5953 23ac 80B5     		push	{r7, lr}
 5954              	.LCFI221:
 5955              		.cfi_def_cfa_offset 8
 5956              		.cfi_offset 7, -8
 5957              		.cfi_offset 14, -4
 5958 23ae 88B0     		sub	sp, sp, #32
 5959              	.LCFI222:
 5960              		.cfi_def_cfa_offset 40
 5961 23b0 00AF     		add	r7, sp, #0
 5962              	.LCFI223:
 5963              		.cfi_def_cfa_register 7
 5964 23b2 F873     		strb	r0, [r7, #15]
 5965 23b4 B981     		strh	r1, [r7, #12]	@ movhi
 5966 23b6 7A81     		strh	r2, [r7, #10]	@ movhi
 5967 23b8 3B81     		strh	r3, [r7, #8]	@ movhi
1544:../QS/QS_ax12.c **** 	Uint16 CcwComplianceSlope;
1545:../QS/QS_ax12.c **** 	Uint16 CcwComplianceMargin;
1546:../QS/QS_ax12.c **** 	Uint16 CwComplianceMargin;
1547:../QS/QS_ax12.c **** 	Uint16 CwComplianceSlope;
1548:../QS/QS_ax12.c **** 
1549:../QS/QS_ax12.c **** 	//Limite d'angle max sinon si l'angle est trop lev, AX12_DEGRE_TO_ANGLE pourrait renvoyer une va
1550:../QS/QS_ax12.c **** 	if(A > AX12_MAX_DEGRE)
 5968              		.loc 2 1550 0
 5969 23ba BB89     		ldrh	r3, [r7, #12]
 5970 23bc B3F5B47F 		cmp	r3, #360
 5971 23c0 02D9     		bls	.L337
1551:../QS/QS_ax12.c **** 		A = AX12_MAX_DEGRE;
 5972              		.loc 2 1551 0
 5973 23c2 4FF4B473 		mov	r3, #360
 5974 23c6 BB81     		strh	r3, [r7, #12]	@ movhi
 5975              	.L337:
1552:../QS/QS_ax12.c **** 	if(B > AX12_MAX_DEGRE)
 5976              		.loc 2 1552 0
 5977 23c8 7B89     		ldrh	r3, [r7, #10]
 5978 23ca B3F5B47F 		cmp	r3, #360
 5979 23ce 02D9     		bls	.L338
1553:../QS/QS_ax12.c **** 		B = AX12_MAX_DEGRE;
 5980              		.loc 2 1553 0
 5981 23d0 4FF4B473 		mov	r3, #360
 5982 23d4 7B81     		strh	r3, [r7, #10]	@ movhi
 5983              	.L338:
1554:../QS/QS_ax12.c **** 	if(C > AX12_MAX_DEGRE)
 5984              		.loc 2 1554 0
 5985 23d6 3B89     		ldrh	r3, [r7, #8]
 5986 23d8 B3F5B47F 		cmp	r3, #360
 5987 23dc 02D9     		bls	.L339
1555:../QS/QS_ax12.c **** 		C = AX12_MAX_DEGRE;
 5988              		.loc 2 1555 0
 5989 23de 4FF4B473 		mov	r3, #360
 5990 23e2 3B81     		strh	r3, [r7, #8]	@ movhi
 5991              	.L339:
1556:../QS/QS_ax12.c **** 	if(D > AX12_MAX_DEGRE)
 5992              		.loc 2 1556 0
 5993 23e4 3B8D     		ldrh	r3, [r7, #40]
 5994 23e6 B3F5B47F 		cmp	r3, #360
 5995 23ea 02D9     		bls	.L340
1557:../QS/QS_ax12.c **** 		D = AX12_MAX_DEGRE;
 5996              		.loc 2 1557 0
 5997 23ec 4FF4B473 		mov	r3, #360
 5998 23f0 3B85     		strh	r3, [r7, #40]	@ movhi
 5999              	.L340:
1558:../QS/QS_ax12.c **** 
1559:../QS/QS_ax12.c **** 	CcwComplianceSlope = AX12_DEGRE_TO_ANGLE(A);
 6000              		.loc 2 1559 0
 6001 23f2 BB89     		ldrh	r3, [r7, #12]
 6002 23f4 4FEAC312 		lsl	r2, r3, #7
 6003 23f8 41F6F323 		movw	r3, #6899
 6004 23fc C6F6CA33 		movt	r3, 27594
 6005 2400 83FB0213 		smull	r1, r3, r3, r2
 6006 2404 4FEA2311 		asr	r1, r3, #4
 6007 2408 4FEAE273 		asr	r3, r2, #31
 6008 240c CB1A     		subs	r3, r1, r3
 6009 240e FB83     		strh	r3, [r7, #30]	@ movhi
1560:../QS/QS_ax12.c **** 	CcwComplianceMargin = AX12_DEGRE_TO_ANGLE(B);
 6010              		.loc 2 1560 0
 6011 2410 7B89     		ldrh	r3, [r7, #10]
 6012 2412 4FEAC312 		lsl	r2, r3, #7
 6013 2416 41F6F323 		movw	r3, #6899
 6014 241a C6F6CA33 		movt	r3, 27594
 6015 241e 83FB0213 		smull	r1, r3, r3, r2
 6016 2422 4FEA2311 		asr	r1, r3, #4
 6017 2426 4FEAE273 		asr	r3, r2, #31
 6018 242a CB1A     		subs	r3, r1, r3
 6019 242c BB83     		strh	r3, [r7, #28]	@ movhi
1561:../QS/QS_ax12.c **** 	CwComplianceMargin = AX12_DEGRE_TO_ANGLE(C);
 6020              		.loc 2 1561 0
 6021 242e 3B89     		ldrh	r3, [r7, #8]
 6022 2430 4FEAC312 		lsl	r2, r3, #7
 6023 2434 41F6F323 		movw	r3, #6899
 6024 2438 C6F6CA33 		movt	r3, 27594
 6025 243c 83FB0213 		smull	r1, r3, r3, r2
 6026 2440 4FEA2311 		asr	r1, r3, #4
 6027 2444 4FEAE273 		asr	r3, r2, #31
 6028 2448 CB1A     		subs	r3, r1, r3
 6029 244a 7B83     		strh	r3, [r7, #26]	@ movhi
1562:../QS/QS_ax12.c **** 	CwComplianceSlope = AX12_DEGRE_TO_ANGLE(D);
 6030              		.loc 2 1562 0
 6031 244c 3B8D     		ldrh	r3, [r7, #40]
 6032 244e 4FEAC312 		lsl	r2, r3, #7
 6033 2452 41F6F323 		movw	r3, #6899
 6034 2456 C6F6CA33 		movt	r3, 27594
 6035 245a 83FB0213 		smull	r1, r3, r3, r2
 6036 245e 4FEA2311 		asr	r1, r3, #4
 6037 2462 4FEAE273 		asr	r3, r2, #31
 6038 2466 CB1A     		subs	r3, r1, r3
 6039 2468 3B83     		strh	r3, [r7, #24]	@ movhi
1563:../QS/QS_ax12.c **** 
1564:../QS/QS_ax12.c **** 	if(!AX12_instruction_async_write8(id_servo, AX12_CCW_COMPLIANCE_SLOPE, CcwComplianceSlope))
 6040              		.loc 2 1564 0
 6041 246a FB8B     		ldrh	r3, [r7, #30]	@ movhi
 6042 246c DBB2     		uxtb	r3, r3
 6043 246e FA7B     		ldrb	r2, [r7, #15]	@ zero_extendqisi2
 6044 2470 1046     		mov	r0, r2
 6045 2472 4FF01D01 		mov	r1, #29
 6046 2476 1A46     		mov	r2, r3
 6047 2478 FDF722FE 		bl	AX12_instruction_async_write8
 6048 247c 0346     		mov	r3, r0
 6049 247e 002B     		cmp	r3, #0
 6050 2480 02D1     		bne	.L341
1565:../QS/QS_ax12.c **** 		return FALSE;
 6051              		.loc 2 1565 0
 6052 2482 4FF00003 		mov	r3, #0
 6053 2486 45E0     		b	.L342
 6054              	.L341:
1566:../QS/QS_ax12.c **** 	if(!AX12_instruction_async_write8(id_servo, AX12_CCW_COMPLIANCE_MARGIN, CcwComplianceMargin))
 6055              		.loc 2 1566 0
 6056 2488 BB8B     		ldrh	r3, [r7, #28]	@ movhi
 6057 248a DBB2     		uxtb	r3, r3
 6058 248c FA7B     		ldrb	r2, [r7, #15]	@ zero_extendqisi2
 6059 248e 1046     		mov	r0, r2
 6060 2490 4FF01B01 		mov	r1, #27
 6061 2494 1A46     		mov	r2, r3
 6062 2496 FDF713FE 		bl	AX12_instruction_async_write8
 6063 249a 0346     		mov	r3, r0
 6064 249c 002B     		cmp	r3, #0
 6065 249e 02D1     		bne	.L343
1567:../QS/QS_ax12.c **** 		return FALSE;
 6066              		.loc 2 1567 0
 6067 24a0 4FF00003 		mov	r3, #0
 6068 24a4 36E0     		b	.L342
 6069              	.L343:
1568:../QS/QS_ax12.c **** 	if(!AX12_instruction_async_write8(id_servo, AX12_CW_COMPLIANCE_MARGIN, CwComplianceMargin))
 6070              		.loc 2 1568 0
 6071 24a6 7B8B     		ldrh	r3, [r7, #26]	@ movhi
 6072 24a8 DBB2     		uxtb	r3, r3
 6073 24aa FA7B     		ldrb	r2, [r7, #15]	@ zero_extendqisi2
 6074 24ac 1046     		mov	r0, r2
 6075 24ae 4FF01A01 		mov	r1, #26
 6076 24b2 1A46     		mov	r2, r3
 6077 24b4 FDF704FE 		bl	AX12_instruction_async_write8
 6078 24b8 0346     		mov	r3, r0
 6079 24ba 002B     		cmp	r3, #0
 6080 24bc 02D1     		bne	.L344
1569:../QS/QS_ax12.c **** 		return FALSE;
 6081              		.loc 2 1569 0
 6082 24be 4FF00003 		mov	r3, #0
 6083 24c2 27E0     		b	.L342
 6084              	.L344:
1570:../QS/QS_ax12.c **** 	if(!AX12_instruction_async_write8(id_servo, AX12_CW_COMPLIANCE_SLOPE, CwComplianceSlope))
 6085              		.loc 2 1570 0
 6086 24c4 3B8B     		ldrh	r3, [r7, #24]	@ movhi
 6087 24c6 DBB2     		uxtb	r3, r3
 6088 24c8 FA7B     		ldrb	r2, [r7, #15]	@ zero_extendqisi2
 6089 24ca 1046     		mov	r0, r2
 6090 24cc 4FF01C01 		mov	r1, #28
 6091 24d0 1A46     		mov	r2, r3
 6092 24d2 FDF7F5FD 		bl	AX12_instruction_async_write8
 6093 24d6 0346     		mov	r3, r0
 6094 24d8 002B     		cmp	r3, #0
 6095 24da 02D1     		bne	.L345
1571:../QS/QS_ax12.c **** 		return FALSE;
 6096              		.loc 2 1571 0
 6097 24dc 4FF00003 		mov	r3, #0
 6098 24e0 18E0     		b	.L342
 6099              	.L345:
1572:../QS/QS_ax12.c **** 
1573:../QS/QS_ax12.c **** 	#if AX12_STATUS_RETURN_MODE == AX12_STATUS_RETURN_ALWAYS
1574:../QS/QS_ax12.c **** 		if(!AX12_instruction_wait(id_servo) || AX12_instruction_get_last_status(id_servo).error == 0)
 6100              		.loc 2 1574 0
 6101 24e2 FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 6102 24e4 1846     		mov	r0, r3
 6103 24e6 FEF7CDF8 		bl	AX12_instruction_wait
 6104 24ea 0346     		mov	r3, r0
 6105 24ec 002B     		cmp	r3, #0
 6106 24ee 0CD0     		beq	.L346
 6107              		.loc 2 1574 0 is_stmt 0 discriminator 1
 6108 24f0 FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 6109 24f2 1846     		mov	r0, r3
 6110 24f4 FEF730F9 		bl	AX12_instruction_get_last_status
 6111 24f8 3880     		strh	r0, [r7, #0]	@ movhi
 6112 24fa C0F30F43 		ubfx	r3, r0, #16, #16
 6113 24fe 7B80     		strh	r3, [r7, #2]	@ movhi
 6114 2500 3B68     		ldr	r3, [r7, #0]
 6115 2502 7B61     		str	r3, [r7, #20]
 6116 2504 3B7D     		ldrb	r3, [r7, #20]	@ zero_extendqisi2
 6117 2506 002B     		cmp	r3, #0
 6118 2508 02D1     		bne	.L347
 6119              	.L346:
1575:../QS/QS_ax12.c **** 			return FALSE;
 6120              		.loc 2 1575 0 is_stmt 1
 6121 250a 4FF00003 		mov	r3, #0
 6122 250e 01E0     		b	.L342
 6123              	.L347:
1576:../QS/QS_ax12.c **** 	#endif
1577:../QS/QS_ax12.c **** 
1578:../QS/QS_ax12.c **** 	return TRUE;
 6124              		.loc 2 1578 0
 6125 2510 4FF00103 		mov	r3, #1
 6126              	.L342:
1579:../QS/QS_ax12.c **** }
 6127              		.loc 2 1579 0
 6128 2514 1846     		mov	r0, r3
 6129 2516 07F12007 		add	r7, r7, #32
 6130 251a BD46     		mov	sp, r7
 6131 251c 80BD     		pop	{r7, pc}
 6132              		.cfi_endproc
 6133              	.LFE184:
 6135 251e 00BF     		.align	2
 6136              		.global	AX12_set_position
 6137              		.thumb
 6138              		.thumb_func
 6140              	AX12_set_position:
 6141              	.LFB185:
1580:../QS/QS_ax12.c **** 
1581:../QS/QS_ax12.c **** bool_e AX12_set_position(Uint8 id_servo, Uint16 degre) {
 6142              		.loc 2 1581 0
 6143              		.cfi_startproc
 6144              		@ args = 0, pretend = 0, frame = 8
 6145              		@ frame_needed = 1, uses_anonymous_args = 0
 6146 2520 80B5     		push	{r7, lr}
 6147              	.LCFI224:
 6148              		.cfi_def_cfa_offset 8
 6149              		.cfi_offset 7, -8
 6150              		.cfi_offset 14, -4
 6151 2522 82B0     		sub	sp, sp, #8
 6152              	.LCFI225:
 6153              		.cfi_def_cfa_offset 16
 6154 2524 00AF     		add	r7, sp, #0
 6155              	.LCFI226:
 6156              		.cfi_def_cfa_register 7
 6157 2526 0246     		mov	r2, r0
 6158 2528 0B46     		mov	r3, r1
 6159 252a FA71     		strb	r2, [r7, #7]
 6160 252c BB80     		strh	r3, [r7, #4]	@ movhi
1582:../QS/QS_ax12.c **** 	if(degre > AX12_MAX_DEGRE) degre = AX12_MAX_DEGRE;
 6161              		.loc 2 1582 0
 6162 252e BB88     		ldrh	r3, [r7, #4]
 6163 2530 B3F5B47F 		cmp	r3, #360
 6164 2534 02D9     		bls	.L349
 6165              		.loc 2 1582 0 is_stmt 0 discriminator 1
 6166 2536 4FF4B473 		mov	r3, #360
 6167 253a BB80     		strh	r3, [r7, #4]	@ movhi
 6168              	.L349:
1583:../QS/QS_ax12.c **** 	return AX12_instruction_write16(id_servo, AX12_GOAL_POSITION_L, AX12_DEGRE_TO_ANGLE(degre));
 6169              		.loc 2 1583 0 is_stmt 1
 6170 253c BB88     		ldrh	r3, [r7, #4]
 6171 253e 4FEAC312 		lsl	r2, r3, #7
 6172 2542 41F6F323 		movw	r3, #6899
 6173 2546 C6F6CA33 		movt	r3, 27594
 6174 254a 83FB0213 		smull	r1, r3, r3, r2
 6175 254e 4FEA2311 		asr	r1, r3, #4
 6176 2552 4FEAE273 		asr	r3, r2, #31
 6177 2556 CB1A     		subs	r3, r1, r3
 6178 2558 9BB2     		uxth	r3, r3
 6179 255a FA79     		ldrb	r2, [r7, #7]	@ zero_extendqisi2
 6180 255c 1046     		mov	r0, r2
 6181 255e 4FF01E01 		mov	r1, #30
 6182 2562 1A46     		mov	r2, r3
 6183 2564 FDF7D2FF 		bl	AX12_instruction_write16
 6184 2568 0346     		mov	r3, r0
1584:../QS/QS_ax12.c **** }
 6185              		.loc 2 1584 0
 6186 256a 1846     		mov	r0, r3
 6187 256c 07F10807 		add	r7, r7, #8
 6188 2570 BD46     		mov	sp, r7
 6189 2572 80BD     		pop	{r7, pc}
 6190              		.cfi_endproc
 6191              	.LFE185:
 6193              		.section	.rodata
 6194 037b 00       		.align	2
 6195              	.LC16:
 6196 037c 41583132 		.ascii	"AX12: AX12_set_move_to_position_speed while in whee"
 6196      3A204158 
 6196      31325F73 
 6196      65745F6D 
 6196      6F76655F 
 6197 03af 6C206D6F 		.ascii	"l mode, use AX12_set_speed_percentage instead.\012\000"
 6197      64652C20 
 6197      75736520 
 6197      41583132 
 6197      5F736574 
 6198              		.text
 6199              		.align	2
 6200              		.global	AX12_set_move_to_position_speed
 6201              		.thumb
 6202              		.thumb_func
 6204              	AX12_set_move_to_position_speed:
 6205              	.LFB186:
1585:../QS/QS_ax12.c **** 
1586:../QS/QS_ax12.c **** bool_e AX12_set_move_to_position_speed(Uint8 id_servo, Uint16 degre_per_sec) {
 6206              		.loc 2 1586 0
 6207              		.cfi_startproc
 6208              		@ args = 0, pretend = 0, frame = 8
 6209              		@ frame_needed = 1, uses_anonymous_args = 0
 6210 2574 80B5     		push	{r7, lr}
 6211              	.LCFI227:
 6212              		.cfi_def_cfa_offset 8
 6213              		.cfi_offset 7, -8
 6214              		.cfi_offset 14, -4
 6215 2576 82B0     		sub	sp, sp, #8
 6216              	.LCFI228:
 6217              		.cfi_def_cfa_offset 16
 6218 2578 00AF     		add	r7, sp, #0
 6219              	.LCFI229:
 6220              		.cfi_def_cfa_register 7
 6221 257a 0246     		mov	r2, r0
 6222 257c 0B46     		mov	r3, r1
 6223 257e FA71     		strb	r2, [r7, #7]
 6224 2580 BB80     		strh	r3, [r7, #4]	@ movhi
1587:../QS/QS_ax12.c **** 	if(AX12_on_the_robot[id_servo].is_wheel_enabled) {
 6225              		.loc 2 1587 0
 6226 2582 F979     		ldrb	r1, [r7, #7]	@ zero_extendqisi2
 6227 2584 40F20002 		movw	r2, #:lower16:AX12_on_the_robot
 6228 2588 C0F20002 		movt	r2, #:upper16:AX12_on_the_robot
 6229 258c 0B46     		mov	r3, r1
 6230 258e 4FEA8303 		lsl	r3, r3, #2
 6231 2592 5B18     		adds	r3, r3, r1
 6232 2594 4FEA4303 		lsl	r3, r3, #1
 6233 2598 D318     		adds	r3, r2, r3
 6234 259a 03F10803 		add	r3, r3, #8
 6235 259e 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 6236 25a0 002B     		cmp	r3, #0
 6237 25a2 0AD0     		beq	.L352
1588:../QS/QS_ax12.c **** 		debug_printf("AX12: AX12_set_move_to_position_speed while in wheel mode, use AX12_set_speed_perce
 6238              		.loc 2 1588 0
 6239 25a4 4FF00500 		mov	r0, #5
 6240 25a8 40F20001 		movw	r1, #:lower16:.LC16
 6241 25ac C0F20001 		movt	r1, #:upper16:.LC16
 6242 25b0 FFF7FEFF 		bl	OUTPUTLOG_printf
1589:../QS/QS_ax12.c **** 		return FALSE;
 6243              		.loc 2 1589 0
 6244 25b4 4FF00003 		mov	r3, #0
 6245 25b8 1DE0     		b	.L353
 6246              	.L352:
1590:../QS/QS_ax12.c **** 	}
1591:../QS/QS_ax12.c **** 
1592:../QS/QS_ax12.c **** 	if(degre_per_sec > AX12_MAX_DPS) degre_per_sec = AX12_MAX_DPS;
 6247              		.loc 2 1592 0
 6248 25ba BB88     		ldrh	r3, [r7, #4]
 6249 25bc B3F5FA7F 		cmp	r3, #500
 6250 25c0 02D9     		bls	.L354
 6251              		.loc 2 1592 0 is_stmt 0 discriminator 1
 6252 25c2 4FF4FA73 		mov	r3, #500
 6253 25c6 BB80     		strh	r3, [r7, #4]	@ movhi
 6254              	.L354:
1593:../QS/QS_ax12.c **** 	return AX12_instruction_write16(id_servo, AX12_GOAL_SPEED_L, AX12_DPS_TO_SPEED(degre_per_sec));
 6255              		.loc 2 1593 0 is_stmt 1
 6256 25c8 BB88     		ldrh	r3, [r7, #4]
 6257 25ca 4FEAC312 		lsl	r2, r3, #7
 6258 25ce 46F26103 		movw	r3, #24673
 6259 25d2 C6F26003 		movt	r3, 24672
 6260 25d6 83FB0213 		smull	r1, r3, r3, r2
 6261 25da 4FEA6311 		asr	r1, r3, #5
 6262 25de 4FEAE273 		asr	r3, r2, #31
 6263 25e2 CB1A     		subs	r3, r1, r3
 6264 25e4 9BB2     		uxth	r3, r3
 6265 25e6 FA79     		ldrb	r2, [r7, #7]	@ zero_extendqisi2
 6266 25e8 1046     		mov	r0, r2
 6267 25ea 4FF02001 		mov	r1, #32
 6268 25ee 1A46     		mov	r2, r3
 6269 25f0 FDF78CFF 		bl	AX12_instruction_write16
 6270 25f4 0346     		mov	r3, r0
 6271              	.L353:
1594:../QS/QS_ax12.c **** }
 6272              		.loc 2 1594 0
 6273 25f6 1846     		mov	r0, r3
 6274 25f8 07F10807 		add	r7, r7, #8
 6275 25fc BD46     		mov	sp, r7
 6276 25fe 80BD     		pop	{r7, pc}
 6277              		.cfi_endproc
 6278              	.LFE186:
 6280              		.section	.rodata
 6281 03df 00       		.align	2
 6282              	.LC17:
 6283 03e0 41583132 		.ascii	"AX12: AX12_set_speed_percentage while not in wheel "
 6283      3A204158 
 6283      31325F73 
 6283      65745F73 
 6283      70656564 
 6284 0413 6D6F6465 		.ascii	"mode, use AX12_set_move_to_position_speed instead.\012"
 6284      2C207573 
 6284      65204158 
 6284      31325F73 
 6284      65745F6D 
 6285 0446 00       		.ascii	"\000"
 6286 0447 00       		.text
 6287              		.align	2
 6288              		.global	AX12_set_speed_percentage
 6289              		.thumb
 6290              		.thumb_func
 6292              	AX12_set_speed_percentage:
 6293              	.LFB187:
1595:../QS/QS_ax12.c **** 
1596:../QS/QS_ax12.c **** bool_e AX12_set_speed_percentage(Uint8 id_servo, Sint8 percentage) {
 6294              		.loc 2 1596 0
 6295              		.cfi_startproc
 6296              		@ args = 0, pretend = 0, frame = 16
 6297              		@ frame_needed = 1, uses_anonymous_args = 0
 6298 2600 80B5     		push	{r7, lr}
 6299              	.LCFI230:
 6300              		.cfi_def_cfa_offset 8
 6301              		.cfi_offset 7, -8
 6302              		.cfi_offset 14, -4
 6303 2602 84B0     		sub	sp, sp, #16
 6304              	.LCFI231:
 6305              		.cfi_def_cfa_offset 24
 6306 2604 00AF     		add	r7, sp, #0
 6307              	.LCFI232:
 6308              		.cfi_def_cfa_register 7
 6309 2606 0246     		mov	r2, r0
 6310 2608 0B46     		mov	r3, r1
 6311 260a FA71     		strb	r2, [r7, #7]
 6312 260c BB71     		strb	r3, [r7, #6]
1597:../QS/QS_ax12.c **** 	bool_e isBackward;
1598:../QS/QS_ax12.c **** 
1599:../QS/QS_ax12.c **** 	if(!AX12_on_the_robot[id_servo].is_wheel_enabled) {
 6313              		.loc 2 1599 0
 6314 260e F979     		ldrb	r1, [r7, #7]	@ zero_extendqisi2
 6315 2610 40F20002 		movw	r2, #:lower16:AX12_on_the_robot
 6316 2614 C0F20002 		movt	r2, #:upper16:AX12_on_the_robot
 6317 2618 0B46     		mov	r3, r1
 6318 261a 4FEA8303 		lsl	r3, r3, #2
 6319 261e 5B18     		adds	r3, r3, r1
 6320 2620 4FEA4303 		lsl	r3, r3, #1
 6321 2624 D318     		adds	r3, r2, r3
 6322 2626 03F10803 		add	r3, r3, #8
 6323 262a 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 6324 262c 002B     		cmp	r3, #0
 6325 262e 0AD1     		bne	.L356
1600:../QS/QS_ax12.c **** 		debug_printf("AX12: AX12_set_speed_percentage while not in wheel mode, use AX12_set_move_to_posit
 6326              		.loc 2 1600 0
 6327 2630 4FF00500 		mov	r0, #5
 6328 2634 40F20001 		movw	r1, #:lower16:.LC17
 6329 2638 C0F20001 		movt	r1, #:upper16:.LC17
 6330 263c FFF7FEFF 		bl	OUTPUTLOG_printf
1601:../QS/QS_ax12.c **** 		return FALSE;
 6331              		.loc 2 1601 0
 6332 2640 4FF00003 		mov	r3, #0
 6333 2644 30E0     		b	.L357
 6334              	.L356:
1602:../QS/QS_ax12.c **** 	}
1603:../QS/QS_ax12.c **** 
1604:../QS/QS_ax12.c **** 	isBackward = percentage < 0;
 6335              		.loc 2 1604 0
 6336 2646 BB79     		ldrb	r3, [r7, #6]	@ zero_extendqisi2
 6337 2648 4FEAD313 		lsr	r3, r3, #7
 6338 264c DBB2     		uxtb	r3, r3
 6339 264e FB73     		strb	r3, [r7, #15]
1605:../QS/QS_ax12.c **** 	//percentage & 0x7F: on enlve le bit de signe, isBackward << 10: ajoute 1024 si on tourne a l'env
1606:../QS/QS_ax12.c **** 	percentage = percentage & 0x7F;
 6340              		.loc 2 1606 0
 6341 2650 BB79     		ldrb	r3, [r7, #6]
 6342 2652 03F07F03 		and	r3, r3, #127
 6343 2656 BB71     		strb	r3, [r7, #6]
1607:../QS/QS_ax12.c **** 	if(percentage > AX12_MAX_PERCENTAGE) percentage = AX12_MAX_PERCENTAGE;
 6344              		.loc 2 1607 0
 6345 2658 97F90630 		ldrsb	r3, [r7, #6]
 6346 265c 642B     		cmp	r3, #100
 6347 265e 02DD     		ble	.L358
 6348              		.loc 2 1607 0 is_stmt 0 discriminator 1
 6349 2660 4FF06403 		mov	r3, #100
 6350 2664 BB71     		strb	r3, [r7, #6]
 6351              	.L358:
1608:../QS/QS_ax12.c **** 	Uint16 realValue = AX12_PERCENTAGE_TO_1024(percentage) | (((Uint16)isBackward) << 10);
 6352              		.loc 2 1608 0 is_stmt 1
 6353 2666 97F90630 		ldrsb	r3, [r7, #6]
 6354 266a 9BB2     		uxth	r3, r3
 6355 266c 4FEA0322 		lsl	r2, r3, #8
 6356 2670 48F21F53 		movw	r3, #34079
 6357 2674 C5F2EB13 		movt	r3, 20971
 6358 2678 83FB0213 		smull	r1, r3, r3, r2
 6359 267c 4FEAE301 		asr	r1, r3, #3
 6360 2680 4FEAE273 		asr	r3, r2, #31
 6361 2684 CB1A     		subs	r3, r1, r3
 6362 2686 9AB2     		uxth	r2, r3
 6363 2688 FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 6364 268a 4FEA8323 		lsl	r3, r3, #10
 6365 268e 9BB2     		uxth	r3, r3
 6366 2690 1343     		orrs	r3, r3, r2
 6367 2692 9BB2     		uxth	r3, r3
 6368 2694 BB81     		strh	r3, [r7, #12]	@ movhi
1609:../QS/QS_ax12.c **** 
1610:../QS/QS_ax12.c **** 	return AX12_instruction_write16(id_servo, AX12_GOAL_SPEED_L, realValue);
 6369              		.loc 2 1610 0
 6370 2696 FA79     		ldrb	r2, [r7, #7]	@ zero_extendqisi2
 6371 2698 BB89     		ldrh	r3, [r7, #12]
 6372 269a 1046     		mov	r0, r2
 6373 269c 4FF02001 		mov	r1, #32
 6374 26a0 1A46     		mov	r2, r3
 6375 26a2 FDF733FF 		bl	AX12_instruction_write16
 6376 26a6 0346     		mov	r3, r0
 6377              	.L357:
1611:../QS/QS_ax12.c **** }
 6378              		.loc 2 1611 0
 6379 26a8 1846     		mov	r0, r3
 6380 26aa 07F11007 		add	r7, r7, #16
 6381 26ae BD46     		mov	sp, r7
 6382 26b0 80BD     		pop	{r7, pc}
 6383              		.cfi_endproc
 6384              	.LFE187:
 6386 26b2 00BF     		.align	2
 6387              		.global	AX12_set_torque_limit
 6388              		.thumb
 6389              		.thumb_func
 6391              	AX12_set_torque_limit:
 6392              	.LFB188:
1612:../QS/QS_ax12.c **** 
1613:../QS/QS_ax12.c **** bool_e AX12_set_torque_limit(Uint8 id_servo, Uint8 percentage) {
 6393              		.loc 2 1613 0
 6394              		.cfi_startproc
 6395              		@ args = 0, pretend = 0, frame = 8
 6396              		@ frame_needed = 1, uses_anonymous_args = 0
 6397 26b4 80B5     		push	{r7, lr}
 6398              	.LCFI233:
 6399              		.cfi_def_cfa_offset 8
 6400              		.cfi_offset 7, -8
 6401              		.cfi_offset 14, -4
 6402 26b6 82B0     		sub	sp, sp, #8
 6403              	.LCFI234:
 6404              		.cfi_def_cfa_offset 16
 6405 26b8 00AF     		add	r7, sp, #0
 6406              	.LCFI235:
 6407              		.cfi_def_cfa_register 7
 6408 26ba 0246     		mov	r2, r0
 6409 26bc 0B46     		mov	r3, r1
 6410 26be FA71     		strb	r2, [r7, #7]
 6411 26c0 BB71     		strb	r3, [r7, #6]
1614:../QS/QS_ax12.c **** 	if(percentage > AX12_MAX_PERCENTAGE) percentage = AX12_MAX_PERCENTAGE;
 6412              		.loc 2 1614 0
 6413 26c2 BB79     		ldrb	r3, [r7, #6]	@ zero_extendqisi2
 6414 26c4 642B     		cmp	r3, #100
 6415 26c6 02D9     		bls	.L360
 6416              		.loc 2 1614 0 is_stmt 0 discriminator 1
 6417 26c8 4FF06403 		mov	r3, #100
 6418 26cc BB71     		strb	r3, [r7, #6]
 6419              	.L360:
1615:../QS/QS_ax12.c **** 
1616:../QS/QS_ax12.c **** 	return AX12_instruction_write16(id_servo, AX12_TORQUE_LIMIT_L, AX12_PERCENTAGE_TO_1024(percentage)
 6420              		.loc 2 1616 0 is_stmt 1
 6421 26ce BB79     		ldrb	r3, [r7, #6]	@ zero_extendqisi2
 6422 26d0 4FEA0322 		lsl	r2, r3, #8
 6423 26d4 48F21F53 		movw	r3, #34079
 6424 26d8 C5F2EB13 		movt	r3, 20971
 6425 26dc 83FB0213 		smull	r1, r3, r3, r2
 6426 26e0 4FEAE301 		asr	r1, r3, #3
 6427 26e4 4FEAE273 		asr	r3, r2, #31
 6428 26e8 CB1A     		subs	r3, r1, r3
 6429 26ea 9BB2     		uxth	r3, r3
 6430 26ec FA79     		ldrb	r2, [r7, #7]	@ zero_extendqisi2
 6431 26ee 1046     		mov	r0, r2
 6432 26f0 4FF02201 		mov	r1, #34
 6433 26f4 1A46     		mov	r2, r3
 6434 26f6 FDF709FF 		bl	AX12_instruction_write16
 6435 26fa 0346     		mov	r3, r0
1617:../QS/QS_ax12.c **** }
 6436              		.loc 2 1617 0
 6437 26fc 1846     		mov	r0, r3
 6438 26fe 07F10807 		add	r7, r7, #8
 6439 2702 BD46     		mov	sp, r7
 6440 2704 80BD     		pop	{r7, pc}
 6441              		.cfi_endproc
 6442              	.LFE188:
 6444 2706 00BF     		.align	2
 6445              		.global	AX12_set_punch_torque_percentage
 6446              		.thumb
 6447              		.thumb_func
 6449              	AX12_set_punch_torque_percentage:
 6450              	.LFB189:
1618:../QS/QS_ax12.c **** 
1619:../QS/QS_ax12.c **** bool_e AX12_set_punch_torque_percentage(Uint8 id_servo, Uint8 percentage) {
 6451              		.loc 2 1619 0
 6452              		.cfi_startproc
 6453              		@ args = 0, pretend = 0, frame = 8
 6454              		@ frame_needed = 1, uses_anonymous_args = 0
 6455 2708 80B5     		push	{r7, lr}
 6456              	.LCFI236:
 6457              		.cfi_def_cfa_offset 8
 6458              		.cfi_offset 7, -8
 6459              		.cfi_offset 14, -4
 6460 270a 82B0     		sub	sp, sp, #8
 6461              	.LCFI237:
 6462              		.cfi_def_cfa_offset 16
 6463 270c 00AF     		add	r7, sp, #0
 6464              	.LCFI238:
 6465              		.cfi_def_cfa_register 7
 6466 270e 0246     		mov	r2, r0
 6467 2710 0B46     		mov	r3, r1
 6468 2712 FA71     		strb	r2, [r7, #7]
 6469 2714 BB71     		strb	r3, [r7, #6]
1620:../QS/QS_ax12.c **** 	if(percentage > AX12_MAX_PERCENTAGE) percentage = AX12_MAX_PERCENTAGE;
 6470              		.loc 2 1620 0
 6471 2716 BB79     		ldrb	r3, [r7, #6]	@ zero_extendqisi2
 6472 2718 642B     		cmp	r3, #100
 6473 271a 02D9     		bls	.L363
 6474              		.loc 2 1620 0 is_stmt 0 discriminator 1
 6475 271c 4FF06403 		mov	r3, #100
 6476 2720 BB71     		strb	r3, [r7, #6]
 6477              	.L363:
1621:../QS/QS_ax12.c **** 
1622:../QS/QS_ax12.c **** 	return AX12_instruction_write16(id_servo, AX12_TORQUE_LIMIT_L, AX12_PERCENTAGE_TO_1024(percentage)
 6478              		.loc 2 1622 0 is_stmt 1
 6479 2722 BB79     		ldrb	r3, [r7, #6]	@ zero_extendqisi2
 6480 2724 4FEA0322 		lsl	r2, r3, #8
 6481 2728 48F21F53 		movw	r3, #34079
 6482 272c C5F2EB13 		movt	r3, 20971
 6483 2730 83FB0213 		smull	r1, r3, r3, r2
 6484 2734 4FEAE301 		asr	r1, r3, #3
 6485 2738 4FEAE273 		asr	r3, r2, #31
 6486 273c CB1A     		subs	r3, r1, r3
 6487 273e 9BB2     		uxth	r3, r3
 6488 2740 FA79     		ldrb	r2, [r7, #7]	@ zero_extendqisi2
 6489 2742 1046     		mov	r0, r2
 6490 2744 4FF02201 		mov	r1, #34
 6491 2748 1A46     		mov	r2, r3
 6492 274a FDF7DFFE 		bl	AX12_instruction_write16
 6493 274e 0346     		mov	r3, r0
1623:../QS/QS_ax12.c **** }
 6494              		.loc 2 1623 0
 6495 2750 1846     		mov	r0, r3
 6496 2752 07F10807 		add	r7, r7, #8
 6497 2756 BD46     		mov	sp, r7
 6498 2758 80BD     		pop	{r7, pc}
 6499              		.cfi_endproc
 6500              	.LFE189:
 6502              		.bss
 6503              	initialized.6644:
 6504 06a3 00       		.space	1
 6505              		.align	2
 6506              	processing_state.6601:
 6507 06a4 00000000 		.space	4
 6508              		.align	2
 6509              	status_response_packet.6615:
 6510 06a8 00000000 		.space	6
 6510      0000
 6511 06ae 0000     		.text
 6512              	.Letext0:
 6513              		.file 3 "../stm32f4xx/stm32f4xx.h"
 6514              		.file 4 "c:\\program files (x86)\\eclipse-arm-eseo\\gcc-arm-none-eabi-4_7-2013q2-20130614-win32\\g
 6515              		.file 5 "../stm32f4xx/misc.h"
 6516              		.file 6 "../QS/QS_types.h"
 6517              		.file 7 "../QS/QS_ax12.h"
 6518              		.file 8 "../QS/QS_outputlog.h"
 6519              		.file 9 "../stm32f4xx/stm32f4xx_usart.h"
DEFINED SYMBOLS
                            *ABS*:00000000 QS_ax12.c
C:\Users\Amaury\AppData\Local\Temp\cccNtK9l.s:18     .text:00000000 $t
C:\Users\Amaury\AppData\Local\Temp\cccNtK9l.s:22     .text:00000000 NVIC_EnableIRQ
C:\Users\Amaury\AppData\Local\Temp\cccNtK9l.s:64     .text:00000038 NVIC_DisableIRQ
C:\Users\Amaury\AppData\Local\Temp\cccNtK9l.s:103    .rodata:00000000 $d
C:\Users\Amaury\AppData\Local\Temp\cccNtK9l.s:106    .rodata:00000000 AX12_values_ranges
C:\Users\Amaury\AppData\Local\Temp\cccNtK9l.s:158    .bss:00000000 $d
C:\Users\Amaury\AppData\Local\Temp\cccNtK9l.s:159    .bss:00000000 AX12_on_the_robot
C:\Users\Amaury\AppData\Local\Temp\cccNtK9l.s:162    .bss:00000048 state_machine
C:\Users\Amaury\AppData\Local\Temp\cccNtK9l.s:165    .bss:00000058 AX12_special_instruction_buffer
C:\Users\Amaury\AppData\Local\Temp\cccNtK9l.s:167    .bss:000006a2 AX12_prepare_commands
C:\Users\Amaury\AppData\Local\Temp\cccNtK9l.s:174    .text:00000074 AX12_instruction_async_read
C:\Users\Amaury\AppData\Local\Temp\cccNtK9l.s:2879   .text:000012dc AX12_instruction_queue_insert
C:\Users\Amaury\AppData\Local\Temp\cccNtK9l.s:235    .text:000000c0 AX12_instruction_async_write8
C:\Users\Amaury\AppData\Local\Temp\cccNtK9l.s:1425   .text:000007f0 AX12_decode_value_range
C:\Users\Amaury\AppData\Local\Temp\cccNtK9l.s:332    .text:00000158 AX12_instruction_async_write16
C:\Users\Amaury\AppData\Local\Temp\cccNtK9l.s:426    .text:000001ec AX12_instruction_async_prepare_write8
C:\Users\Amaury\AppData\Local\Temp\cccNtK9l.s:523    .text:00000284 AX12_instruction_async_prepare_write16
C:\Users\Amaury\AppData\Local\Temp\cccNtK9l.s:617    .text:00000318 AX12_instruction_async_execute_write
C:\Users\Amaury\AppData\Local\Temp\cccNtK9l.s:665    .text:00000350 AX12_instruction_read8
C:\Users\Amaury\AppData\Local\Temp\cccNtK9l.s:1214   .text:00000684 AX12_instruction_wait
C:\Users\Amaury\AppData\Local\Temp\cccNtK9l.s:1323   .text:00000758 AX12_instruction_get_last_status
C:\Users\Amaury\AppData\Local\Temp\cccNtK9l.s:762    .text:000003dc AX12_instruction_read16
C:\Users\Amaury\AppData\Local\Temp\cccNtK9l.s:859    .text:00000468 AX12_instruction_write8
C:\Users\Amaury\AppData\Local\Temp\cccNtK9l.s:965    .text:0000050c AX12_instruction_write16
C:\Users\Amaury\AppData\Local\Temp\cccNtK9l.s:1071   .text:000005b0 AX12_instruction_ping
C:\Users\Amaury\AppData\Local\Temp\cccNtK9l.s:1154   .text:00000630 AX12_instruction_buffer_is_full
C:\Users\Amaury\AppData\Local\Temp\cccNtK9l.s:1207   .rodata:00000034 .LC0
C:\Users\Amaury\AppData\Local\Temp\cccNtK9l.s:1372   .text:000007a0 AX12_instruction_reset_last_status
C:\Users\Amaury\AppData\Local\Temp\cccNtK9l.s:1470   .text:0000082c $d
C:\Users\Amaury\AppData\Local\Temp\cccNtK9l.s:1476   .text:0000083c $t
C:\Users\Amaury\AppData\Local\Temp\cccNtK9l.s:1569   .rodata:00000050 .LC1
C:\Users\Amaury\AppData\Local\Temp\cccNtK9l.s:1573   .rodata:0000009c .LC2
C:\Users\Amaury\AppData\Local\Temp\cccNtK9l.s:1581   .text:000008d4 AX12_instruction_packet_calc_checksum
C:\Users\Amaury\AppData\Local\Temp\cccNtK9l.s:1627   .text:00000914 $d
C:\Users\Amaury\AppData\Local\Temp\cccNtK9l.s:1633   .text:00000924 $t
C:\Users\Amaury\AppData\Local\Temp\cccNtK9l.s:1689   .rodata:000000e4 .LC3
C:\Users\Amaury\AppData\Local\Temp\cccNtK9l.s:1696   .text:00000980 AX12_get_instruction_packet
C:\Users\Amaury\AppData\Local\Temp\cccNtK9l.s:1737   .text:000009b0 $d
C:\Users\Amaury\AppData\Local\Temp\cccNtK9l.s:1747   .text:000009d0 $t
C:\Users\Amaury\AppData\Local\Temp\cccNtK9l.s:1805   .rodata:00000108 .LC4
C:\Users\Amaury\AppData\Local\Temp\cccNtK9l.s:1809   .rodata:00000150 .LC5
C:\Users\Amaury\AppData\Local\Temp\cccNtK9l.s:1817   .text:00000a24 AX12_status_packet_calc_checksum
C:\Users\Amaury\AppData\Local\Temp\cccNtK9l.s:1914   .rodata:00000194 .LC6
C:\Users\Amaury\AppData\Local\Temp\cccNtK9l.s:1917   .rodata:000001b0 .LC7
C:\Users\Amaury\AppData\Local\Temp\cccNtK9l.s:1925   .text:00000ab4 AX12_update_status_packet
C:\Users\Amaury\AppData\Local\Temp\cccNtK9l.s:1989   .text:00000b14 $d
C:\Users\Amaury\AppData\Local\Temp\cccNtK9l.s:1998   .text:00000b30 $t
C:\Users\Amaury\AppData\Local\Temp\cccNtK9l.s:2097   .rodata:000001f4 .LC8
C:\Users\Amaury\AppData\Local\Temp\cccNtK9l.s:2100   .rodata:00000210 .LC9
C:\Users\Amaury\AppData\Local\Temp\cccNtK9l.s:2103   .rodata:00000234 .LC10
C:\Users\Amaury\AppData\Local\Temp\cccNtK9l.s:2106   .rodata:0000024c .LC11
C:\Users\Amaury\AppData\Local\Temp\cccNtK9l.s:2113   .text:00000bc4 AX12_state_machine
C:\Users\Amaury\AppData\Local\Temp\cccNtK9l.s:6506   .bss:000006a4 processing_state.6601
C:\Users\Amaury\AppData\Local\Temp\cccNtK9l.s:6509   .bss:000006a8 status_response_packet.6615
C:\Users\Amaury\AppData\Local\Temp\cccNtK9l.s:2558   .text:00000fec $d
C:\Users\Amaury\AppData\Local\Temp\cccNtK9l.s:2561   .text:00000ff0 $t
C:\Users\Amaury\AppData\Local\Temp\cccNtK9l.s:2872   .rodata:00000264 .LC12
C:\Users\Amaury\AppData\Local\Temp\cccNtK9l.s:3035   .text:0000141c AX12_UART2_init
C:\Users\Amaury\AppData\Local\Temp\cccNtK9l.s:3133   .text:000014dc USART2_IRQHandler
C:\Users\Amaury\AppData\Local\Temp\cccNtK9l.s:3238   .rodata:0000028c .LC13
C:\Users\Amaury\AppData\Local\Temp\cccNtK9l.s:3246   .text:0000158c _T2Interrupt
C:\Users\Amaury\AppData\Local\Temp\cccNtK9l.s:3339   .text:0000162c AX12_init
C:\Users\Amaury\AppData\Local\Temp\cccNtK9l.s:6503   .bss:000006a3 initialized.6644
C:\Users\Amaury\AppData\Local\Temp\cccNtK9l.s:3454   .text:00001708 AX12_is_ready
C:\Users\Amaury\AppData\Local\Temp\cccNtK9l.s:3491   .text:00001728 AX12_get_last_error
C:\Users\Amaury\AppData\Local\Temp\cccNtK9l.s:3537   .text:00001760 AX12_reset_last_error
C:\Users\Amaury\AppData\Local\Temp\cccNtK9l.s:3572   .text:0000177c AX12_is_buffer_full
C:\Users\Amaury\AppData\Local\Temp\cccNtK9l.s:3600   .text:0000178c AX12_start_command_block
C:\Users\Amaury\AppData\Local\Temp\cccNtK9l.s:3631   .text:000017a4 AX12_end_command_block
C:\Users\Amaury\AppData\Local\Temp\cccNtK9l.s:3662   .text:000017bc AX12_config_is_locked
C:\Users\Amaury\AppData\Local\Temp\cccNtK9l.s:3706   .text:000017ec AX12_config_get_model_number
C:\Users\Amaury\AppData\Local\Temp\cccNtK9l.s:3745   .text:00001814 AX12_config_get_firmware_version
C:\Users\Amaury\AppData\Local\Temp\cccNtK9l.s:3784   .text:0000183c AX12_config_get_return_delay_time
C:\Users\Amaury\AppData\Local\Temp\cccNtK9l.s:3825   .text:00001868 AX12_config_get_minimal_angle
C:\Users\Amaury\AppData\Local\Temp\cccNtK9l.s:3872   .text:000018a4 AX12_config_get_maximal_angle
C:\Users\Amaury\AppData\Local\Temp\cccNtK9l.s:3919   .text:000018e0 AX12_config_get_temperature_limit
C:\Users\Amaury\AppData\Local\Temp\cccNtK9l.s:3958   .text:00001908 AX12_config_get_lowest_voltage
C:\Users\Amaury\AppData\Local\Temp\cccNtK9l.s:3997   .text:00001930 AX12_config_get_highest_voltage
C:\Users\Amaury\AppData\Local\Temp\cccNtK9l.s:4036   .text:00001958 AX12_config_get_maximum_torque
C:\Users\Amaury\AppData\Local\Temp\cccNtK9l.s:4098   .text:000019b8 AX12_config_get_status_return_mode
C:\Users\Amaury\AppData\Local\Temp\cccNtK9l.s:4137   .text:000019e0 AX12_config_get_error_before_led
C:\Users\Amaury\AppData\Local\Temp\cccNtK9l.s:4176   .text:00001a08 AX12_config_get_error_before_shutdown
C:\Users\Amaury\AppData\Local\Temp\cccNtK9l.s:4215   .text:00001a30 AX12_config_lock
C:\Users\Amaury\AppData\Local\Temp\cccNtK9l.s:4254   .text:00001a58 AX12_config_set_return_delay_time
C:\Users\Amaury\AppData\Local\Temp\cccNtK9l.s:4299   .text:00001a8c AX12_config_set_minimal_angle
C:\Users\Amaury\AppData\Local\Temp\cccNtK9l.s:4357   .text:00001ae0 AX12_config_set_maximal_angle
C:\Users\Amaury\AppData\Local\Temp\cccNtK9l.s:4423   .text:00001b40 AX12_config_set_temperature_limit
C:\Users\Amaury\AppData\Local\Temp\cccNtK9l.s:4465   .text:00001b6c AX12_config_set_lowest_voltage
C:\Users\Amaury\AppData\Local\Temp\cccNtK9l.s:4507   .text:00001b98 AX12_config_set_highest_voltage
C:\Users\Amaury\AppData\Local\Temp\cccNtK9l.s:4549   .text:00001bc4 AX12_config_set_maximum_torque_percentage
C:\Users\Amaury\AppData\Local\Temp\cccNtK9l.s:4601   .text:00001c0c AX12_config_set_status_return_mode
C:\Users\Amaury\AppData\Local\Temp\cccNtK9l.s:4643   .text:00001c38 AX12_config_set_error_before_led
C:\Users\Amaury\AppData\Local\Temp\cccNtK9l.s:4685   .text:00001c64 AX12_config_set_error_before_shutdown
C:\Users\Amaury\AppData\Local\Temp\cccNtK9l.s:4727   .text:00001c90 AX12_is_wheel_mode_enabled
C:\Users\Amaury\AppData\Local\Temp\cccNtK9l.s:4771   .text:00001cc4 AX12_is_torque_enabled
C:\Users\Amaury\AppData\Local\Temp\cccNtK9l.s:4815   .text:00001cf4 AX12_is_led_enabled
C:\Users\Amaury\AppData\Local\Temp\cccNtK9l.s:4859   .text:00001d24 AX12_get_torque_response
C:\Users\Amaury\AppData\Local\Temp\cccNtK9l.s:5029   .text:00001e4c AX12_get_position
C:\Users\Amaury\AppData\Local\Temp\cccNtK9l.s:5073   .rodata:000002b0 .LC14
C:\Users\Amaury\AppData\Local\Temp\cccNtK9l.s:5082   .text:00001e88 AX12_get_move_to_position_speed
C:\Users\Amaury\AppData\Local\Temp\cccNtK9l.s:5176   .rodata:00000314 .LC15
C:\Users\Amaury\AppData\Local\Temp\cccNtK9l.s:5186   .text:00001f30 AX12_get_speed_percentage
C:\Users\Amaury\AppData\Local\Temp\cccNtK9l.s:5285   .text:00001fdc AX12_get_torque_limit
C:\Users\Amaury\AppData\Local\Temp\cccNtK9l.s:5332   .text:00002018 AX12_get_punch_torque_percentage
C:\Users\Amaury\AppData\Local\Temp\cccNtK9l.s:5379   .text:00002054 AX12_get_load_percentage
C:\Users\Amaury\AppData\Local\Temp\cccNtK9l.s:5456   .text:000020c8 AX12_get_voltage
C:\Users\Amaury\AppData\Local\Temp\cccNtK9l.s:5495   .text:000020f0 AX12_get_temperature
C:\Users\Amaury\AppData\Local\Temp\cccNtK9l.s:5534   .text:00002118 AX12_is_instruction_prepared
C:\Users\Amaury\AppData\Local\Temp\cccNtK9l.s:5578   .text:00002148 AX12_is_moving
C:\Users\Amaury\AppData\Local\Temp\cccNtK9l.s:5622   .text:00002178 AX12_set_wheel_mode_enabled
C:\Users\Amaury\AppData\Local\Temp\cccNtK9l.s:5853   .text:00002344 AX12_set_torque_enabled
C:\Users\Amaury\AppData\Local\Temp\cccNtK9l.s:5900   .text:00002378 AX12_set_led_enabled
C:\Users\Amaury\AppData\Local\Temp\cccNtK9l.s:5947   .text:000023ac AX12_set_torque_response
C:\Users\Amaury\AppData\Local\Temp\cccNtK9l.s:6140   .text:00002520 AX12_set_position
C:\Users\Amaury\AppData\Local\Temp\cccNtK9l.s:6195   .rodata:0000037c .LC16
C:\Users\Amaury\AppData\Local\Temp\cccNtK9l.s:6204   .text:00002574 AX12_set_move_to_position_speed
C:\Users\Amaury\AppData\Local\Temp\cccNtK9l.s:6282   .rodata:000003e0 .LC17
C:\Users\Amaury\AppData\Local\Temp\cccNtK9l.s:6292   .text:00002600 AX12_set_speed_percentage
C:\Users\Amaury\AppData\Local\Temp\cccNtK9l.s:6391   .text:000026b4 AX12_set_torque_limit
C:\Users\Amaury\AppData\Local\Temp\cccNtK9l.s:6449   .text:00002708 AX12_set_punch_torque_percentage
                     .debug_frame:00000010 $d
                           .group:00000000 wm4.1.13c6c37fe6ef97541a459ad1f2cd1ddb
                           .group:00000000 wm4.QS_ax12.h.14.650b8e984ab5516ae7ea22170235fa2d
                           .group:00000000 wm4.stm32f4xx.h.54.d172d9d6631f11a8436908e748990b53
                           .group:00000000 wm4.core_cm4.h.32.39d0f71cd333856d56f1935d9037195e
                           .group:00000000 wm4.newlib.h.8.a9901dc52d1357e3e94003403d43f8b5
                           .group:00000000 wm4.features.h.22.b72b3baab2bb2eab3661375590100b6b
                           .group:00000000 wm4.config.h.193.5fb8ef056cdff92dec3dee9552839d8c
                           .group:00000000 wm4._ansi.h.23.b5bb84d7ba97d82b5b1dc1826a7ae811
                           .group:00000000 wm4.stdint.h.20.54ad762faa59e3c05491630641c8d8bf
                           .group:00000000 wm4.core_cmInstr.h.25.d8165482ef3061013a2fc83e2d85f3d9
                           .group:00000000 wm4.core_cm4_simd.h.29.013e5bcf58dba2d27c60184174208e07
                           .group:00000000 wm4.core_cm4.h.163.d36d54ebc869626f337c4fcb95a9b424
                           .group:00000000 wm4.stm32f4xx.h.306.7867854ab89778ccd63e1fde7c22c0b6
                           .group:00000000 wm4.stm32f4xx_rcc.h.65.29a27820bc754566c4190ed8ad1c1d80
                           .group:00000000 wm4.misc.h.31.041217492a6cb86f2fb26099f373a465
                           .group:00000000 wm4.stm32f4xx.h.7233.cb6cb3cb095c29e1fc0eb152d26090b1
                           .group:00000000 wm4.Global_config.h.14.bea53ddf4045d71f1c9fb87037131e8e
                           .group:00000000 wm4.config_global.h.12.5c30ea43d7f0d9daa101874e8ba75f6f
                           .group:00000000 wm4.config_qs.h.12.4699be7196e891fb4cd84d522e29cde7
                           .group:00000000 wm4.config_qs.h.12.8e0ab7f7cbbdaecfb1e464f5610b5d86
                           .group:00000000 wm4.QS_macro.h.19.3d2533714681986d2ad8c517737c4640
                           .group:00000000 wm4.QS_ax12.h.186.424226f3dc96f6793aff001a12253823
                           .group:00000000 wm4.QS_outputlog.h.12.c4345486982132d59ec2c51f5e320631
                           .group:00000000 wm4.stm32f4xx_usart.h.31.b8cf39d5de41afe6bafa390bb6ad93c6
                           .group:00000000 wm4.config_pin.h.12.92dbe1317fae649a069f2ce6e5ad725c
                           .group:00000000 wm4.config_pin.h.12.20ee5a96fdfc3c7ca3bc6056aaec7473
                           .group:00000000 wm4.stm32f4xx_tim.h.31.b1d608fbde729347e4ccf70799e654d2
                           .group:00000000 wm4.QS_timer.h.23.f1c7374d1ffe22793578c04386c6b1e2
                           .group:00000000 wm4.QS_setTimerSource.h.51.311478667205ed8486a34e0f995a2bbc

UNDEFINED SYMBOLS
OUTPUTLOG_printf
TIMER2_disableInt
TIMER2_run
USART_SendData
USART_ITConfig
USART_GetFlagStatus
TIMER2_stop
TIM_ClearITPendingBit
USART_ReceiveData
TIMER2_enableInt
PORTS_uarts_init
RCC_APB1PeriphClockCmd
USART_OverSampling8Cmd
USART_Init
USART_Cmd
NVIC_Init
USART_GetITStatus
TIMER_init
